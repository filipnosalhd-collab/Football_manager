<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>⚽ Football Manager Ultimate</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Russo+One&family=Roboto:wght@400;700;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.2/peerjs.min.js"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Rajdhani:wght@300;400;500;600;700&family=Exo+2:wght@400;500;600;700;800;900&display=swap");

      :root {
        --primary: #0d2818;
        --primary-light: #1a4d2e;
        --primary-dark: #061510;
        --gold: #ffd700;
        --gold-light: #ffe566;
        --gold-dark: #b8960b;
        --silver: #e8e8e8;
        --bronze: #cd7f32;
        --field-green: #2d8a4e;
        --field-dark: #1a5c32;
        --white-line: rgba(255, 255, 255, 0.95);
        --neon-green: #00ff88;
        --neon-blue: #00d4ff;
        --neon-purple: #a855f7;
        --danger: #ef4444;
        --success: #22c55e;
        --glass: rgba(255, 255, 255, 0.05);
        --glass-border: rgba(255, 255, 255, 0.1);
        --shadow-glow: 0 0 30px rgba(255, 215, 0, 0.3);
        --shadow-strong: 0 10px 40px rgba(0, 0, 0, 0.5);
        --gradient-gold: linear-gradient(
          135deg,
          #ffd700 0%,
          #ffed4a 50%,
          #f59e0b 100%
        );
        --gradient-dark: linear-gradient(180deg, #0d2818 0%, #061510 100%);
        --gradient-card: linear-gradient(
          145deg,
          rgba(255, 255, 255, 0.1) 0%,
          rgba(255, 255, 255, 0.02) 100%
        );
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Rajdhani", "Segoe UI", sans-serif;
        background: var(--gradient-dark);
        min-height: 100vh;
        color: white;
        overflow-x: hidden;
      }

      /* Scrollbar styling */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }

      ::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
      }

      ::-webkit-scrollbar-thumb {
        background: var(--gold-dark);
        border-radius: 10px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: var(--gold);
      }

      /* Global text improvements */
      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        font-family: "Orbitron", sans-serif;
        letter-spacing: 1px;
      }

      /* Animated background */
      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: radial-gradient(
            ellipse at 20% 20%,
            rgba(0, 255, 136, 0.08) 0%,
            transparent 50%
          ),
          radial-gradient(
            ellipse at 80% 80%,
            rgba(0, 212, 255, 0.08) 0%,
            transparent 50%
          ),
          radial-gradient(
            ellipse at 50% 50%,
            rgba(255, 215, 0, 0.05) 0%,
            transparent 70%
          );
        pointer-events: none;
        z-index: -1;
        animation: bgPulse 10s ease-in-out infinite;
      }

      @keyframes bgPulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }

      /* Mobile/Tablet block overlay */
      .mobile-block {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          135deg,
          #0a0a0a 0%,
          #1a1a2e 50%,
          #0f0f0f 100%
        );
        z-index: 99999;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: 2rem;
      }

      .mobile-block-icon {
        font-size: 5rem;
        margin-bottom: 1.5rem;
        animation: float 3s ease-in-out infinite;
      }

      @keyframes float {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-15px);
        }
      }

      .mobile-block-title {
        font-family: "Orbitron", sans-serif;
        font-size: 1.6rem;
        color: #ff6b6b;
        margin-bottom: 1rem;
        text-transform: uppercase;
        text-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
      }

      .mobile-block-message {
        font-family: "Rajdhani", sans-serif;
        font-size: 1.1rem;
        color: #aaa;
        max-width: 350px;
        line-height: 1.7;
        margin-bottom: 2rem;
      }

      .mobile-block-devices {
        display: flex;
        gap: 1.5rem;
        flex-wrap: wrap;
        justify-content: center;
      }

      .mobile-block-device {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        padding: 1rem;
        border-radius: 15px;
        background: rgba(255, 255, 255, 0.05);
        min-width: 80px;
        backdrop-filter: blur(10px);
        transition: transform 0.3s ease;
      }

      .mobile-block-device:hover {
        transform: scale(1.1);
      }

      .mobile-block-device-icon {
        font-size: 2.5rem;
      }

      .mobile-block-device.supported {
        border: 2px solid #4ade80;
        box-shadow: 0 0 20px rgba(74, 222, 128, 0.3);
      }

      .mobile-block-device.supported .mobile-block-device-icon {
        filter: drop-shadow(0 0 10px #4ade80);
      }

      .mobile-block-device.unsupported {
        border: 2px solid #ff6b6b;
        opacity: 0.6;
      }

      .mobile-block-device-label {
        font-size: 0.8rem;
        color: #888;
        font-family: "Rajdhani", sans-serif;
        font-weight: 600;
      }

      .mobile-block-device.supported .mobile-block-device-label {
        color: #4ade80;
      }

      .mobile-block-device.unsupported .mobile-block-device-label {
        color: #ff6b6b;
      }

      .mobile-block-footer {
        margin-top: 2rem;
        font-size: 0.85rem;
        color: #666;
      }

      /* Show block on mobile/tablet */
      @media (max-width: 1024px) {
        .mobile-block {
          display: flex !important;
        }
      }

      @media (pointer: coarse) {
        .mobile-block {
          display: flex !important;
        }
      }

      @media (hover: none) {
        .mobile-block {
          display: flex !important;
        }
      }

      body {
        font-family: "Roboto", sans-serif;
        background: linear-gradient(
          135deg,
          #0a1a0f 0%,
          #1a2f1a 50%,
          #0f2010 100%
        );
        min-height: 100vh;
        color: white;
        overflow-x: hidden;
      }

      /* ==================== MAIN MENU ==================== */
      .screen {
        display: none;
        min-height: 100vh;
        padding: 1.5rem;
        position: relative;
      }

      .screen.active {
        display: flex;
        flex-direction: column;
        align-items: center;
        animation: screenFadeIn 0.4s ease-out;
      }

      @keyframes screenFadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .game-title {
        font-family: "Orbitron", sans-serif;
        font-size: 2.8rem;
        font-weight: 800;
        background: var(--gradient-gold);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        filter: drop-shadow(0 4px 15px rgba(255, 215, 0, 0.4));
        margin: 2rem 0;
        text-align: center;
        letter-spacing: 3px;
        animation: titleGlow 3s ease-in-out infinite;
      }

      @keyframes titleGlow {
        0%,
        100% {
          filter: drop-shadow(0 4px 15px rgba(255, 215, 0, 0.4));
        }
        50% {
          filter: drop-shadow(0 4px 25px rgba(255, 215, 0, 0.7));
        }
      }

      .game-title span {
        display: block;
        font-family: "Exo 2", sans-serif;
        font-size: 1rem;
        font-weight: 500;
        letter-spacing: 8px;
        background: linear-gradient(90deg, var(--silver), white, var(--silver));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        margin-top: 0.5rem;
      }

      .menu-container {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
        max-width: 400px;
        width: 100%;
      }

      /* Arena System CSS */
      .arena-container {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        max-width: 500px;
        width: 100%;
        padding: 1rem;
      }

      .arena-info {
        background: linear-gradient(
          135deg,
          rgba(255, 215, 0, 0.1) 0%,
          rgba(0, 0, 0, 0.3) 100%
        );
        border: 2px solid var(--gold);
        border-radius: 15px;
        padding: 1.5rem;
        text-align: center;
      }

      .arena-current {
        font-size: 1.2rem;
        margin-bottom: 1rem;
      }

      .arena-name {
        color: var(--gold);
        font-weight: bold;
        font-size: 1.5rem;
        display: block;
        margin-top: 0.5rem;
      }

      .arena-rewards {
        display: flex;
        justify-content: space-around;
        margin: 1rem 0;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .reward-green {
        color: #4caf50;
        font-weight: bold;
      }
      .reward-red {
        color: #f44336;
        font-weight: bold;
      }
      .reward-gold {
        color: var(--gold);
        font-weight: bold;
      }

      .arena-tp-display {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid rgba(255, 215, 0, 0.3);
        font-size: 1.1rem;
      }

      .tp-value {
        color: var(--gold);
        font-weight: bold;
        font-size: 1.3rem;
      }

      /* Upgrade Slider CSS */
      .upgrade-slider-section {
        margin-top: 1rem;
        padding: 1rem;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
        border: 1px solid var(--gold);
      }

      .upgrade-slider-info {
        text-align: center;
        margin-bottom: 0.5rem;
        font-size: 1.1rem;
      }

      .upgrade-slider {
        width: 100%;
        height: 8px;
        border-radius: 4px;
        background: rgba(255, 255, 255, 0.1);
        outline: none;
        -webkit-appearance: none;
      }

      .upgrade-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: var(--gold);
        cursor: pointer;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      }

      .upgrade-slider::-moz-range-thumb {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: var(--gold);
        cursor: pointer;
        border: none;
      }

      .upgrade-slider-labels {
        display: flex;
        justify-content: space-between;
        color: var(--silver);
        font-size: 0.8rem;
        margin-top: 0.3rem;
      }

      .upgrade-preview {
        text-align: center;
        margin-top: 1rem;
        font-size: 1.2rem;
      }

      .upgrade-cost-preview {
        text-align: center;
        margin-top: 0.5rem;
        font-size: 1rem;
      }

      .arena-bot-info {
        color: var(--silver);
        font-size: 0.9rem;
      }

      .arena-actions {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
      }

      .arena-select-container {
        max-width: 600px;
        width: 100%;
        max-height: 70vh;
        overflow-y: auto;
        padding: 1rem;
      }

      .arena-list {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
      }

      .arena-item {
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.05) 0%,
          rgba(0, 0, 0, 0.2) 100%
        );
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .arena-item:hover {
        border-color: var(--gold);
        transform: scale(1.02);
      }

      .arena-item.current {
        border-color: var(--gold);
        background: linear-gradient(
          135deg,
          rgba(255, 215, 0, 0.2) 0%,
          rgba(0, 0, 0, 0.3) 100%
        );
      }

      .arena-item.locked {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .arena-item.locked:hover {
        transform: none;
      }

      .arena-item-info {
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
      }

      .arena-item-name {
        font-weight: bold;
        font-size: 1.1rem;
      }

      .arena-item-rewards {
        font-size: 0.85rem;
        color: var(--silver);
      }

      .arena-item-bot {
        font-size: 0.8rem;
        color: #888;
      }

      .arena-item-action {
        text-align: right;
      }

      .arena-unlock-price {
        color: var(--gold);
        font-weight: bold;
      }

      .arena-unlocked {
        color: #4caf50;
      }

      .menu-btn {
        font-family: "Orbitron", sans-serif;
        font-size: 1rem;
        font-weight: 600;
        padding: 1rem 2rem;
        border: none;
        border-radius: 12px;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.1) 0%,
          rgba(255, 255, 255, 0.02) 100%
        );
        color: white;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        text-transform: uppercase;
        letter-spacing: 1px;
        position: relative;
        overflow: hidden;
        backdrop-filter: blur(10px);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3),
          inset 0 1px 0 rgba(255, 255, 255, 0.1),
          inset 0 -1px 0 rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 215, 0, 0.3);
      }

      .menu-btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 215, 0, 0.2),
          transparent
        );
        transition: left 0.5s;
      }

      .menu-btn:hover::before {
        left: 100%;
      }

      .menu-btn:hover {
        transform: translateY(-3px) scale(1.02);
        box-shadow: 0 8px 25px rgba(255, 215, 0, 0.3),
          inset 0 1px 0 rgba(255, 255, 255, 0.2);
        border-color: var(--gold);
      }

      .menu-btn:active {
        transform: translateY(0) scale(0.98);
      }

      .menu-btn.gold {
        background: var(--gradient-gold);
        color: #1a1a1a;
        font-weight: 700;
        border: none;
        box-shadow: 0 4px 20px rgba(255, 215, 0, 0.4),
          inset 0 2px 0 rgba(255, 255, 255, 0.3);
      }

      .menu-btn.gold:hover {
        box-shadow: 0 8px 30px rgba(255, 215, 0, 0.6),
          inset 0 2px 0 rgba(255, 255, 255, 0.4);
      }

      /* ==================== ACCOUNT SECTION ==================== */
      .account-panel {
        background: linear-gradient(
          145deg,
          rgba(0, 0, 0, 0.6) 0%,
          rgba(0, 0, 0, 0.3) 100%
        );
        border: 2px solid rgba(255, 215, 0, 0.5);
        border-radius: 20px;
        padding: 1.5rem;
        margin-bottom: 2rem;
        width: 100%;
        max-width: 500px;
        backdrop-filter: blur(20px);
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4),
          inset 0 1px 0 rgba(255, 255, 255, 0.05);
        position: relative;
        overflow: hidden;
      }

      .account-panel::before {
        content: "";
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(
          circle,
          rgba(255, 215, 0, 0.05) 0%,
          transparent 50%
        );
        animation: panelShine 8s linear infinite;
      }

      @keyframes panelShine {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .account-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        position: relative;
        z-index: 1;
      }

      .account-name {
        font-family: "Orbitron", sans-serif;
        font-size: 1.5rem;
        color: var(--gold);
      }

      .account-balance {
        font-family: "Orbitron", sans-serif;
        font-size: 1.3rem;
        font-weight: 700;
        color: var(--neon-green);
        text-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
      }

      .account-balance::before {
        content: "€";
        margin-right: 0.3rem;
      }

      .squad-overall {
        text-align: center;
        padding: 0.75rem;
        background: rgba(255, 215, 0, 0.1);
        border-radius: 10px;
      }

      .squad-overall-stats {
        display: flex;
        gap: 1.5rem;
        justify-content: center;
        align-items: center;
      }

      .squad-stat {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .squad-stat-value {
        font-family: "Russo One", sans-serif;
        font-size: 1.5rem;
        color: white;
      }

      .squad-stat.main .squad-stat-value {
        font-size: 2.5rem;
        color: var(--gold);
      }

      .squad-stat-label {
        font-size: 0.7rem;
        color: var(--silver);
      }

      .squad-stat.main .squad-stat-label {
        font-size: 0.85rem;
        color: var(--gold);
      }

      /* ==================== PLAYER CARD ==================== */
      .player-card {
        width: 160px;
        height: 230px;
        border-radius: 15px;
        position: relative;
        cursor: pointer;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        transform-style: preserve-3d;
        filter: drop-shadow(0 10px 20px rgba(0, 0, 0, 0.4));
      }

      .player-card.small {
        width: 120px;
        height: 170px;
      }

      .player-card:hover {
        transform: translateY(-10px) scale(1.08) rotateX(5deg);
        filter: drop-shadow(0 20px 40px rgba(0, 0, 0, 0.5));
      }

      .player-card-inner {
        width: 100%;
        height: 100%;
        position: relative;
        transform-style: preserve-3d;
        transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .player-card.flipped .player-card-inner {
        transform: rotateY(180deg);
      }

      .player-card-front,
      .player-card-back {
        position: absolute;
        width: 100%;
        height: 100%;
        backface-visibility: hidden;
        border-radius: 15px;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 0.6rem;
        overflow: hidden;
      }

      .player-card-front::before {
        content: "";
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: linear-gradient(
          45deg,
          transparent 30%,
          rgba(255, 255, 255, 0.15) 50%,
          transparent 70%
        );
        animation: cardShine 4s ease-in-out infinite;
        pointer-events: none;
      }

      @keyframes cardShine {
        0% {
          transform: translateX(-100%) rotate(45deg);
        }
        100% {
          transform: translateX(100%) rotate(45deg);
        }
      }

      /* Card tiers based on overall */
      .player-card.tier-bronze .player-card-front {
        background: linear-gradient(
          160deg,
          #654321 0%,
          #8b4513 30%,
          #cd7f32 60%,
          #a0522d 100%
        );
        border: 3px solid #cd7f32;
        box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.3);
      }

      .player-card.tier-silver .player-card-front {
        background: linear-gradient(
          160deg,
          #5a5a5a 0%,
          #8a8a8a 30%,
          #d4d4d4 60%,
          #9a9a9a 100%
        );
        border: 3px solid #d4d4d4;
        box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.2);
      }

      .player-card.tier-gold .player-card-front {
        background: linear-gradient(
          160deg,
          #8b6914 0%,
          #daa520 30%,
          #ffd700 60%,
          #b8860b 100%
        );
        border: 3px solid #ffd700;
        box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.2),
          0 0 20px rgba(255, 215, 0, 0.3);
      }

      .player-card.tier-elite .player-card-front {
        background: linear-gradient(
          160deg,
          #1a0a2e 0%,
          #4a00e0 40%,
          #8e2de2 70%,
          #6a0dad 100%
        );
        border: 3px solid #a855f7;
        box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.3),
          0 0 30px rgba(168, 85, 247, 0.5);
        animation: elitePulse 3s ease-in-out infinite;
      }

      @keyframes elitePulse {
        0%,
        100% {
          box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.3),
            0 0 20px rgba(168, 85, 247, 0.4);
        }
        50% {
          box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.3),
            0 0 40px rgba(168, 85, 247, 0.7);
        }
      }

      .player-card.tier-icon .player-card-front {
        background: linear-gradient(
          160deg,
          #000814 0%,
          #001d3d 30%,
          #003566 60%,
          #001d3d 100%
        );
        border: 3px solid var(--neon-blue);
        box-shadow: inset 0 0 40px rgba(0, 212, 255, 0.2),
          0 0 40px rgba(0, 212, 255, 0.5);
        animation: iconGlow 2s ease-in-out infinite;
      }

      @keyframes iconGlow {
        0%,
        100% {
          box-shadow: inset 0 0 40px rgba(0, 212, 255, 0.2),
            0 0 30px rgba(0, 212, 255, 0.4);
          border-color: var(--neon-blue);
        }
        50% {
          box-shadow: inset 0 0 40px rgba(0, 212, 255, 0.3),
            0 0 50px rgba(0, 212, 255, 0.8);
          border-color: #80eaff;
        }
      }

      .player-card-back {
        background: linear-gradient(
          160deg,
          #0a0a0a 0%,
          #1a1a2e 50%,
          #0a0a0a 100%
        );
        border: 3px solid rgba(255, 255, 255, 0.2);
        transform: rotateY(180deg);
        justify-content: center;
        box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.5);
      }

      .card-overall {
        font-family: "Orbitron", sans-serif;
        font-size: 2.2rem;
        font-weight: 900;
        color: white;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8),
          0 0 20px rgba(255, 255, 255, 0.3);
        line-height: 1;
      }

      .card-position {
        font-family: "Orbitron", sans-serif;
        font-size: 0.8rem;
        font-weight: 700;
        color: white;
        opacity: 0.95;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }

      .card-player-silhouette {
        width: 70px;
        height: 70px;
        background: radial-gradient(
          circle,
          rgba(255, 255, 255, 0.25) 0%,
          rgba(255, 255, 255, 0.05) 100%
        );
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2.5rem;
        margin: 0.3rem 0;
        box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.1),
          0 5px 15px rgba(0, 0, 0, 0.3);
      }

      .card-country {
        font-size: 1.5rem;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
      }

      .card-stats-mini {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.3rem;
        font-size: 0.7rem;
        width: 100%;
        margin-top: auto;
      }

      .player-card.small .card-stats-mini {
        font-size: 0.6rem;
        gap: 0.2rem;
      }

      .stat-mini {
        text-align: center;
        background: rgba(0, 0, 0, 0.4);
        padding: 0.2rem;
        border-radius: 5px;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .stat-mini-value {
        font-family: "Orbitron", sans-serif;
        font-weight: 700;
        font-size: 0.8rem;
      }

      .card-name-back {
        font-family: "Russo One", sans-serif;
        font-size: 1rem;
        color: white;
        text-align: center;
        margin-bottom: 0.5rem;
      }

      .card-details-back {
        font-size: 0.8rem;
        color: var(--silver);
        text-align: center;
      }

      /* ==================== SQUAD SELECTION ==================== */
      .formation-selector {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        justify-content: center;
        margin-bottom: 1rem;
      }

      .formation-btn {
        padding: 0.5rem 1rem;
        border: 2px solid var(--gold);
        border-radius: 5px;
        background: transparent;
        color: white;
        cursor: pointer;
        font-family: "Russo One", sans-serif;
        transition: all 0.3s;
      }

      .formation-btn.selected {
        background: var(--gold);
        color: #1a1a1a;
      }

      .pitch-container {
        width: 100%;
        max-width: 600px;
        aspect-ratio: 3/4;
        background: linear-gradient(
          to bottom,
          var(--field-green) 0%,
          var(--field-dark) 100%
        );
        border-radius: 10px;
        position: relative;
        overflow: hidden;
        border: 3px solid white;
      }

      /* Pitch markings */
      .pitch-container::before {
        content: "";
        position: absolute;
        top: 50%;
        left: 5%;
        right: 5%;
        height: 2px;
        background: var(--white-line);
      }

      .pitch-center-circle {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100px;
        height: 100px;
        border: 2px solid var(--white-line);
        border-radius: 50%;
      }

      .pitch-penalty-area {
        position: absolute;
        left: 20%;
        right: 20%;
        height: 15%;
        border: 2px solid var(--white-line);
        border-top: none;
      }

      .pitch-penalty-area.top {
        top: 0;
        border-top: none;
        border-bottom: 2px solid var(--white-line);
      }

      .pitch-penalty-area.bottom {
        bottom: 0;
        border-bottom: none;
        border-top: 2px solid var(--white-line);
      }

      .pitch-goal-area {
        position: absolute;
        left: 35%;
        right: 35%;
        height: 5%;
        border: 2px solid var(--white-line);
      }

      .pitch-goal-area.top {
        top: 0;
        border-top: none;
      }

      .pitch-goal-area.bottom {
        bottom: 0;
        border-bottom: none;
      }

      .pitch-slot {
        position: absolute;
        width: 50px;
        height: 50px;
        background: rgba(255, 255, 255, 0.2);
        border: 2px dashed rgba(255, 255, 255, 0.5);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s;
        font-size: 0.7rem;
        color: white;
      }

      .pitch-slot:hover {
        background: rgba(255, 215, 0, 0.3);
        border-color: var(--gold);
      }

      .pitch-slot.filled {
        background: rgba(255, 255, 255, 0.9);
        border: none;
      }

      .pitch-slot .player-mini {
        width: 100%;
        height: 100%;
        border-radius: 50%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-size: 0.6rem;
        color: #1a1a1a;
      }

      .pitch-slot .player-mini-overall {
        font-family: "Russo One", sans-serif;
        font-size: 1rem;
      }

      /* Position warning - wrong position */
      .pitch-slot .position-warning {
        position: absolute;
        top: -8px;
        right: -8px;
        width: 20px;
        height: 20px;
        background: #ff4444;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.9rem;
        font-weight: bold;
        color: white;
        animation: warningPulse 1s ease-in-out infinite;
        z-index: 10;
        border: 2px solid white;
      }

      @keyframes warningPulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.2);
        }
      }

      /* Bench section */
      .bench-section {
        margin-top: 1.5rem;
        padding: 1rem;
        background: rgba(0, 0, 0, 0.4);
        border-radius: 10px;
        border: 2px solid var(--gold);
        max-width: 600px;
        width: 100%;
      }

      .bench-title {
        font-family: "Russo One", sans-serif;
        color: var(--gold);
        margin-bottom: 1rem;
        text-align: center;
      }

      .bench-players {
        display: flex;
        gap: 0.5rem;
        overflow-x: auto;
        padding: 0.5rem;
        justify-content: center;
        flex-wrap: wrap;
      }

      .bench-slot {
        width: 60px;
        height: 80px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px dashed rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s;
        position: relative;
      }

      .bench-slot:hover {
        background: rgba(255, 215, 0, 0.2);
        border-color: var(--gold);
      }

      .bench-slot.filled {
        background: rgba(255, 255, 255, 0.9);
        border: none;
      }

      .bench-slot .player-mini {
        width: 100%;
        height: 100%;
        border-radius: 6px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: #1a1a1a;
        font-size: 0.6rem;
      }

      .bench-slot .player-mini-overall {
        font-family: "Russo One", sans-serif;
        font-size: 1.2rem;
      }

      .bench-slot .position-warning {
        position: absolute;
        top: -5px;
        right: -5px;
        width: 16px;
        height: 16px;
        background: #ff4444;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.7rem;
        font-weight: bold;
        color: white;
        animation: warningPulse 1s ease-in-out infinite;
        z-index: 10;
        border: 2px solid white;
      }

      /* Player Selection Modal */
      .player-select-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.95);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }

      .player-select-modal.active {
        display: flex;
      }

      .player-select-panel {
        background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
        border: 2px solid var(--gold);
        border-radius: 15px;
        padding: 1.5rem;
        max-width: 800px;
        width: 95%;
        max-height: 90vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      .player-select-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
      }

      .player-select-header h2 {
        color: var(--gold);
        font-family: "Russo One", sans-serif;
      }

      .player-select-slot-info {
        background: rgba(255, 215, 0, 0.2);
        padding: 0.5rem 1rem;
        border-radius: 20px;
        color: var(--gold);
        font-weight: bold;
      }

      .player-select-tabs {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 1rem;
      }

      .player-tab {
        flex: 1;
        padding: 0.8rem;
        border: 2px solid var(--gold);
        border-radius: 8px;
        background: transparent;
        color: white;
        cursor: pointer;
        font-family: "Russo One", sans-serif;
        transition: all 0.3s;
      }

      .player-tab.active {
        background: var(--gold);
        color: #1a1a1a;
      }

      .player-select-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 1rem;
        overflow-y: auto;
        max-height: 50vh;
        padding: 1rem;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
      }

      .player-select-item {
        cursor: pointer;
        transition: all 0.3s;
        position: relative;
      }

      .player-select-item:hover {
        transform: scale(1.05);
      }

      .player-select-item.current {
        outline: 3px solid #4ade80;
        outline-offset: 3px;
      }

      .player-select-item .select-badge {
        position: absolute;
        top: -10px;
        left: 50%;
        transform: translateX(-50%);
        background: #4ade80;
        color: #1a1a1a;
        padding: 0.2rem 0.5rem;
        border-radius: 10px;
        font-size: 0.6rem;
        font-weight: bold;
      }

      .player-select-item .wrong-pos-badge {
        position: absolute;
        bottom: -10px;
        left: 50%;
        transform: translateX(-50%);
        background: #ff4444;
        color: white;
        padding: 0.2rem 0.5rem;
        border-radius: 10px;
        font-size: 0.6rem;
        font-weight: bold;
        white-space: nowrap;
      }

      .player-select-buttons {
        margin-top: 1rem;
        display: flex;
        justify-content: center;
      }

      /* ==================== MATCH GAMEPLAY ==================== */
      /* ==================== 3D MATCH WITH CAMERA ==================== */
      .match-screen-3d {
        width: 100%;
        height: 100vh;
        position: relative;
        overflow: hidden;
        background: linear-gradient(
          180deg,
          #87ceeb 0%,
          #4a90c2 30%,
          #2d5a2d 50%,
          #1a3a1a 100%
        );
        cursor: crosshair;
      }

      /* 3D World container */
      .world-3d {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        perspective: 1000px;
        perspective-origin: 50% 60%;
        overflow: hidden;
      }

      .pitch-3d {
        position: absolute;
        width: 200%;
        height: 300%;
        left: -50%;
        top: -50%;
        transform-style: preserve-3d;
        transition: transform 0.3s ease-out;
      }

      .grass-3d {
        position: absolute;
        width: 50%;
        height: 33.33%;
        left: 25%;
        top: 33.33%;
        background: repeating-linear-gradient(
          90deg,
          #3d8b40 0px,
          #3d8b40 5%,
          #358538 5%,
          #358538 10%
        );
        border: 6px solid white;
        transform: rotateX(70deg) translateZ(0);
        transform-origin: center center;
      }

      /* Pitch lines */
      .pitch-line.center {
        position: absolute;
        top: 50%;
        left: 0;
        right: 0;
        height: 4px;
        background: white;
        transform: translateY(-50%);
      }

      .pitch-circle {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 20%;
        height: 15%;
        border: 4px solid white;
        border-radius: 50%;
        transform: translate(-50%, -50%);
      }

      .penalty-box {
        position: absolute;
        left: 25%;
        right: 25%;
        height: 18%;
        border: 4px solid white;
      }

      .penalty-box.near {
        bottom: 0;
        border-bottom: none;
      }

      .penalty-box.far {
        top: 0;
        border-top: none;
      }

      /* Goals */
      .goal-3d {
        position: absolute;
        left: 35%;
        right: 35%;
        height: 8%;
        transform-style: preserve-3d;
      }

      .goal-3d.far {
        top: -8%;
      }

      .goal-3d.near {
        bottom: -8%;
      }

      .goal-post {
        position: absolute;
        width: 8px;
        height: 100%;
        background: white;
        border-radius: 4px;
      }

      .goal-post.left {
        left: 0;
      }
      .goal-post.right {
        right: 0;
      }

      .goal-crossbar {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 8px;
        background: white;
      }

      .goal-3d.near .goal-crossbar {
        top: auto;
        bottom: 0;
      }

      .goal-net {
        position: absolute;
        left: 8px;
        right: 8px;
        height: 70%;
        background: repeating-linear-gradient(
            90deg,
            transparent 0px,
            transparent 10px,
            rgba(255, 255, 255, 0.4) 10px,
            rgba(255, 255, 255, 0.4) 12px
          ),
          repeating-linear-gradient(
            0deg,
            transparent 0px,
            transparent 10px,
            rgba(255, 255, 255, 0.4) 10px,
            rgba(255, 255, 255, 0.4) 12px
          );
        background-color: rgba(180, 180, 180, 0.3);
      }

      .goal-3d.far .goal-net {
        top: 8px;
      }

      .goal-3d.near .goal-net {
        bottom: 8px;
      }

      /* HUD */
      .match-hud-3d {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        padding: 0.8rem;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 2rem;
        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0.8) 0%,
          transparent 100%
        );
        z-index: 100;
      }

      .match-score-panel {
        display: flex;
        align-items: center;
        gap: 1rem;
        background: rgba(0, 0, 0, 0.7);
        padding: 0.5rem 1.5rem;
        border-radius: 30px;
        border: 2px solid var(--gold);
      }

      .match-score-panel .team-name {
        font-size: 0.9rem;
        color: var(--silver);
      }

      .match-score-panel .score {
        font-family: "Russo One", sans-serif;
        font-size: 2rem;
        color: white;
      }

      .match-score-panel .separator {
        color: var(--gold);
        font-size: 1.5rem;
      }

      .match-time-3d {
        font-family: "Russo One", sans-serif;
        font-size: 1.2rem;
        color: var(--gold);
        background: rgba(0, 0, 0, 0.7);
        padding: 0.4rem 1rem;
        border-radius: 20px;
      }

      /* Turn timer */
      .turn-timer {
        position: absolute;
        top: 70px;
        left: 50%;
        transform: translateX(-50%);
        width: 300px;
        height: 30px;
        background: rgba(0, 0, 0, 0.8);
        border-radius: 15px;
        overflow: hidden;
        border: 2px solid var(--gold);
        z-index: 100;
      }

      .turn-timer-bar {
        height: 100%;
        background: linear-gradient(
          90deg,
          #4ade80 0%,
          #fbbf24 50%,
          #ef4444 100%
        );
        transition: width 0.1s linear;
        width: 100%;
      }

      .turn-timer-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: "Russo One", sans-serif;
        font-size: 0.85rem;
        color: white;
        text-shadow: 1px 1px 3px black;
      }

      /* Turn indicator */
      .turn-indicator {
        position: absolute;
        top: 110px;
        left: 50%;
        transform: translateX(-50%);
        font-family: "Russo One", sans-serif;
        font-size: 1.5rem;
        color: var(--gold);
        text-shadow: 2px 2px 4px black;
        z-index: 100;
        animation: pulse 1s ease-in-out infinite;
      }

      .turn-indicator.opponent {
        color: #ff6b6b;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.6;
        }
      }

      .match-buttons-3d {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        gap: 0.5rem;
        z-index: 100;
      }

      /* 3D Player */
      .player-3d {
        position: absolute;
        transform-style: preserve-3d;
        cursor: pointer;
        transition: left 0.4s ease-out, top 0.4s ease-out;
        z-index: 10;
      }

      .player-3d-body {
        transform: rotateX(-70deg);
        transform-origin: bottom center;
      }

      .player-3d .head {
        width: 24px;
        height: 24px;
        background: radial-gradient(
          circle at 30% 30%,
          #ffd4a3 0%,
          #d4a574 100%
        );
        border-radius: 50%;
        margin: 0 auto 2px;
        border: 2px solid #333;
      }

      .player-3d .body {
        width: 32px;
        height: 40px;
        background: linear-gradient(180deg, #ffffff 0%, #e8e8e8 100%);
        border-radius: 8px 8px 4px 4px;
        margin: 0 auto;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid #333;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      .player-3d .number {
        font-family: "Russo One", sans-serif;
        font-size: 0.8rem;
        color: #1a1a1a;
      }

      .player-3d.opponent .body {
        background: linear-gradient(180deg, #ff5555 0%, #cc3333 100%);
      }

      .player-3d.opponent .number {
        color: white;
      }

      .player-3d .shadow {
        width: 30px;
        height: 10px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 50%;
        margin: 2px auto 0;
      }

      .player-3d .name-tag {
        position: absolute;
        top: -25px;
        left: 50%;
        transform: translateX(-50%) rotateX(-70deg);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 3px 8px;
        border-radius: 5px;
        font-size: 0.65rem;
        white-space: nowrap;
        font-weight: bold;
      }

      .player-3d.has-ball .body {
        animation: hasBall 0.8s ease-in-out infinite;
        box-shadow: 0 0 20px var(--gold), 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      @keyframes hasBall {
        0%,
        100% {
          box-shadow: 0 0 15px var(--gold);
        }
        50% {
          box-shadow: 0 0 30px var(--gold);
        }
      }

      /* Ball */
      .ball-3d {
        position: absolute;
        width: 18px;
        height: 18px;
        background: radial-gradient(
          circle at 35% 35%,
          #fff 0%,
          #ddd 40%,
          #999 100%
        );
        border-radius: 50%;
        box-shadow: 2px 3px 6px rgba(0, 0, 0, 0.4);
        z-index: 15;
        transition: left 0.3s, top 0.3s;
      }

      .ball-3d.shooting {
        transition: all 0.6s ease-out;
        z-index: 50;
      }

      /* Controls help */
      .controls-help-3d {
        position: absolute;
        bottom: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        padding: 1rem;
        border-radius: 15px;
        font-size: 0.75rem;
        color: var(--silver);
        z-index: 100;
        line-height: 1.8;
      }

      .controls-help-3d b {
        color: var(--gold);
      }

      /* Ball holder panel */
      .ball-holder-panel {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.85);
        padding: 1rem 1.5rem;
        border-radius: 15px;
        border: 2px solid var(--gold);
        z-index: 100;
      }

      .holder-name {
        font-family: "Russo One", sans-serif;
        font-size: 1.2rem;
        color: white;
      }

      .holder-pos {
        color: var(--gold);
        font-size: 0.85rem;
        margin-bottom: 0.3rem;
      }

      .holder-stats {
        display: flex;
        gap: 1rem;
        font-size: 0.75rem;
        color: var(--silver);
      }

      /* Pass line */
      .pass-line-svg {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 50;
        display: none;
      }

      /* Cards display */
      .cards-display-3d {
        position: absolute;
        top: 110px;
        left: 20px;
        display: flex;
        gap: 5px;
        z-index: 100;
      }

      /* Goal celebration */
      .goal-celebration {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.85);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 500;
      }

      .goal-celebration.active {
        display: flex;
      }

      .goal-text {
        font-family: "Russo One", sans-serif;
        font-size: 6rem;
        color: var(--gold);
        text-shadow: 0 0 40px var(--gold), 0 0 80px var(--gold);
        animation: goalBounce 0.4s ease-in-out infinite;
      }

      @keyframes goalBounce {
        0%,
        100% {
          transform: scale(1) rotate(-2deg);
        }
        50% {
          transform: scale(1.1) rotate(2deg);
        }
      }

      /* Foul message */
      .foul-message {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        font-family: "Russo One", sans-serif;
        font-size: 4rem;
        color: #ff4444;
        text-shadow: 3px 3px 6px black;
        z-index: 400;
        transition: transform 0.3s;
      }

      .foul-message.active {
        transform: translate(-50%, -50%) scale(1);
      }

      /* Card display */
      .card-display {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0) rotate(-10deg);
        width: 80px;
        height: 120px;
        border-radius: 8px;
        z-index: 450;
        transition: transform 0.3s;
      }

      .card-display.yellow {
        background: linear-gradient(
          135deg,
          #ffd700 0%,
          #ffed4a 50%,
          #ffd700 100%
        );
        transform: translate(-50%, -50%) scale(1) rotate(-10deg);
      }

      .card-display.red {
        background: linear-gradient(
          135deg,
          #dc2626 0%,
          #ef4444 50%,
          #dc2626 100%
        );
        transform: translate(-50%, -50%) scale(1) rotate(-10deg);
      }

      .mini-card {
        width: 15px;
        height: 22px;
        border-radius: 2px;
      }

      .mini-card.yellow {
        background: #ffd700;
      }
      .mini-card.red {
        background: #dc2626;
      }

      /* ==================== PENALTY SHOOTOUT ==================== */
      .penalty-container {
        max-width: 600px;
        width: 100%;
        padding: 1rem;
        text-align: center;
      }

      .penalty-score {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        padding: 1rem;
        background: rgba(0, 0, 0, 0.6);
        border-radius: 15px;
        border: 2px solid var(--gold);
      }

      .penalty-team {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .penalty-team .team-label {
        color: var(--silver);
        font-size: 0.8rem;
      }

      .penalty-team .team-score {
        font-family: "Russo One", sans-serif;
        font-size: 3rem;
        color: white;
      }

      .penalty-round {
        font-family: "Russo One", sans-serif;
        color: var(--gold);
        font-size: 1.2rem;
      }

      .penalty-dots {
        display: flex;
        justify-content: space-between;
        margin-bottom: 1.5rem;
        padding: 0 2rem;
      }

      .dots-row {
        display: flex;
        gap: 0.5rem;
      }

      .dot {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.3);
      }

      .dot.scored {
        background: #4ade80;
        border-color: #22c55e;
      }

      .dot.missed {
        background: #ef4444;
        border-color: #dc2626;
      }

      .penalty-goal-view {
        position: relative;
        width: 100%;
        height: 250px;
        background: linear-gradient(180deg, #87ceeb 0%, #228b22 70%);
        border-radius: 15px;
        overflow: hidden;
        margin-bottom: 1rem;
      }

      .goal-frame-penalty {
        position: absolute;
        bottom: 15%;
        left: 10%;
        right: 10%;
        height: 60%;
        border: 10px solid white;
        border-bottom: none;
        display: flex;
        box-shadow: 0 0 30px rgba(255, 255, 255, 0.3),
          inset 0 0 50px rgba(0, 0, 0, 0.3);
        border-radius: 5px 5px 0 0;
      }

      .goal-zone {
        flex: 1;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        z-index: 10;
        border-right: 1px solid rgba(255, 255, 255, 0.1);
      }

      .goal-zone:last-child {
        border-right: none;
      }

      .goal-zone:hover {
        background: radial-gradient(
          circle at center,
          rgba(255, 215, 0, 0.4) 0%,
          transparent 70%
        );
        box-shadow: inset 0 0 30px rgba(255, 215, 0, 0.2);
      }

      .goal-zone.selected {
        background: radial-gradient(
          circle at center,
          rgba(255, 215, 0, 0.6) 0%,
          rgba(255, 215, 0, 0.2) 70%
        );
        box-shadow: inset 0 0 40px rgba(255, 215, 0, 0.3);
      }

      .goal-zone.highlight-green {
        background: radial-gradient(
          circle at center,
          rgba(0, 255, 136, 0.7) 0%,
          rgba(0, 255, 136, 0.2) 70%
        ) !important;
        box-shadow: inset 0 0 50px rgba(0, 255, 136, 0.4) !important;
      }

      .goal-zone.highlight-red {
        background: radial-gradient(
          circle at center,
          rgba(239, 68, 68, 0.7) 0%,
          rgba(239, 68, 68, 0.2) 70%
        ) !important;
        box-shadow: inset 0 0 50px rgba(239, 68, 68, 0.4) !important;
      }

      .goal-net-penalty {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: repeating-linear-gradient(
            90deg,
            transparent,
            transparent 12px,
            rgba(255, 255, 255, 0.15) 12px,
            rgba(255, 255, 255, 0.15) 14px
          ),
          repeating-linear-gradient(
            0deg,
            transparent,
            transparent 12px,
            rgba(255, 255, 255, 0.15) 12px,
            rgba(255, 255, 255, 0.15) 14px
          );
        pointer-events: none;
      }

      .goalkeeper-penalty {
        position: absolute;
        bottom: 5px;
        left: 50%;
        transform: translateX(-50%);
        width: 50px;
        height: 70px;
        background: linear-gradient(180deg, var(--gold) 0%, #ff9500 100%);
        border-radius: 15px 15px 8px 8px;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 5;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
      }

      .goalkeeper-penalty::before {
        content: "";
        position: absolute;
        top: -22px;
        left: 50%;
        transform: translateX(-50%);
        width: 28px;
        height: 28px;
        background: linear-gradient(180deg, #ffd4a3 0%, #e8b080 100%);
        border-radius: 50%;
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
      }

      .goalkeeper-penalty::after {
        content: "";
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        width: 35px;
        height: 8px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 5px;
      }

      .goalkeeper-penalty.dive-left {
        left: 15%;
        transform: translateX(-50%) rotate(-35deg) scaleX(1.2);
      }

      .goalkeeper-penalty.dive-right {
        left: 85%;
        transform: translateX(-50%) rotate(35deg) scaleX(1.2);
      }

      .ball-penalty {
        position: absolute;
        bottom: -30px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 2.5rem;
        transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 15;
        filter: drop-shadow(0 5px 10px rgba(0, 0, 0, 0.5));
      }

      .ball-penalty.shoot-left {
        bottom: 50%;
        left: 20%;
        animation: ballSpin 0.5s linear;
      }

      .ball-penalty.shoot-center {
        bottom: 70%;
        left: 50%;
        animation: ballSpin 0.5s linear;
      }

      .ball-penalty.shoot-right {
        bottom: 50%;
        left: 80%;
        animation: ballSpin 0.5s linear;
      }

      @keyframes ballSpin {
        from {
          transform: translateX(-50%) rotate(0deg);
        }
        to {
          transform: translateX(-50%) rotate(720deg);
        }
      }

      .ball-penalty.shoot-miss {
        bottom: 150%;
        left: 30%;
        opacity: 0;
        transition: all 0.25s ease-out;
      }

      /* Card reveal animation */
      .penalty-card-reveal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        z-index: 600;
        animation: cardReveal 1.5s ease-out forwards;
      }

      @keyframes cardReveal {
        0% {
          transform: translate(-50%, -50%) scale(0) rotateY(0deg);
        }
        15% {
          transform: translate(-50%, -50%) scale(1.2) rotateY(180deg);
        }
        30% {
          transform: translate(-50%, -50%) scale(1) rotateY(360deg);
        }
        45% {
          transform: translate(-50%, -50%) scale(1.1) rotateY(540deg);
        }
        60% {
          transform: translate(-50%, -50%) scale(1) rotateY(720deg);
        }
        80% {
          transform: translate(-50%, -50%) scale(1) rotateY(720deg);
        }
        100% {
          transform: translate(-50%, -50%) scale(0) rotateY(720deg);
        }
      }

      .penalty-card-reveal .player-card {
        transform: scale(1.5);
      }

      .shooter-info {
        background: rgba(0, 0, 0, 0.6);
        padding: 0.8rem;
        border-radius: 10px;
        margin-bottom: 1rem;
      }

      .shooter-name {
        font-family: "Russo One", sans-serif;
        color: white;
        font-size: 1.2rem;
      }

      .shooter-stats {
        color: var(--gold);
        font-size: 0.9rem;
      }

      .penalty-action {
        font-family: "Russo One", sans-serif;
        color: var(--gold);
        font-size: 1.1rem;
        margin-bottom: 1rem;
        animation: pulse 1s ease-in-out infinite;
      }

      .penalty-buttons {
        display: flex;
        justify-content: center;
        gap: 1rem;
        margin-bottom: 1rem;
      }

      .penalty-btn {
        padding: 1rem 1.5rem;
        font-family: "Orbitron", sans-serif;
        font-size: 0.9rem;
        font-weight: 600;
        background: linear-gradient(
          145deg,
          rgba(255, 215, 0, 0.2) 0%,
          rgba(255, 215, 0, 0.05) 100%
        );
        border: 2px solid var(--gold);
        border-radius: 12px;
        color: white;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        backdrop-filter: blur(10px);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        position: relative;
        overflow: hidden;
      }

      .penalty-btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 215, 0, 0.3),
          transparent
        );
        transition: left 0.4s;
      }

      .penalty-btn:hover::before {
        left: 100%;
      }

      .penalty-btn:hover {
        background: linear-gradient(
          145deg,
          rgba(255, 215, 0, 0.4) 0%,
          rgba(255, 215, 0, 0.1) 100%
        );
        transform: translateY(-5px) scale(1.05);
        box-shadow: 0 8px 25px rgba(255, 215, 0, 0.3);
      }

      .penalty-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none;
      }

      .penalty-result {
        font-family: "Orbitron", sans-serif;
        font-size: 2.2rem;
        font-weight: 800;
        min-height: 3rem;
        margin-bottom: 0.5rem;
        text-shadow: 0 0 30px currentColor;
      }

      .penalty-result.goal {
        color: var(--neon-green);
        animation: goalBounce 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        text-shadow: 0 0 40px var(--neon-green);
      }

      .penalty-result.save {
        color: #fbbf24;
        text-shadow: 0 0 30px #fbbf24;
      }

      .penalty-result.miss {
        color: var(--danger);
        text-shadow: 0 0 30px var(--danger);
        animation: missShake 0.5s ease-in-out;
      }

      @keyframes goalBounce {
        0% {
          transform: scale(0.5);
          opacity: 0;
        }
        50% {
          transform: scale(1.3);
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      @keyframes missShake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-10px);
        }
        75% {
          transform: translateX(10px);
        }
      }

      .surrender-btn {
        position: absolute;
        bottom: 20px;
        right: 20px;
        padding: 0.8rem 1.2rem;
        font-family: "Orbitron", sans-serif;
        font-size: 0.9rem;
        background: linear-gradient(145deg, #4a1a1a, #2a0a0a);
        border: 2px solid #ff4444;
        border-radius: 10px;
        color: #ff4444;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 100;
      }

      .surrender-btn:hover {
        background: linear-gradient(145deg, #5a2a2a, #3a1a1a);
        transform: scale(1.05);
        box-shadow: 0 0 15px rgba(255, 68, 68, 0.3);
      }

      /* ==================== FREE KICK STYLES ==================== */
      .mode-indicator {
        font-family: "Orbitron", sans-serif;
        font-size: 0.9rem;
        color: var(--gold);
        background: rgba(0, 0, 0, 0.5);
        padding: 0.3rem 1rem;
        border-radius: 20px;
        margin-bottom: 0.5rem;
      }

      .distance-info {
        font-family: "Rajdhani", sans-serif;
        font-size: 1rem;
        color: var(--silver);
        margin-bottom: 0.5rem;
      }

      .freekick-goal-view {
        position: relative;
        width: 100%;
        height: 280px;
        background: linear-gradient(180deg, #87ceeb 0%, #228b22 70%);
        border-radius: 15px;
        overflow: hidden;
        margin-bottom: 1rem;
        cursor: crosshair;
      }

      .goal-frame-freekick {
        position: absolute;
        bottom: 20%;
        left: 15%;
        right: 15%;
        height: 50%;
        border: 8px solid white;
        border-bottom: none;
        border-radius: 5px 5px 0 0;
        box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
      }

      .goal-net-freekick {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: repeating-linear-gradient(
            90deg,
            transparent,
            transparent 15px,
            rgba(255, 255, 255, 0.1) 15px,
            rgba(255, 255, 255, 0.1) 17px
          ),
          repeating-linear-gradient(
            0deg,
            transparent,
            transparent 15px,
            rgba(255, 255, 255, 0.1) 15px,
            rgba(255, 255, 255, 0.1) 17px
          );
        pointer-events: none;
      }

      .goalkeeper-freekick {
        position: absolute;
        bottom: 5px;
        left: 50%;
        transform: translateX(-50%);
        width: 40px;
        height: 60px;
        background: linear-gradient(180deg, #ff9500 0%, #ff6600 100%);
        border-radius: 12px 12px 6px 6px;
        z-index: 5;
        transition: all 0.5s ease;
      }

      .goalkeeper-freekick::before {
        content: "";
        position: absolute;
        top: -18px;
        left: 50%;
        transform: translateX(-50%);
        width: 22px;
        height: 22px;
        background: #ffd4a3;
        border-radius: 50%;
      }

      .ball-freekick {
        position: absolute;
        bottom: -30px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 2rem;
        z-index: 10;
        transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .ball-freekick.shooting {
        animation: ballCurve 0.8s ease-out forwards;
      }

      @keyframes ballCurve {
        0% {
          bottom: -30px;
          transform: translateX(-50%) scale(1);
        }
        50% {
          bottom: 60%;
          transform: translateX(var(--curve-x, 0)) scale(0.7);
        }
        100% {
          bottom: var(--target-y, 50%);
          left: var(--target-x, 50%);
          transform: translateX(-50%) scale(0.5);
        }
      }

      .aim-cursor {
        position: absolute;
        font-size: 1.5rem;
        color: rgba(255, 0, 0, 0.8);
        pointer-events: none;
        z-index: 20;
        display: none;
        text-shadow: 0 0 10px red;
        transform: translate(-50%, -50%);
      }

      .aim-cursor.active {
        display: block;
      }

      .wall-freekick {
        position: absolute;
        bottom: -15px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 1.5rem;
        letter-spacing: -5px;
        z-index: 3;
        filter: brightness(0.7);
      }

      /* Curve Meter (Speedometer style) */
      .curve-meter {
        background: rgba(0, 0, 0, 0.7);
        border-radius: 15px;
        padding: 1rem;
        margin-bottom: 1rem;
        border: 2px solid var(--gold);
      }

      .curve-meter-label {
        font-family: "Orbitron", sans-serif;
        color: var(--gold);
        font-size: 0.8rem;
        margin-bottom: 0.5rem;
      }

      .curve-meter-arc {
        position: relative;
        width: 200px;
        height: 100px;
        margin: 0 auto;
        background: conic-gradient(
          from 180deg,
          #ff4444 0deg,
          #ffff00 90deg,
          #44ff44 180deg
        );
        border-radius: 200px 200px 0 0;
        overflow: hidden;
      }

      .curve-meter-arc::before {
        content: "";
        position: absolute;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 140px;
        height: 70px;
        background: rgba(0, 0, 0, 0.9);
        border-radius: 140px 140px 0 0;
      }

      .curve-meter-needle {
        position: absolute;
        bottom: 5px;
        left: 50%;
        width: 4px;
        height: 80px;
        background: linear-gradient(to top, var(--gold) 0%, white 100%);
        transform-origin: bottom center;
        transform: translateX(-50%) rotate(0deg);
        border-radius: 2px;
        z-index: 5;
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
      }

      .curve-meter-center {
        position: absolute;
        bottom: -5px;
        left: 50%;
        transform: translateX(-50%);
        width: 20px;
        height: 20px;
        background: var(--gold);
        border-radius: 50%;
        z-index: 6;
      }

      .curve-meter-labels {
        display: flex;
        justify-content: space-between;
        padding: 0 20px;
        font-family: "Orbitron", sans-serif;
        font-size: 0.8rem;
        color: var(--silver);
      }

      /* Power Meter */
      .power-meter {
        background: rgba(0, 0, 0, 0.7);
        border-radius: 15px;
        padding: 1rem;
        margin-bottom: 1rem;
        border: 2px solid var(--gold);
      }

      .power-meter-label {
        font-family: "Orbitron", sans-serif;
        color: var(--gold);
        font-size: 0.8rem;
        margin-bottom: 0.5rem;
      }

      .power-meter-bar {
        position: relative;
        width: 100%;
        height: 30px;
        background: linear-gradient(
          90deg,
          #44ff44 0%,
          #ffff00 50%,
          #ff4444 80%,
          #aa0000 100%
        );
        border-radius: 15px;
        overflow: hidden;
      }

      .power-meter-fill {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        width: 100%;
        transition: width 0.05s linear;
      }

      .power-meter-max {
        position: absolute;
        top: 0;
        height: 100%;
        width: 4px;
        background: white;
        z-index: 5;
        box-shadow: 0 0 10px white;
      }

      .power-meter-indicator {
        position: absolute;
        top: -5px;
        width: 10px;
        height: 40px;
        background: var(--gold);
        border-radius: 3px;
        z-index: 10;
        box-shadow: 0 0 15px var(--gold);
      }

      /* ==================== MARKET ==================== */
      .market-container {
        max-width: 1200px;
        width: 100%;
        padding: 1rem;
      }

      .market-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        padding: 1rem;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 15px;
        border: 2px solid var(--gold);
      }

      .market-timer {
        color: var(--silver);
        font-size: 0.9rem;
      }

      .market-timer span {
        color: var(--gold);
        font-family: "Russo One", sans-serif;
      }

      .market-cards {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
        gap: 1.5rem;
        justify-items: center;
      }

      .market-card-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer;
        transition: transform 0.2s;
      }

      .market-card-wrapper:hover {
        transform: scale(1.05);
      }

      .market-card-price {
        color: var(--gold);
        font-family: "Russo One", sans-serif;
        font-size: 1.1rem;
      }

      .market-card-timer {
        color: var(--silver);
        font-size: 0.8rem;
      }

      /* ==================== MODALS ==================== */
      .negotiation-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.9);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 1rem;
      }

      .negotiation-modal.active {
        display: flex;
      }

      .negotiation-panel {
        background: linear-gradient(135deg, #1a2a1a 0%, #0d1a0d 100%);
        border: 3px solid var(--gold);
        border-radius: 20px;
        padding: 0;
        max-width: 450px;
        width: 100%;
        max-height: 90vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      /* Chat header with card */
      .chat-header {
        background: linear-gradient(135deg, #2d5a3d 0%, #1a472a 100%);
        padding: 1rem;
        display: flex;
        align-items: center;
        gap: 1rem;
        border-bottom: 2px solid var(--gold);
      }

      .chat-header .player-card {
        transform: scale(0.6);
        transform-origin: left center;
        margin: -20px 0;
      }

      .chat-player-info {
        flex: 1;
      }

      .chat-player-info h3 {
        color: white;
        font-family: "Russo One", sans-serif;
        margin: 0;
      }

      .chat-player-info p {
        color: var(--silver);
        font-size: 0.85rem;
        margin: 0.25rem 0;
      }

      .chat-player-info .price {
        color: var(--gold);
        font-weight: bold;
      }

      .chat-close {
        background: none;
        border: none;
        color: white;
        font-size: 1.5rem;
        cursor: pointer;
        padding: 0.5rem;
      }

      /* Chat messages area */
      .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
        background: #0a1a0a;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        min-height: 200px;
        max-height: 300px;
      }

      .chat-message {
        max-width: 85%;
        padding: 0.75rem 1rem;
        border-radius: 15px;
        font-size: 0.9rem;
        line-height: 1.4;
        animation: messageIn 0.3s ease-out;
      }

      @keyframes messageIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .chat-message.agent {
        background: #2d3748;
        color: white;
        align-self: flex-start;
        border-bottom-left-radius: 5px;
      }

      .chat-message.player {
        background: var(--primary-light);
        color: white;
        align-self: flex-end;
        border-bottom-right-radius: 5px;
      }

      .chat-message .sender {
        font-size: 0.7rem;
        color: var(--gold);
        margin-bottom: 0.25rem;
        font-weight: bold;
      }

      /* Offer input area */
      .chat-offer-area {
        background: #1a2a1a;
        padding: 1rem;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
      }

      .offer-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.5rem;
        margin-bottom: 0.75rem;
      }

      .offer-input {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .offer-input label {
        font-size: 0.7rem;
        color: var(--silver);
      }

      .offer-input input {
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        padding: 0.5rem;
        color: white;
        font-size: 0.9rem;
      }

      .offer-input input:focus {
        outline: none;
        border-color: var(--gold);
      }

      .chat-buttons {
        display: flex;
        gap: 0.5rem;
      }

      .chat-buttons button {
        flex: 1;
        padding: 0.75rem;
        border: none;
        border-radius: 10px;
        font-family: "Russo One", sans-serif;
        font-size: 0.85rem;
        cursor: pointer;
        transition: all 0.2s;
      }

      .btn-send {
        background: linear-gradient(135deg, var(--gold) 0%, #b8860b 100%);
        color: #1a1a1a;
      }

      .btn-send:hover {
        transform: scale(1.02);
      }

      .btn-leave {
        background: #4a1a1a;
        color: white;
      }

      .btn-leave:hover {
        background: #6a2a2a;
      }

      /* Tension bar */
      .tension-bar-container {
        padding: 0.75rem 1rem;
        background: rgba(0, 0, 0, 0.3);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .tension-label {
        font-size: 0.75rem;
        color: var(--silver);
        margin-bottom: 0.3rem;
        font-family: "Rajdhani", sans-serif;
      }

      .tension-bar {
        height: 8px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 10px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .tension-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(
          90deg,
          var(--neon-green) 0%,
          #fbbf24 50%,
          var(--danger) 100%
        );
        border-radius: 10px;
        transition: width 0.5s ease;
      }

      .tension-warning {
        display: none;
        font-size: 0.75rem;
        color: var(--danger);
        margin-top: 0.3rem;
        animation: warningPulse 1s infinite;
      }

      @keyframes warningPulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      /* Phase title */
      .phase-title {
        font-family: "Orbitron", sans-serif;
        font-size: 0.85rem;
        color: var(--gold);
        margin-bottom: 0.75rem;
        text-align: center;
        padding-bottom: 0.5rem;
        border-bottom: 1px solid rgba(255, 215, 0, 0.3);
      }

      /* Swap section */
      .swap-section {
        margin: 0.75rem 0;
        padding: 0.75rem;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .swap-toggle {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer;
        font-size: 0.9rem;
        color: var(--silver);
      }

      .swap-toggle input[type="checkbox"] {
        width: 18px;
        height: 18px;
        accent-color: var(--gold);
      }

      .swap-player-select {
        margin-top: 0.75rem;
      }

      .swap-player-select select {
        width: 100%;
        padding: 0.6rem;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 215, 0, 0.3);
        border-radius: 8px;
        color: white;
        font-family: "Rajdhani", sans-serif;
        font-size: 0.95rem;
      }

      .swap-player-select select:focus {
        outline: none;
        border-color: var(--gold);
      }

      .swap-player-value {
        margin-top: 0.5rem;
        font-size: 0.85rem;
        color: var(--neon-green);
        text-align: center;
      }

      /* ==================== UPGRADE SCREEN ==================== */
      .upgrade-container {
        max-width: 1000px;
        width: 95%;
        margin: 0 auto;
      }

      .upgrade-tabs {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 1.5rem;
        justify-content: center;
      }

      .upgrade-tab {
        padding: 0.8rem 2rem;
        font-family: "Orbitron", sans-serif;
        font-size: 0.9rem;
        font-weight: 600;
        background: linear-gradient(
          145deg,
          rgba(255, 255, 255, 0.05) 0%,
          rgba(255, 255, 255, 0.02) 100%
        );
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        color: var(--silver);
        cursor: pointer;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
      }

      .upgrade-tab:hover {
        border-color: var(--gold);
        color: white;
      }

      .upgrade-tab.active {
        background: linear-gradient(
          145deg,
          rgba(255, 215, 0, 0.2) 0%,
          rgba(255, 215, 0, 0.05) 100%
        );
        border-color: var(--gold);
        color: var(--gold);
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
      }

      .upgrade-players-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 1rem;
        padding: 1rem;
        min-height: 300px;
      }

      .upgrade-player-card {
        display: flex;
        flex-direction: column;
        align-items: center;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .upgrade-player-card:hover {
        transform: translateY(-8px) scale(1.05);
      }

      .upgrade-player-card .player-card {
        width: 120px !important;
        height: 175px !important;
      }

      /* ==================== UPGRADE MODAL ==================== */
      .upgrade-modal-content {
        max-width: 550px;
        background: linear-gradient(160deg, #0d1f15 0%, #0a1810 100%);
        border-radius: 20px;
        border: 2px solid rgba(255, 215, 0, 0.3);
        overflow: hidden;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      }

      .upgrade-modal-header {
        display: flex;
        gap: 1.5rem;
        align-items: center;
        padding: 1.5rem;
        background: linear-gradient(
          135deg,
          rgba(255, 215, 0, 0.1) 0%,
          transparent 100%
        );
        border-bottom: 1px solid rgba(255, 215, 0, 0.2);
      }

      .upgrade-modal-header .player-card {
        flex-shrink: 0;
      }

      .upgrade-player-info h2 {
        font-family: "Orbitron", sans-serif;
        font-size: 1.3rem;
        color: white;
        margin-bottom: 0.3rem;
      }

      .upgrade-player-info p {
        color: var(--silver);
        font-size: 0.95rem;
      }

      .upgrade-section {
        padding: 1.2rem 1.5rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .upgrade-section-title {
        font-family: "Orbitron", sans-serif;
        font-size: 0.85rem;
        font-weight: 600;
        margin-bottom: 1rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .upgrade-section-title.stats {
        color: var(--gold);
      }

      .upgrade-section-title.positions {
        color: var(--neon-blue);
      }

      .upgrade-stats-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 0.6rem;
      }

      .upgrade-stat-btn {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.7rem 1rem;
        background: linear-gradient(
          145deg,
          rgba(255, 255, 255, 0.08) 0%,
          rgba(255, 255, 255, 0.02) 100%
        );
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .upgrade-stat-btn:hover:not(.maxed) {
        background: linear-gradient(
          145deg,
          rgba(255, 215, 0, 0.15) 0%,
          rgba(255, 215, 0, 0.05) 100%
        );
        border-color: var(--gold);
        transform: translateX(3px);
      }

      .upgrade-stat-btn.selected {
        background: linear-gradient(
          145deg,
          rgba(255, 215, 0, 0.25) 0%,
          rgba(255, 215, 0, 0.1) 100%
        );
        border-color: var(--gold);
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
      }

      .upgrade-stat-btn.maxed {
        opacity: 0.4;
        cursor: not-allowed;
        background: rgba(100, 100, 100, 0.1);
      }

      .upgrade-stat-btn .stat-info {
        display: flex;
        flex-direction: column;
      }

      .upgrade-stat-btn .upgrade-stat-name {
        font-family: "Rajdhani", sans-serif;
        font-weight: 600;
        font-size: 0.85rem;
      }

      .upgrade-stat-btn .upgrade-stat-max {
        font-size: 0.7rem;
        color: var(--neon-green);
      }

      .upgrade-stat-btn .stat-values {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .upgrade-stat-btn .upgrade-stat-value {
        font-family: "Orbitron", sans-serif;
        font-size: 1rem;
        color: var(--gold);
      }

      .upgrade-stat-btn .stat-arrow {
        color: var(--neon-green);
        font-size: 0.8rem;
      }

      .upgrade-stat-btn .stat-new-value {
        font-family: "Orbitron", sans-serif;
        font-size: 1rem;
        color: var(--neon-green);
      }

      .upgrade-positions-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        justify-content: center;
      }

      .position-btn {
        padding: 0.6rem 1rem;
        background: linear-gradient(
          145deg,
          rgba(255, 255, 255, 0.08) 0%,
          rgba(255, 255, 255, 0.02) 100%
        );
        border: 2px solid rgba(255, 255, 255, 0.15);
        border-radius: 8px;
        color: white;
        cursor: pointer;
        font-family: "Orbitron", sans-serif;
        font-size: 0.8rem;
        font-weight: 600;
        transition: all 0.3s ease;
      }

      .position-btn:hover:not(.current):not(:disabled) {
        background: linear-gradient(
          145deg,
          rgba(0, 212, 255, 0.2) 0%,
          rgba(0, 212, 255, 0.05) 100%
        );
        border-color: var(--neon-blue);
        transform: scale(1.05);
      }

      .position-btn.selected {
        background: linear-gradient(
          145deg,
          rgba(0, 212, 255, 0.3) 0%,
          rgba(0, 212, 255, 0.1) 100%
        );
        border-color: var(--neon-blue);
        box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
      }

      .position-btn.current {
        background: linear-gradient(
          145deg,
          rgba(0, 255, 136, 0.2) 0%,
          rgba(0, 255, 136, 0.05) 100%
        );
        border-color: var(--neon-green);
        cursor: default;
      }

      .position-btn.expensive {
        border-color: rgba(239, 68, 68, 0.5);
      }

      .position-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .position-cost-info {
        text-align: center;
        margin-top: 0.8rem;
        font-size: 0.8rem;
        color: var(--silver);
      }

      .upgrade-cost-section {
        padding: 1.2rem 1.5rem;
        background: linear-gradient(
          145deg,
          rgba(255, 215, 0, 0.08) 0%,
          rgba(255, 215, 0, 0.02) 100%
        );
        text-align: center;
      }

      .upgrade-cost-label {
        font-family: "Rajdhani", sans-serif;
        font-size: 0.8rem;
        color: var(--silver);
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .upgrade-cost-value {
        font-family: "Orbitron", sans-serif;
        font-size: 1.8rem;
        font-weight: 700;
        color: var(--gold);
        margin: 0.3rem 0;
        text-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
      }

      .upgrade-effect {
        font-size: 0.9rem;
        color: var(--neon-green);
      }

      .upgrade-buttons {
        display: flex;
        gap: 0.8rem;
        padding: 1.2rem 1.5rem;
      }

      .upgrade-buttons .menu-btn {
        flex: 1;
      }

      .upgrade-buttons .btn-cancel {
        background: linear-gradient(
          145deg,
          rgba(239, 68, 68, 0.2) 0%,
          rgba(239, 68, 68, 0.05) 100%
        ) !important;
        border-color: rgba(239, 68, 68, 0.5) !important;
      }

      .upgrade-buttons .btn-cancel:hover {
        background: linear-gradient(
          145deg,
          rgba(239, 68, 68, 0.3) 0%,
          rgba(239, 68, 68, 0.1) 100%
        ) !important;
      }

      /* ==================== ONLINE LOBBY ==================== */

      /* ==================== SQUAD REVEAL ANIMATION ==================== */
      .squad-reveal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(180deg, #0a1a10 0%, #061510 100%);
        z-index: 10000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      .squad-reveal-title {
        font-family: "Orbitron", sans-serif;
        font-size: 1.5rem;
        color: var(--gold);
        margin-bottom: 2rem;
        text-transform: uppercase;
        letter-spacing: 3px;
        animation: titlePulse 2s ease-in-out infinite;
      }

      @keyframes titlePulse {
        0%,
        100% {
          opacity: 1;
          text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        50% {
          opacity: 0.8;
          text-shadow: 0 0 40px rgba(255, 215, 0, 0.8);
        }
      }

      .squad-reveal-position-label {
        font-family: "Orbitron", sans-serif;
        font-size: 1rem;
        color: var(--silver);
        margin-bottom: 1rem;
        text-transform: uppercase;
        letter-spacing: 2px;
      }

      .squad-reveal-card-container {
        perspective: 1000px;
        margin-bottom: 2rem;
      }

      .squad-reveal-card {
        animation: cardReveal 0.8s ease-out forwards;
        transform-style: preserve-3d;
      }

      @keyframes cardReveal {
        0% {
          transform: scale(0.3) rotateY(180deg);
          opacity: 0;
        }
        50% {
          transform: scale(1.1) rotateY(90deg);
          opacity: 0.5;
        }
        100% {
          transform: scale(1) rotateY(0deg);
          opacity: 1;
        }
      }

      .squad-reveal-card .player-card {
        width: 180px !important;
        height: 260px !important;
      }

      .squad-reveal-progress {
        display: flex;
        gap: 0.5rem;
        margin-top: 1rem;
      }

      .squad-reveal-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
        transition: all 0.3s ease;
      }

      .squad-reveal-dot.active {
        background: var(--gold);
        box-shadow: 0 0 10px var(--gold);
      }

      .squad-reveal-dot.done {
        background: var(--neon-green);
      }

      /* Full squad display */
      .squad-reveal-full {
        display: none;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
        animation: fullSquadReveal 1s ease-out forwards;
      }

      @keyframes fullSquadReveal {
        0% {
          opacity: 0;
          transform: scale(0.8);
        }
        100% {
          opacity: 1;
          transform: scale(1);
        }
      }

      .squad-reveal-formation {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.8rem;
      }

      .squad-reveal-row {
        display: flex;
        gap: 0.5rem;
        justify-content: center;
        flex-wrap: wrap;
      }

      .squad-reveal-row .player-card {
        width: 80px !important;
        height: 115px !important;
      }

      .squad-reveal-row .card-overall {
        font-size: 1.2rem !important;
      }

      .squad-reveal-row .card-position {
        font-size: 0.5rem !important;
      }

      .squad-reveal-row .card-player-silhouette {
        width: 35px !important;
        height: 35px !important;
        font-size: 1.2rem !important;
      }

      .squad-reveal-row .card-stats-mini {
        display: none !important;
      }

      /* Mini card for opponent reveal */
      .mini-reveal-card {
        width: 70px;
        height: 90px;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-family: "Orbitron", sans-serif;
        border: 2px solid;
      }

      .mini-reveal-card.common {
        background: linear-gradient(145deg, #4a4a4a, #2a2a2a);
        border-color: #666;
      }
      .mini-reveal-card.uncommon {
        background: linear-gradient(145deg, #2e5a2e, #1a3a1a);
        border-color: #4caf50;
      }
      .mini-reveal-card.rare {
        background: linear-gradient(145deg, #1a3a5a, #0d2040);
        border-color: #2196f3;
      }
      .mini-reveal-card.epic {
        background: linear-gradient(145deg, #4a2a6a, #2a1a4a);
        border-color: #9c27b0;
      }
      .mini-reveal-card.legendary {
        background: linear-gradient(145deg, #5a4a1a, #3a2a0a);
        border-color: #ffd700;
      }
      .mini-reveal-card.icon {
        background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
        border-color: #00bfff;
      }

      .mini-card-ovr {
        font-size: 1.5rem;
        font-weight: bold;
        color: white;
      }

      .mini-card-pos {
        font-size: 0.6rem;
        color: var(--gold);
        margin-top: 2px;
      }

      .mini-card-name {
        font-size: 0.5rem;
        color: white;
        text-align: center;
        margin-top: 4px;
        max-width: 65px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      /* BIG ACTION INDICATOR */
      .penalty-action-indicator {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        padding: 15px 40px;
        border-radius: 15px;
        font-family: "Orbitron", sans-serif;
        font-size: 2rem;
        font-weight: bold;
        text-transform: uppercase;
        z-index: 100;
        animation: actionPulse 1s ease infinite;
      }

      .penalty-action-indicator.shooting {
        background: linear-gradient(145deg, #ff6b00, #ff4500);
        border: 3px solid #ffaa00;
        color: white;
        box-shadow: 0 0 30px rgba(255, 107, 0, 0.7);
      }

      .penalty-action-indicator.saving {
        background: linear-gradient(145deg, #00a8ff, #0066cc);
        border: 3px solid #00ddff;
        color: white;
        box-shadow: 0 0 30px rgba(0, 168, 255, 0.7);
      }

      @keyframes actionPulse {
        0%,
        100% {
          transform: translateX(-50%) scale(1);
        }
        50% {
          transform: translateX(-50%) scale(1.05);
        }
      }

      .squad-reveal-vs {
        font-family: "Orbitron", sans-serif;
        font-size: 2rem;
        color: var(--gold);
        margin: 1rem 0;
        text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
      }

      .squad-reveal-opponent-name {
        font-family: "Orbitron", sans-serif;
        font-size: 1.3rem;
        color: #ff6b6b;
        margin-bottom: 1rem;
        text-transform: uppercase;
        letter-spacing: 2px;
      }

      .squad-reveal-ready-btn {
        margin-top: 1.5rem;
        padding: 1rem 3rem;
        font-family: "Orbitron", sans-serif;
        font-size: 1.1rem;
        background: var(--gradient-gold);
        border: none;
        border-radius: 12px;
        color: #1a1a1a;
        cursor: pointer;
        font-weight: 700;
        transition: all 0.3s ease;
        box-shadow: 0 5px 20px rgba(255, 215, 0, 0.4);
      }

      .squad-reveal-ready-btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 30px rgba(255, 215, 0, 0.6);
      }

      .squad-reveal-waiting {
        font-family: "Rajdhani", sans-serif;
        font-size: 1rem;
        color: var(--silver);
        margin-top: 1rem;
        animation: waitingPulse 1.5s ease-in-out infinite;
      }

      @keyframes waitingPulse {
        0%,
        100% {
          opacity: 0.5;
        }
        50% {
          opacity: 1;
        }
      }
      .lobby-container {
        max-width: 600px;
        width: 100%;
      }

      .lobby-section {
        background: rgba(0, 0, 0, 0.4);
        border: 2px solid var(--gold);
        border-radius: 15px;
        padding: 1.5rem;
        margin-bottom: 1rem;
      }

      .lobby-title {
        font-family: "Russo One", sans-serif;
        font-size: 1.2rem;
        color: var(--gold);
        margin-bottom: 1rem;
        text-align: center;
      }

      .lobby-input {
        width: 100%;
        padding: 1rem 1.2rem;
        border: 2px solid rgba(255, 215, 0, 0.3);
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.6);
        color: white;
        font-family: "Rajdhani", sans-serif;
        font-size: 1.1rem;
        font-weight: 500;
        margin-bottom: 1rem;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
      }

      .lobby-input:focus {
        outline: none;
        border-color: var(--gold);
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
        background: rgba(0, 0, 0, 0.8);
      }

      .lobby-input::placeholder {
        color: rgba(255, 255, 255, 0.4);
      }

      .lobby-link {
        background: linear-gradient(
          145deg,
          rgba(0, 0, 0, 0.7) 0%,
          rgba(0, 0, 0, 0.5) 100%
        );
        padding: 1rem;
        border-radius: 12px;
        word-break: break-all;
        font-family: "Orbitron", monospace;
        font-size: 0.9rem;
        margin-bottom: 1rem;
        border: 1px solid rgba(255, 215, 0, 0.3);
        color: var(--neon-blue);
        text-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
      }

      .lobby-status {
        text-align: center;
        padding: 0.75rem 1rem;
        border-radius: 10px;
        font-family: "Rajdhani", sans-serif;
        font-weight: 600;
        font-size: 1rem;
      }

      .lobby-status.connected {
        background: linear-gradient(
          145deg,
          rgba(0, 255, 136, 0.2) 0%,
          rgba(0, 255, 136, 0.05) 100%
        );
        color: var(--neon-green);
        border: 1px solid rgba(0, 255, 136, 0.3);
        text-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
      }

      .lobby-status.error {
        background: rgba(255, 0, 0, 0.2);
        color: #ff6b6b;
      }

      /* ==================== RESPONSIVE ==================== */
      @media (max-width: 600px) {
        .game-title {
          font-size: 2rem;
        }

        .player-card {
          width: 100px;
          height: 145px;
        }

        .card-overall {
          font-size: 1.8rem;
        }

        .pitch-slot {
          width: 35px;
          height: 35px;
        }
      }

      /* Email System Styles */
      .email-btn {
        background: linear-gradient(145deg, #1a3d2a, #0d1f15);
        border: 2px solid var(--gold);
        border-radius: 10px;
        padding: 8px 12px;
        font-size: 1.2rem;
        cursor: pointer;
        position: relative;
        transition: all 0.3s ease;
      }

      .email-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
      }

      .email-badge {
        position: absolute;
        top: -5px;
        right: -5px;
        background: #ff4444;
        color: white;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        font-size: 0.7rem;
        font-family: "Orbitron", sans-serif;
        display: flex;
        align-items: center;
        justify-content: center;
        animation: pulse 1s infinite;
      }

      .email-container {
        max-width: 800px;
        width: 95%;
        margin: 0 auto;
        background: rgba(13, 31, 21, 0.9);
        border: 2px solid var(--gold);
        border-radius: 15px;
        padding: 1rem;
        max-height: 60vh;
        overflow-y: auto;
      }

      .email-list {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .email-item {
        background: linear-gradient(145deg, #1a3d2a, #0d1f15);
        border: 1px solid var(--silver);
        border-radius: 10px;
        padding: 1rem;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 1rem;
      }

      .email-item:hover {
        border-color: var(--gold);
        transform: translateX(5px);
      }

      .email-item.unread {
        border-left: 4px solid var(--gold);
        background: linear-gradient(145deg, #1a4d3a, #0d2f25);
      }

      .email-item.urgent {
        border-left: 4px solid #ff4444;
      }

      .email-icon {
        font-size: 2rem;
      }

      .email-content {
        flex: 1;
      }

      .email-subject {
        font-family: "Orbitron", sans-serif;
        color: var(--gold);
        font-size: 0.9rem;
        margin-bottom: 0.3rem;
      }

      .email-preview {
        color: var(--silver);
        font-size: 0.8rem;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .email-time {
        color: #666;
        font-size: 0.7rem;
      }

      .email-player-mini {
        width: 50px;
        height: 70px;
      }

      .no-emails {
        text-align: center;
        color: var(--silver);
        padding: 2rem;
        font-style: italic;
      }

      /* Email Modal */
      .email-modal-content {
        background: linear-gradient(145deg, #0d2818, #051a0d);
        border: 2px solid var(--gold);
        border-radius: 15px;
        max-width: 600px;
        width: 95%;
        max-height: 80vh;
        overflow-y: auto;
        padding: 1.5rem;
      }

      .email-modal-header {
        border-bottom: 1px solid var(--gold);
        padding-bottom: 1rem;
        margin-bottom: 1rem;
      }

      .email-modal-subject {
        font-family: "Orbitron", sans-serif;
        color: var(--gold);
        font-size: 1.2rem;
        margin-bottom: 0.5rem;
      }

      .email-modal-from {
        color: var(--silver);
        font-size: 0.9rem;
      }

      .email-modal-body {
        color: #ddd;
        line-height: 1.6;
        margin-bottom: 1rem;
        white-space: pre-line;
      }

      .email-modal-player {
        display: flex;
        justify-content: center;
        margin: 1rem 0;
      }

      .email-modal-actions {
        display: flex;
        gap: 1rem;
        justify-content: center;
        flex-wrap: wrap;
        margin-top: 1rem;
      }

      .email-action-btn {
        padding: 0.8rem 1.5rem;
        border-radius: 10px;
        font-family: "Rajdhani", sans-serif;
        font-weight: 600;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .email-action-btn.accept {
        background: linear-gradient(145deg, #2d5a3d, #1a3d2a);
        border: 2px solid #4caf50;
        color: #4caf50;
      }

      .email-action-btn.negotiate {
        background: linear-gradient(145deg, #5a4a2d, #3d3a1a);
        border: 2px solid var(--gold);
        color: var(--gold);
      }

      .email-action-btn.reject {
        background: linear-gradient(145deg, #5a2d2d, #3d1a1a);
        border: 2px solid #ff4444;
        color: #ff4444;
      }

      .email-action-btn.close {
        background: linear-gradient(145deg, #2d2d2d, #1a1a1a);
        border: 2px solid var(--silver);
        color: var(--silver);
      }

      .email-action-btn:hover {
        transform: scale(1.05);
      }

      /* Contract info */
      .contract-info {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
        padding: 1rem;
        margin: 1rem 0;
      }

      .contract-row {
        display: flex;
        justify-content: space-between;
        padding: 0.5rem 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .contract-row:last-child {
        border-bottom: none;
      }

      .contract-label {
        color: var(--silver);
      }

      .contract-value {
        color: var(--gold);
        font-family: "Orbitron", sans-serif;
      }

      .contract-value.urgent {
        color: #ff4444;
      }

      /* Modal Overlay */
      .modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }

      /* Compose Email Styles */
      .email-actions-bar {
        max-width: 800px;
        width: 95%;
        margin: 0 auto 1rem auto;
        display: flex;
        justify-content: flex-end;
      }

      .compose-section {
        margin-bottom: 1rem;
      }

      .compose-section label {
        display: block;
        color: var(--silver);
        margin-bottom: 0.5rem;
        font-size: 0.9rem;
      }

      .compose-select,
      .compose-input {
        width: 100%;
        padding: 0.8rem;
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid var(--silver);
        border-radius: 10px;
        color: white;
        font-size: 1rem;
        font-family: "Rajdhani", sans-serif;
      }

      .compose-select:focus,
      .compose-input:focus {
        border-color: var(--gold);
        outline: none;
      }

      .compose-options {
        display: flex;
        gap: 1rem;
        flex-wrap: wrap;
      }

      .compose-option {
        flex: 1;
        min-width: 150px;
        padding: 1rem;
        background: rgba(0, 0, 0, 0.3);
        border: 2px solid var(--silver);
        border-radius: 10px;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        font-family: "Rajdhani", sans-serif;
        font-size: 1rem;
      }

      .compose-option:hover {
        border-color: var(--gold);
      }

      .compose-option.selected {
        border-color: var(--gold);
        background: rgba(255, 215, 0, 0.1);
      }

      .compose-player-preview {
        display: flex;
        justify-content: center;
        margin: 1rem 0;
        padding: 1rem;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
      }

      .compose-hint {
        color: #888;
        font-size: 0.8rem;
        margin-top: 0.3rem;
      }

      .compose-details {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 10px;
        padding: 1rem;
        margin-bottom: 1rem;
      }

      .reasons-list {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        max-height: 200px;
        overflow-y: auto;
        padding: 0.5rem;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        margin-bottom: 0.5rem;
      }

      .reason-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 0.85rem;
        color: var(--silver);
      }

      .reason-item:hover {
        background: rgba(255, 215, 0, 0.1);
      }

      .reason-item input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--gold);
      }

      .reason-item input[type="checkbox"]:checked + span {
        color: var(--gold);
      }

      /* Negotiation Chat Styles */
      .chat-modal-content {
        background: linear-gradient(145deg, #1a1a2e, #16213e);
        border: 2px solid var(--gold);
        border-radius: 15px;
        max-width: 500px;
        width: 95%;
        max-height: 85vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .chat-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem;
        background: rgba(0, 0, 0, 0.3);
        border-bottom: 1px solid var(--gold);
      }

      .chat-player-info {
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }

      .chat-player-avatar {
        width: 45px;
        height: 45px;
        background: linear-gradient(145deg, var(--gold), #b8860b);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
      }

      .chat-player-name {
        font-family: "Orbitron", sans-serif;
        font-size: 1.1rem;
        color: white;
      }

      .chat-close-btn {
        background: rgba(255, 0, 0, 0.2);
        border: 1px solid #ff4444;
        color: #ff4444;
        width: 35px;
        height: 35px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 1.2rem;
      }

      .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        min-height: 200px;
        max-height: 300px;
      }

      .chat-message {
        max-width: 85%;
        padding: 0.75rem 1rem;
        border-radius: 15px;
        font-size: 0.9rem;
        line-height: 1.4;
        animation: messageSlide 0.3s ease;
      }

      @keyframes messageSlide {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .chat-message.player {
        background: linear-gradient(145deg, #2d5016, #1e3a0e);
        border: 1px solid #4caf50;
        color: #a5d6a7;
        align-self: flex-start;
        border-bottom-left-radius: 5px;
      }

      .chat-message.manager {
        background: linear-gradient(145deg, #1a237e, #0d1442);
        border: 1px solid #5c6bc0;
        color: #9fa8da;
        align-self: flex-end;
        border-bottom-right-radius: 5px;
      }

      .chat-message.system {
        background: rgba(255, 215, 0, 0.1);
        border: 1px solid var(--gold);
        color: var(--gold);
        align-self: center;
        text-align: center;
        font-size: 0.85rem;
      }

      .chat-reasons-panel {
        padding: 0.75rem;
        background: rgba(0, 0, 0, 0.3);
        border-top: 1px solid rgba(255, 215, 0, 0.3);
        max-height: 180px;
        overflow-y: auto;
      }

      .chat-reasons-title {
        color: var(--gold);
        font-size: 0.85rem;
        margin-bottom: 0.5rem;
        font-family: "Orbitron", sans-serif;
      }

      .chat-reasons-list {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.4rem;
      }

      .chat-reason-item {
        display: flex;
        align-items: flex-start;
        gap: 0.4rem;
        padding: 0.4rem;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 5px;
        cursor: pointer;
        font-size: 0.75rem;
        color: var(--silver);
        transition: all 0.2s ease;
      }

      .chat-reason-item:hover {
        background: rgba(255, 215, 0, 0.1);
      }

      .chat-reason-item input {
        margin-top: 2px;
        accent-color: var(--gold);
      }

      .chat-reason-item.selected {
        background: rgba(255, 215, 0, 0.2);
        border: 1px solid var(--gold);
      }

      .chat-input-panel {
        padding: 0.75rem;
        background: rgba(0, 0, 0, 0.2);
        display: flex;
        gap: 1rem;
        align-items: center;
        flex-wrap: wrap;
      }

      .chat-salary-input,
      .chat-years-input {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .chat-salary-input input,
      .chat-years-input input {
        width: 100px;
      }

      .chat-actions {
        padding: 0.75rem;
        display: flex;
        gap: 0.5rem;
        background: rgba(0, 0, 0, 0.3);
        border-top: 1px solid rgba(255, 215, 0, 0.3);
      }

      .chat-send-btn,
      .chat-end-btn {
        flex: 1;
        padding: 0.75rem;
        border-radius: 10px;
        font-family: "Orbitron", sans-serif;
        font-size: 0.9rem;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .chat-send-btn {
        background: linear-gradient(145deg, #1a5a1a, #0d3d0d);
        border: 2px solid #4caf50;
        color: #4caf50;
      }

      .chat-send-btn:hover:not(:disabled) {
        background: linear-gradient(145deg, #2a7a2a, #1d5d1d);
      }

      .chat-send-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .chat-end-btn {
        background: linear-gradient(145deg, #5a5a1a, #3d3d0d);
        border: 2px solid var(--gold);
        color: var(--gold);
      }

      .chat-typing {
        display: flex;
        gap: 4px;
        padding: 0.5rem;
      }

      .chat-typing span {
        width: 8px;
        height: 8px;
        background: var(--silver);
        border-radius: 50%;
        animation: typingBounce 1s infinite;
      }

      .chat-typing span:nth-child(2) {
        animation-delay: 0.2s;
      }
      .chat-typing span:nth-child(3) {
        animation-delay: 0.4s;
      }

      @keyframes typingBounce {
        0%,
        60%,
        100% {
          transform: translateY(0);
        }
        30% {
          transform: translateY(-5px);
        }
      }

      /* Injury styles */
      .player-card.injured {
        position: relative;
      }

      .player-card.injured::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 0, 0, 0.15);
        border-radius: 12px;
        pointer-events: none;
        z-index: 5;
      }

      .injury-badge {
        position: absolute;
        top: 5px;
        right: 5px;
        background: linear-gradient(145deg, #ff4444, #cc0000);
        color: white;
        padding: 2px 6px;
        border-radius: 5px;
        font-size: 0.6rem;
        font-weight: bold;
        z-index: 10;
        animation: injuryPulse 1.5s infinite;
      }

      @keyframes injuryPulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }

      /* Transfer List Styles */
      .transfer-list-container {
        max-width: 900px;
        width: 95%;
        margin: 0 auto;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
      }

      /* New transfer squad view */
      .transfer-squad-view {
        max-width: 1000px;
        width: 95%;
        margin: 0 auto;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 15px;
        padding: 1rem;
        border: 2px solid var(--gold);
      }

      .transfer-squad-view h3 {
        color: var(--gold);
        font-family: "Orbitron", sans-serif;
        text-align: center;
        margin-bottom: 0.5rem;
      }

      .transfer-squad-grid,
      .transfer-bench-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        justify-content: center;
        padding: 0.5rem;
      }

      .transfer-card-slot {
        position: relative;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
      }

      .transfer-card-slot:hover {
        transform: scale(1.05);
        z-index: 10;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
      }

      .transfer-card-slot.listed {
        opacity: 0.5;
      }

      .listed-badge {
        position: absolute;
        top: 5px;
        right: 5px;
        font-size: 1.5rem;
        z-index: 10;
      }

      .transfer-offers-section {
        max-width: 1000px;
        width: 95%;
        margin: 0 auto;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 15px;
        padding: 1rem;
        border: 2px solid var(--gold);
      }

      .transfer-offers-section h3 {
        color: var(--gold);
        font-family: "Orbitron", sans-serif;
        text-align: center;
        margin-bottom: 0.5rem;
      }

      /* Listed for sale section */
      .transfer-listed-section {
        max-width: 1000px;
        width: 95%;
        margin: 0 auto;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 15px;
        padding: 1rem;
        border: 2px solid #4caf50;
      }

      .transfer-listed-section h3 {
        color: #4caf50;
        font-family: "Orbitron", sans-serif;
        text-align: center;
        margin-bottom: 0.5rem;
      }

      .transfer-listed-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        justify-content: center;
        padding: 0.5rem;
      }

      .listed-card-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
      }

      .listed-card-info {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.25rem;
      }

      .listed-card-price {
        font-family: "Russo One", sans-serif;
        color: var(--gold);
        font-size: 1rem;
      }

      .listed-remove-btn {
        padding: 0.4rem 0.8rem;
        font-size: 0.75rem;
        border-radius: 5px;
        cursor: pointer;
        background: linear-gradient(145deg, #4a1a1a, #2a0a0a);
        border: 1px solid #ff4444;
        color: #ff4444;
        transition: transform 0.2s;
      }

      .listed-remove-btn:hover {
        transform: scale(1.05);
      }

      .no-listed {
        color: var(--silver);
        text-align: center;
        padding: 1rem;
        font-style: italic;
      }

      /* Sell card modal - new layout */
      .sell-modal-container {
        display: flex;
        gap: 2rem;
        background: linear-gradient(145deg, #1a1a2e, #0d0d1a);
        padding: 2rem;
        border-radius: 20px;
        border: 3px solid var(--gold);
        max-width: 500px;
      }

      .sell-modal-left {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.75rem;
      }

      .sell-card-display {
        /* Just holds the card */
      }

      .sell-market-value {
        background: rgba(255, 215, 0, 0.1);
        padding: 0.5rem 1rem;
        border-radius: 10px;
        border: 1px solid var(--gold);
        font-size: 0.85rem;
        color: var(--silver);
      }

      .sell-market-value span:last-child {
        color: var(--gold);
        font-weight: bold;
        font-family: "Russo One", sans-serif;
      }

      .sell-modal-right {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        min-width: 200px;
      }

      .sell-modal-title {
        font-family: "Orbitron", sans-serif;
        color: var(--gold);
        font-size: 1.1rem;
        margin: 0;
      }

      .sell-player-name {
        font-family: "Russo One", sans-serif;
        color: white;
        font-size: 1.3rem;
      }

      .sell-player-details {
        color: var(--silver);
        font-size: 0.9rem;
      }

      .sell-price-section {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .sell-price-section label {
        color: var(--silver);
        font-size: 0.85rem;
      }

      .sell-price-input {
        width: 100%;
        padding: 0.75rem;
        border-radius: 10px;
        border: 2px solid var(--gold);
        background: rgba(0, 0, 0, 0.5);
        color: white;
        font-size: 1.2rem;
        text-align: center;
        font-family: "Russo One", sans-serif;
      }

      .sell-price-hint {
        color: var(--silver);
        font-size: 0.75rem;
      }

      .sell-modal-buttons {
        display: flex;
        gap: 0.75rem;
        margin-top: 0.5rem;
      }

      .sell-modal-btn {
        flex: 1;
        padding: 0.75rem 1rem;
        border-radius: 10px;
        font-size: 1rem;
        font-weight: bold;
        cursor: pointer;
        border: none;
        font-family: "Orbitron", sans-serif;
        transition: transform 0.2s, box-shadow 0.2s;
      }

      .sell-modal-btn:hover {
        transform: scale(1.05);
      }

      .sell-modal-btn.sell {
        background: linear-gradient(145deg, #2e7d32, #1b5e20);
        color: white;
        box-shadow: 0 4px 15px rgba(46, 125, 50, 0.4);
      }

      .sell-modal-btn.cancel {
        background: linear-gradient(145deg, #c62828, #8e0000);
        color: white;
        box-shadow: 0 4px 15px rgba(198, 40, 40, 0.4);
      }

      /* DRAG AND DROP */
      .player-card.dragging {
        opacity: 0.5;
        transform: scale(1.1);
        z-index: 1000;
      }

      .player-card.drag-over {
        box-shadow: 0 0 20px var(--gold);
        transform: scale(1.05);
      }

      .slot-wrapper {
        position: relative;
      }

      .slot-wrapper.drag-over {
        background: rgba(255, 215, 0, 0.2);
        border-radius: 15px;
      }

      .transfer-list-section {
        background: rgba(0, 0, 0, 0.5);
        border-radius: 15px;
        padding: 1rem;
        border: 2px solid var(--gold);
      }

      .transfer-list-section h3 {
        color: var(--gold);
        margin-bottom: 1rem;
        font-family: "Orbitron", sans-serif;
        text-align: center;
      }

      .listed-players-grid {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        max-height: 400px;
        overflow-y: auto;
      }

      .listed-player-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        border: 1px solid rgba(255, 215, 0, 0.3);
      }

      .listed-player-info {
        display: flex;
        flex-direction: column;
      }

      .listed-player-name {
        color: white;
        font-weight: bold;
      }

      .listed-player-price {
        color: var(--gold);
        font-size: 0.85rem;
      }

      .listed-player-actions button {
        padding: 0.4rem 0.8rem;
        font-size: 0.75rem;
        border-radius: 5px;
        cursor: pointer;
        background: linear-gradient(145deg, #4a1a1a, #2a0a0a);
        border: 1px solid #ff4444;
        color: #ff4444;
      }

      .offers-list {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        max-height: 400px;
        overflow-y: auto;
      }

      .offer-item {
        padding: 0.75rem;
        background: rgba(0, 100, 0, 0.2);
        border-radius: 8px;
        border: 1px solid #4caf50;
      }

      .offer-item.new {
        animation: offerPulse 1s ease;
        border-color: var(--gold);
      }

      @keyframes offerPulse {
        0%,
        100% {
          box-shadow: 0 0 5px var(--gold);
        }
        50% {
          box-shadow: 0 0 20px var(--gold);
        }
      }

      .offer-header {
        display: flex;
        justify-content: space-between;
        margin-bottom: 0.5rem;
      }

      .offer-club {
        color: white;
        font-weight: bold;
      }

      .offer-amount {
        color: #4caf50;
        font-weight: bold;
      }

      .offer-player {
        color: var(--silver);
        font-size: 0.85rem;
        margin-bottom: 0.5rem;
      }

      .offer-actions {
        display: flex;
        gap: 0.5rem;
      }

      .offer-actions button {
        flex: 1;
        padding: 0.4rem;
        font-size: 0.7rem;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Orbitron", sans-serif;
      }

      .offer-actions .accept-btn {
        background: linear-gradient(145deg, #1a5a1a, #0d3d0d);
        border: 1px solid #4caf50;
        color: #4caf50;
      }

      .offer-actions .reject-btn {
        background: linear-gradient(145deg, #4a1a1a, #2a0a0a);
        border: 1px solid #ff4444;
        color: #ff4444;
      }

      .offer-actions .negotiate-btn {
        background: linear-gradient(145deg, #1a1a4a, #0d0d2a);
        border: 1px solid #5c6bc0;
        color: #9fa8da;
      }

      .no-offers {
        text-align: center;
        color: var(--silver);
        padding: 2rem;
      }
    </style>
  </head>
  <body>
    <!-- Mobile/Tablet Block -->
    <div class="mobile-block" id="mobileBlock">
      <div class="mobile-block-icon">🖥️</div>
      <div class="mobile-block-title">Tylko na komputerze</div>
      <div class="mobile-block-message">
        Ta gra wymaga komputera z myszką. Sterowanie za pomocą ekranu dotykowego
        nie jest obsługiwane.
      </div>
      <div class="mobile-block-devices">
        <div class="mobile-block-device supported">
          <div class="mobile-block-device-icon">💻</div>
          <div class="mobile-block-device-label">Laptop ✓</div>
        </div>
        <div class="mobile-block-device supported">
          <div class="mobile-block-device-icon">🖥️</div>
          <div class="mobile-block-device-label">Komputer ✓</div>
        </div>
        <div class="mobile-block-device unsupported">
          <div class="mobile-block-device-icon">📱</div>
          <div class="mobile-block-device-label">Telefon ✗</div>
        </div>
        <div class="mobile-block-device unsupported">
          <div class="mobile-block-device-icon">📲</div>
          <div class="mobile-block-device-label">Tablet ✗</div>
        </div>
      </div>
      <div class="mobile-block-footer">⚽ Football Manager Ultimate</div>
    </div>

    <!-- ==================== SQUAD REVEAL OVERLAY ==================== -->
    <div
      class="squad-reveal-overlay"
      id="squadRevealOverlay"
      style="display: none"
    >
      <div class="squad-reveal-title" id="squadRevealTitle">TWÓJ SKŁAD</div>

      <div class="squad-reveal-position-label" id="squadRevealPosition">
        BRAMKARZ
      </div>

      <div class="squad-reveal-card-container" id="squadRevealCardContainer">
        <!-- Single card reveal -->
      </div>

      <div class="squad-reveal-progress" id="squadRevealProgress">
        <!-- Dots will be generated -->
      </div>

      <!-- Full squad display (shown after all cards) -->
      <div class="squad-reveal-full" id="squadRevealFull">
        <div
          class="squad-reveal-title"
          id="squadRevealMyName"
          data-t="squadTitle"
        >
          TWÓJ SKŁAD
        </div>
        <div class="squad-reveal-formation" id="squadRevealFormation">
          <!-- Formation rows will be generated -->
        </div>
        <div class="squad-reveal-vs">VS</div>
        <div
          class="squad-reveal-opponent-name"
          id="squadRevealOpponentName"
        ></div>
        <div
          class="squad-reveal-waiting"
          id="squadRevealWaiting"
          data-t="waitingForOpponent"
        >
          Oczekiwanie na przeciwnika...
        </div>
        <button
          class="squad-reveal-ready-btn"
          id="squadRevealReadyBtn"
          onclick="confirmSquadReady()"
          data-t="ready"
          style="display: none"
        >
          GOTOWY!
        </button>
      </div>
    </div>

    <!-- ==================== MAIN MENU ==================== -->
    <div class="screen active" id="mainMenu">
      <h1 class="game-title">
        ⚽ FOOTBALL MANAGER
        <span>ULTIMATE EDITION</span>
      </h1>

      <div class="account-panel" id="accountPanel">
        <div class="account-header">
          <div style="display: flex; align-items: center; gap: 10px">
            <input
              type="text"
              class="lobby-input"
              id="managerName"
              placeholder="Nazwa Managera"
              maxlength="15"
              style="margin-bottom: 0"
            />
            <button
              class="email-btn"
              id="emailBtn"
              onclick="showScreen('emailScreen')"
            >
              📧
              <span class="email-badge" id="emailBadge" style="display: none"
                >0</span
              >
            </button>
          </div>
          <div class="account-balance" id="accountBalance">10000</div>
        </div>
        <div class="squad-overall">
          <div class="squad-overall-stats">
            <div class="squad-stat">
              <span class="squad-stat-value" id="squadATK">0</span>
              <span class="squad-stat-label">⚽ ATK</span>
            </div>
            <div class="squad-stat">
              <span class="squad-stat-value" id="squadMID">0</span>
              <span class="squad-stat-label">🎯 MID</span>
            </div>
            <div class="squad-stat">
              <span class="squad-stat-value" id="squadDEF">0</span>
              <span class="squad-stat-label">🛡️ DEF</span>
            </div>
            <div class="squad-stat main">
              <span class="squad-stat-value" id="squadOverall">40</span>
              <span class="squad-stat-label" data-t="squadOverall">OVR</span>
            </div>
          </div>
        </div>
      </div>

      <div class="menu-container">
        <button
          class="menu-btn"
          onclick="showScreen('squadScreen')"
          data-t="squad"
        >
          📋 MÓJ SKŁAD
        </button>
        <button
          class="menu-btn"
          onclick="showScreen('marketScreen')"
          data-t="market"
        >
          🏪 RYNEK TRANSFEROWY
        </button>
        <button
          class="menu-btn"
          onclick="openTransferList()"
          data-t="transferList"
        >
          💰 LISTA TRANSFEROWA
        </button>
        <button
          class="menu-btn gold"
          onclick="showScreen('playMenu')"
          data-t="play"
        >
          ⚽ ZAGRAJ MECZ
        </button>
        <button
          class="menu-btn"
          onclick="showScreen('upgradeScreen')"
          data-t="upgrades"
        >
          ⬆️ ULEPSZENIA
        </button>
        <button
          class="menu-btn"
          onclick="showScreen('legendsScreen')"
          data-t="legends"
        >
          ⭐ LEGENDY
        </button>
        <button
          class="menu-btn"
          onclick="showScreen('settingsScreen')"
          data-t="settings"
        >
          ⚙️ USTAWIENIA
        </button>
      </div>
    </div>

    <!-- ==================== LEGENDS SCREEN ==================== -->
    <div class="screen" id="legendsScreen">
      <h1 class="game-title" data-t="legendsTitle">⭐ LEGENDY NA EMERYTURZE</h1>

      <div
        class="legends-container"
        style="max-width: 1000px; width: 95%; margin: 0 auto"
      >
        <div
          class="legends-grid"
          id="legendsGrid"
          style="
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 1.5rem;
            justify-items: center;
            padding: 1rem;
          "
        >
          <!-- Legends will be generated by JS -->
        </div>
        <div
          class="no-legends"
          id="noLegends"
          style="text-align: center; color: var(--silver); padding: 2rem"
          data-t="noLegends"
        >
          Brak legend. Rozwijaj graczy do 90+ OVR i pozwól im przejść na
          emeryturę!
        </div>
      </div>

      <button
        class="menu-btn"
        onclick="showScreen('mainMenu')"
        style="margin-top: 1rem"
        data-t="back"
      >
        🔙 POWRÓT
      </button>
    </div>

    <!-- ==================== EMAIL SCREEN ==================== -->
    <div class="screen" id="emailScreen">
      <h1 class="game-title">
        📧 <span data-t="emailTitle">SKRZYNKA ODBIORCZA</span>
      </h1>

      <div class="email-actions-bar">
        <button
          class="menu-btn gold"
          onclick="openComposeEmail()"
          data-t="composeEmail"
        >
          ✉️ WYŚLIJ WIADOMOŚĆ
        </button>
      </div>

      <div class="email-container">
        <div class="email-list" id="emailList">
          <!-- Emails will be generated by JS -->
        </div>
        <div class="no-emails" id="noEmails" data-t="noEmails">
          Brak wiadomości
        </div>
      </div>

      <button
        class="menu-btn"
        onclick="showScreen('mainMenu')"
        style="margin-top: 1rem"
        data-t="back"
      >
        🔙 POWRÓT
      </button>
    </div>

    <!-- ==================== EMAIL MODAL ==================== -->
    <div class="modal-overlay" id="emailModal" style="display: none">
      <div class="email-modal-content">
        <div class="email-modal-header">
          <div class="email-modal-subject" id="emailSubject"></div>
          <div class="email-modal-from" id="emailFrom"></div>
        </div>
        <div class="email-modal-body" id="emailBody"></div>
        <div class="email-modal-player" id="emailPlayerCard"></div>
        <div class="email-modal-actions" id="emailActions">
          <!-- Buttons will be generated -->
        </div>
      </div>
    </div>

    <!-- ==================== COMPOSE EMAIL MODAL ==================== -->
    <div class="modal-overlay" id="composeEmailModal" style="display: none">
      <div class="email-modal-content">
        <div class="email-modal-header">
          <div class="email-modal-subject" data-t="composeEmail">
            ✉️ WYŚLIJ WIADOMOŚĆ
          </div>
        </div>

        <div class="compose-section">
          <label data-t="selectPlayerEmail">Wybierz zawodnika:</label>
          <select
            id="composePlayerSelect"
            class="compose-select"
            onchange="updateComposePreview()"
          >
            <option value="" data-t="selectPlayerForAction">
              -- Wybierz zawodnika --
            </option>
          </select>
        </div>

        <div
          class="compose-player-preview"
          id="composePlayerPreview"
          style="display: none"
        ></div>

        <div class="compose-section">
          <label data-t="messageType">Typ wiadomości:</label>
          <div class="compose-options">
            <button
              class="compose-option"
              onclick="selectComposeType('reduce_salary')"
              id="optReduceSalary"
            >
              📉 <span data-t="reduceSalaryOption">Obniż pensję</span>
            </button>
            <button
              class="compose-option"
              onclick="selectComposeType('extend_contract')"
              id="optExtendContract"
            >
              📝 <span data-t="extendContractOption">Przedłuż kontrakt</span>
            </button>
            <button
              class="compose-option"
              onclick="selectComposeType('raise_salary')"
              id="optRaiseSalary"
            >
              📈 <span data-t="raiseSalaryOption">Podwyżka pensji</span>
            </button>
          </div>
        </div>

        <div class="email-modal-actions">
          <button
            class="email-action-btn accept"
            onclick="startNegotiationChat()"
            id="composeSendBtn"
            disabled
          >
            💬 <span data-t="startChat">ROZPOCZNIJ ROZMOWĘ</span>
          </button>
          <button class="email-action-btn close" onclick="closeComposeEmail()">
            ❌ <span data-t="cancel">ANULUJ</span>
          </button>
        </div>
      </div>
    </div>

    <!-- ==================== NEGOTIATION CHAT MODAL ==================== -->
    <div class="modal-overlay" id="negotiationChatModal" style="display: none">
      <div class="chat-modal-content">
        <div class="chat-header">
          <div class="chat-player-info">
            <div class="chat-player-avatar" id="chatPlayerAvatar">👤</div>
            <div class="chat-player-name" id="chatPlayerName">Zawodnik</div>
          </div>
          <button class="chat-close-btn" onclick="closeNegotiationChat()">
            ✕
          </button>
        </div>

        <div class="chat-messages" id="chatMessages">
          <!-- Messages will be generated -->
        </div>

        <div
          class="chat-reasons-panel"
          id="chatReasonsPanel"
          style="display: none"
        >
          <div class="chat-reasons-title" data-t="selectReasons">
            Wybierz argumenty:
          </div>
          <div class="chat-reasons-list" id="chatReasonsList">
            <!-- Reasons checkboxes -->
          </div>
        </div>

        <div class="chat-input-panel" id="chatInputPanel" style="display: none">
          <div class="chat-salary-input">
            <label id="chatSalaryLabel" data-t="salary">Pensja:</label>
            <input
              type="number"
              id="chatSalaryInput"
              class="compose-input"
              min="100"
            />
            <span id="chatSalaryUnit">€/tyg</span>
          </div>
          <div
            class="chat-years-input"
            id="chatYearsInput"
            style="display: none"
          >
            <label data-t="contractYearsShort">Lata:</label>
            <input
              type="number"
              id="chatContractYears"
              class="compose-input"
              min="1"
              max="5"
              value="2"
            />
          </div>
        </div>

        <div class="chat-actions" id="chatActions">
          <button
            class="chat-send-btn"
            onclick="sendNegotiationMessage()"
            id="chatSendBtn"
            disabled
          >
            📤 <span data-t="sendMessage">WYŚLIJ</span>
          </button>
          <button
            class="chat-end-btn"
            onclick="endNegotiationChat()"
            id="chatEndBtn"
            style="display: none"
          >
            ✅ <span data-t="endChat">ZAKOŃCZ</span>
          </button>
        </div>
      </div>
    </div>

    <!-- ==================== SETTINGS SCREEN ==================== -->
    <div class="screen" id="settingsScreen">
      <h1 class="game-title" data-t="settingsTitle">⚙️ USTAWIENIA</h1>

      <div
        class="settings-container"
        style="max-width: 500px; width: 95%; margin: 0 auto; padding: 1rem"
      >
        <div
          class="settings-section"
          style="
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            border: 2px solid var(--gold);
          "
        >
          <div
            class="settings-label"
            style="color: var(--silver); margin-bottom: 0.5rem"
            data-t="language"
          >
            JĘZYK
          </div>
          <div style="display: flex; gap: 1rem; justify-content: center">
            <button
              class="menu-btn lang-btn"
              onclick="setLanguage('pl')"
              id="langPL"
              style="flex: 1"
            >
              🇵🇱 POLSKI
            </button>
            <button
              class="menu-btn lang-btn"
              onclick="setLanguage('en')"
              id="langEN"
              style="flex: 1"
            >
              🇬🇧 ENGLISH
            </button>
          </div>
        </div>

        <div
          class="settings-section"
          style="
            background: rgba(255, 0, 0, 0.1);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            border: 2px solid #ff4444;
          "
        >
          <div
            class="settings-label"
            style="color: #ff4444; margin-bottom: 0.5rem"
            data-t="dangerZone"
          >
            ⚠️ STREFA ZAGROŻENIA
          </div>
          <button
            class="menu-btn"
            onclick="resetGame()"
            style="
              background: linear-gradient(135deg, #ff4444 0%, #cc0000 100%);
              width: 100%;
            "
            data-t="resetProgress"
          >
            🗑️ RESETUJ POSTĘPY
          </button>
        </div>
      </div>

      <button
        class="menu-btn"
        onclick="showScreen('mainMenu')"
        style="margin-top: 1rem"
        data-t="back"
      >
        🔙 POWRÓT
      </button>
    </div>

    <!-- ==================== UPGRADE SCREEN ==================== -->
    <div class="screen" id="upgradeScreen">
      <h1 class="game-title" data-t="upgradesTitle">
        ⬆️ ULEPSZENIA ZAWODNIKÓW
      </h1>

      <div class="account-panel" style="margin-bottom: 1rem">
        <div class="account-balance">
          🎯 <span data-t="trainingPoints">Punkty Treningowe</span>:
          <span id="upgradeTP">0</span>
        </div>
      </div>

      <div class="upgrade-container">
        <div class="upgrade-tabs">
          <button
            class="upgrade-tab active"
            data-tab="squad"
            onclick="switchUpgradeTab('squad')"
            data-t="squadTab"
          >
            📋 SKŁAD
          </button>
          <button
            class="upgrade-tab"
            data-tab="bench"
            onclick="switchUpgradeTab('bench')"
            data-t="benchTab"
          >
            🪑 ŁAWKA
          </button>
        </div>

        <div class="upgrade-players-grid" id="upgradePlayersGrid">
          <!-- Players will be generated by JS -->
        </div>

        <button
          class="menu-btn"
          onclick="showScreen('mainMenu')"
          style="width: 100%; margin-top: 1.5rem"
          data-t="back"
        >
          🔙 POWRÓT
        </button>
      </div>
    </div>

    <!-- ==================== UPGRADE MODAL ==================== -->
    <div class="negotiation-modal" id="upgradeModal">
      <div class="upgrade-modal-content">
        <div class="upgrade-modal-header">
          <div id="upgradeCardPreview"></div>
          <div class="upgrade-player-info">
            <h2 id="upgradePlayerName">Zawodnik</h2>
            <p id="upgradePlayerDetails">ST | OVR 75</p>
          </div>
        </div>

        <div class="upgrade-section">
          <div class="upgrade-section-title stats">
            📊 <span data-t="upgradeStats">ULEPSZ STATYSTYKĘ</span>
          </div>
          <div class="upgrade-stats-grid" id="upgradeStatsList">
            <!-- Stats will be generated by JS -->
          </div>

          <div
            class="upgrade-slider-section"
            id="upgradeSliderSection"
            style="display: none"
          >
            <div class="upgrade-slider-info">
              <span data-t="pointsToAdd">Ile punktów dodać</span>:
              <span id="sliderValue">1</span>
            </div>
            <input
              type="range"
              id="upgradeSlider"
              min="1"
              max="10"
              value="1"
              class="upgrade-slider"
              oninput="updateSliderValue()"
            />
            <div class="upgrade-slider-labels">
              <span>1</span>
              <span id="sliderMaxLabel">10</span>
            </div>
            <div class="upgrade-preview">
              <span id="upgradeStatName">Stat</span>:
              <span id="upgradeOldValue">70</span> →
              <span id="upgradeNewValue" class="reward-green">71</span>
            </div>
            <div class="upgrade-cost-preview">
              <span data-t="upgradeCost">Koszt</span>:
              <span id="sliderCost" class="reward-gold">5 TP</span>
            </div>
          </div>
        </div>

        <div class="upgrade-section">
          <div class="upgrade-section-title positions">
            🔄 <span data-t="upgradePositions">DODAJ POZYCJĘ</span>
          </div>
          <div class="upgrade-positions-grid" id="upgradePositionsList">
            <!-- Positions will be generated by JS -->
          </div>
          <div class="position-cost-info" id="positionCostInfo"></div>
        </div>

        <div class="upgrade-buttons">
          <button
            class="menu-btn gold"
            id="confirmUpgradeBtn"
            onclick="confirmUpgrade()"
            data-t="confirmUpgrade"
          >
            ✅ ULEPSZ
          </button>
          <button
            class="menu-btn btn-cancel"
            onclick="closeUpgradeModal()"
            data-t="cancel"
          >
            ❌ ANULUJ
          </button>
        </div>
      </div>
    </div>

    <!-- ==================== TRANSFER LIST SCREEN ==================== -->
    <div class="screen" id="transferListScreen">
      <h1 class="game-title" data-t="transferList">💰 LISTA TRANSFEROWA</h1>

      <div class="account-panel" style="margin-bottom: 1rem">
        <div class="account-balance" id="transferListBalance">€0</div>
      </div>

      <!-- Squad cards view for selling -->
      <div class="transfer-squad-view">
        <h3 data-t="squad">📋 SKŁAD</h3>
        <p
          style="color: var(--silver); font-size: 0.8rem; margin-bottom: 0.5rem"
          data-t="clickToSell"
        >
          Kliknij kartę aby wystawić na sprzedaż
        </p>
        <div class="transfer-squad-grid" id="transferSquadGrid">
          <!-- Squad cards will appear here -->
        </div>

        <h3 style="margin-top: 1.5rem" data-t="bench">🪑 ŁAWKA</h3>
        <div class="transfer-bench-grid" id="transferBenchGrid">
          <!-- Bench cards will appear here -->
        </div>
      </div>

      <!-- Listed for sale section -->
      <div class="transfer-listed-section" style="margin-top: 1.5rem">
        <h3>🏷️ <span data-t="listedForSale">WYSTAWIONE NA SPRZEDAŻ</span></h3>
        <div class="transfer-listed-grid" id="transferListedGrid">
          <!-- Listed players will appear here -->
        </div>
      </div>

      <!-- Offers section -->
      <div class="transfer-offers-section" style="margin-top: 1.5rem">
        <h3 data-t="offersReceived">📬 Otrzymane oferty</h3>
        <div class="offers-list" id="offersListContainer">
          <div class="no-offers" data-t="noOffersYet">
            Brak ofert - poczekaj...
          </div>
        </div>
      </div>

      <button
        class="menu-btn"
        onclick="showScreen('mainMenu')"
        style="margin-top: 1rem"
        data-t="back"
      >
        🔙 POWRÓT
      </button>
    </div>

    <!-- ==================== SELL CARD MODAL ==================== -->
    <div class="modal-overlay" id="sellCardModal" style="display: none">
      <div class="sell-modal-container">
        <div class="sell-modal-left">
          <div class="sell-card-display" id="sellCardFront">
            <!-- Player card will appear here -->
          </div>
          <div class="sell-market-value">
            <span data-t="marketValue">WARTOŚĆ RYNKOWA</span>:
            <span id="sellMarketValue">€0</span>
          </div>
        </div>
        <div class="sell-modal-right">
          <h2 class="sell-modal-title">
            🏷️ <span data-t="listForSale">WYSTAW NA SPRZEDAŻ</span>
          </h2>
          <div class="sell-player-name" id="sellPlayerName">Gracz</div>
          <div class="sell-player-details" id="sellPlayerDetails">
            ST | OVR 80
          </div>

          <div class="sell-price-section">
            <label data-t="askingPrice">Cena wywoławcza (€):</label>
            <input
              type="number"
              id="sellCardPrice"
              class="sell-price-input"
              min="1000"
            />
            <div class="sell-price-hint" id="sellCardHint"></div>
          </div>

          <div class="sell-modal-buttons">
            <button class="sell-modal-btn sell" onclick="confirmSellCard()">
              ✅ SELL
            </button>
            <button
              class="sell-modal-btn cancel"
              onclick="closeSellCardModal()"
            >
              ❌ CANCEL
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- ==================== LIST PLAYER MODAL (legacy - hidden) ==================== -->
    <div class="modal-overlay" id="listPlayerModal" style="display: none">
      <div class="email-modal-content">
        <div class="email-modal-header">
          <div class="email-modal-subject">
            🏷️ <span data-t="listForSale">WYSTAW NA SPRZEDAŻ</span>
          </div>
        </div>

        <div class="compose-section">
          <label data-t="selectPlayerEmail">Wybierz zawodnika:</label>
          <select
            id="listPlayerSelect"
            class="compose-select"
            onchange="updateListPlayerPreview()"
          >
            <option value="">-- Wybierz --</option>
          </select>
        </div>

        <div
          class="compose-player-preview"
          id="listPlayerPreview"
          style="display: none"
        ></div>

        <div
          class="compose-section"
          id="listPriceSection"
          style="display: none"
        >
          <label data-t="askingPrice">Cena wywoławcza (€):</label>
          <input
            type="number"
            id="listAskingPrice"
            class="compose-input"
            min="1000"
          />
          <div class="compose-hint" id="listPriceHint"></div>
        </div>

        <div class="email-modal-actions">
          <button
            class="email-action-btn accept"
            onclick="confirmListPlayer()"
            id="listPlayerBtn"
            disabled
          >
            🏷️ <span data-t="listForSale">WYSTAW</span>
          </button>
          <button
            class="email-action-btn close"
            onclick="closeListPlayerModal()"
          >
            ❌ <span data-t="cancel">ANULUJ</span>
          </button>
        </div>
      </div>
    </div>

    <!-- ==================== SELL NEGOTIATION MODAL ==================== -->
    <div class="modal-overlay" id="sellNegotiationModal" style="display: none">
      <div class="chat-modal-content">
        <div class="chat-header">
          <div class="chat-player-info">
            <div class="chat-player-avatar" id="sellChatClubLogo">🏟️</div>
            <div class="chat-player-name" id="sellChatClubName">
              Agent klubu
            </div>
          </div>
          <button class="chat-close-btn" onclick="closeSellNegotiation()">
            ✕
          </button>
        </div>

        <div class="chat-messages" id="sellChatMessages">
          <!-- Messages will be generated -->
        </div>

        <div
          class="chat-reasons-panel"
          id="sellReasonsPanel"
          style="display: none"
        >
          <div class="chat-reasons-title" data-t="selectReasons">
            Wybierz argumenty:
          </div>
          <div class="chat-reasons-list" id="sellReasonsList">
            <!-- Reasons checkboxes -->
          </div>
        </div>

        <div class="chat-input-panel" id="sellInputPanel" style="display: none">
          <div class="chat-salary-input">
            <label id="sellPriceLabel">Cena:</label>
            <input
              type="number"
              id="sellPriceInput"
              class="compose-input"
              min="1000"
            />
            <span>€</span>
          </div>
        </div>

        <div class="chat-actions" id="sellChatActions">
          <button
            class="chat-send-btn"
            onclick="sendSellNegotiationMessage()"
            id="sellChatSendBtn"
            disabled
          >
            📤 <span data-t="sendMessage">WYŚLIJ</span>
          </button>
          <button
            class="chat-end-btn"
            onclick="closeSellNegotiation()"
            id="sellChatEndBtn"
            style="display: none"
          >
            ✅ <span data-t="endChat">ZAKOŃCZ</span>
          </button>
        </div>
      </div>
    </div>

    <!-- ==================== PLAY MENU ==================== -->
    <div class="screen" id="playMenu">
      <h1 class="game-title">🏟️ <span data-t="arenas">ARENY</span></h1>

      <div class="arena-container">
        <div class="arena-info">
          <div class="arena-current">
            <span data-t="currentArena">Aktualna Arena:</span>
            <span id="currentArenaName" class="arena-name">Arena 1</span>
          </div>
          <div class="arena-rewards">
            <span
              >🏆 <span data-t="win">Wygrana</span>:
              <span id="arenaWinReward" class="reward-green"
                >+€5,000</span
              ></span
            >
            <span
              >💀 <span data-t="lose">Przegrana</span>:
              <span id="arenaLoseReward" class="reward-red">-€2,500</span></span
            >
            <span
              >🎯 TP:
              <span id="arenaTpReward" class="reward-gold">+5 TP</span></span
            >
          </div>
          <div class="arena-bot-info">
            <span
              >🤖 <span data-t="botOVR">OVR Bota</span>:
              <span id="arenaBotOVR">45-55</span></span
            >
          </div>
          <div class="arena-tp-display">
            <span
              >🎯 <span data-t="trainingPoints">Punkty Treningowe</span>:
              <span id="currentTP" class="tp-value">0</span></span
            >
          </div>
        </div>

        <div class="arena-actions">
          <button
            class="menu-btn gold"
            onclick="playArenaMatch()"
            data-t="playMatch"
          >
            ⚽ ZAGRAJ MECZ
          </button>
          <button
            class="menu-btn"
            onclick="showArenaSelect()"
            data-t="changeArena"
          >
            🏟️ ZMIEŃ ARENĘ
          </button>
          <button
            class="menu-btn gold"
            onclick="showScreen('onlinePenaltyLobby')"
            data-t="online"
          >
            🌐 ONLINE VS GRACZ
          </button>
          <button
            class="menu-btn"
            onclick="showScreen('mainMenu')"
            data-t="back"
          >
            🔙 POWRÓT
          </button>
        </div>
      </div>
    </div>

    <!-- ==================== ARENA SELECT ==================== -->
    <div class="screen" id="arenaSelectScreen">
      <h1 class="game-title">
        🏟️ <span data-t="selectArena">WYBIERZ ARENĘ</span>
      </h1>

      <div class="arena-select-container">
        <div class="arena-list" id="arenaList"></div>
        <button
          class="menu-btn"
          onclick="showScreen('playMenu')"
          style="margin-top: 1rem"
          data-t="back"
        >
          🔙 POWRÓT
        </button>
      </div>
    </div>

    <!-- ==================== ONLINE PENALTY LOBBY ==================== -->
    <div class="screen" id="onlinePenaltyLobby">
      <h1 class="game-title" data-t="onlinePenalties">🌐 KARNE ONLINE</h1>

      <div class="lobby-container">
        <div class="lobby-section" id="onlinePenaltyChoice">
          <div class="lobby-title" data-t="chooseOption">WYBIERZ OPCJĘ</div>
          <button
            class="menu-btn"
            onclick="createPenaltyRoom()"
            style="width: 100%; margin-bottom: 1rem"
            data-t="createRoom"
          >
            🏠 UTWÓRZ POKÓJ
          </button>
          <div
            style="
              text-align: center;
              margin-bottom: 1rem;
              color: var(--silver);
            "
            data-t="or"
          >
            — lub —
          </div>
          <input
            type="text"
            class="lobby-input"
            id="joinPenaltyInput"
            data-t-placeholder="pasteCode"
            placeholder="Wklej link lub kod"
          />
          <button
            class="menu-btn"
            onclick="joinPenaltyRoom()"
            style="width: 100%"
            data-t="joinRoom"
          >
            🔗 DOŁĄCZ DO POKOJU
          </button>
        </div>

        <div
          class="lobby-section"
          id="hostPenaltySection"
          style="display: none"
        >
          <div class="lobby-title" data-t="yourRoom">TWÓJ POKÓJ</div>
          <div class="lobby-link" id="penaltyRoomCode" data-t="generating">
            Generowanie...
          </div>
          <button
            class="menu-btn"
            onclick="copyPenaltyCode()"
            style="width: 100%; margin-bottom: 1rem"
            data-t="copyLink"
          >
            📋 KOPIUJ LINK
          </button>
          <div class="lobby-status" id="penaltyHostStatus" data-t="waiting">
            Oczekiwanie na przeciwnika...
          </div>
          <button
            class="menu-btn gold"
            id="startOnlinePenaltyBtn"
            onclick="startOnlinePenalty()"
            style="width: 100%; margin-top: 1rem"
            disabled
            data-t="start"
          >
            ROZPOCZNIJ
          </button>
        </div>

        <div
          class="lobby-section"
          id="guestPenaltySection"
          style="display: none"
        >
          <div class="lobby-title" data-t="joining">DOŁĄCZANIE...</div>
          <div class="lobby-status" id="penaltyGuestStatus" data-t="connecting">
            Łączenie z pokojem...
          </div>
        </div>

        <button
          class="menu-btn"
          onclick="leavePenaltyLobby()"
          style="width: 100%"
          data-t="back"
        >
          🔙 POWRÓT
        </button>
      </div>
    </div>

    <!-- ==================== PENALTY SHOOTOUT ==================== -->
    <div class="screen" id="penaltyScreen">
      <div class="penalty-container">
        <!-- BIG ACTION INDICATOR -->
        <div
          class="penalty-action-indicator shooting"
          id="penaltyActionIndicator"
        >
          ⚽ STRZELASZ!
        </div>

        <!-- Score -->
        <div class="penalty-score">
          <div class="penalty-team">
            <span class="team-label" id="penaltyPlayerLabel">TY</span>
            <span class="team-score" id="penaltyScorePlayer">0</span>
          </div>
          <div class="penalty-round" id="penaltyRound">Runda 1/5</div>
          <div class="penalty-team">
            <span class="team-label" id="penaltyOpponentLabel">PRZECIWNIK</span>
            <span class="team-score" id="penaltyScoreOpponent">0</span>
          </div>
        </div>

        <!-- Penalty dots -->
        <div class="penalty-dots">
          <div class="dots-row" id="playerDots">
            <span class="dot"></span>
            <span class="dot"></span>
            <span class="dot"></span>
            <span class="dot"></span>
            <span class="dot"></span>
          </div>
          <div class="dots-row" id="opponentDots">
            <span class="dot"></span>
            <span class="dot"></span>
            <span class="dot"></span>
            <span class="dot"></span>
            <span class="dot"></span>
          </div>
        </div>

        <!-- Goal view -->
        <div class="penalty-goal-view" id="penaltyGoalView">
          <div class="goal-frame-penalty">
            <div class="goal-zone left" data-zone="left"></div>
            <div class="goal-zone center" data-zone="center"></div>
            <div class="goal-zone right" data-zone="right"></div>
            <div class="goal-net-penalty"></div>
            <div class="goalkeeper-penalty" id="penaltyGK"></div>
            <div class="ball-penalty" id="penaltyBall">⚽</div>
          </div>
        </div>

        <!-- Shooter info -->
        <div class="shooter-info" id="shooterInfo">
          <div class="shooter-name" id="shooterName">Strzelec</div>
          <div class="shooter-stats" id="shooterStats">SHO: 80</div>
        </div>

        <!-- Action info -->
        <div class="penalty-action" id="penaltyAction">
          WYBIERZ KIERUNEK STRZAŁU
        </div>

        <!-- Direction buttons -->
        <div class="penalty-buttons" id="penaltyButtons">
          <button class="penalty-btn" onclick="selectPenaltyDirection('left')">
            ⬅️ LEWO
          </button>
          <button
            class="penalty-btn"
            onclick="selectPenaltyDirection('center')"
          >
            ⬆️ ŚRODEK
          </button>
          <button class="penalty-btn" onclick="selectPenaltyDirection('right')">
            ➡️ PRAWO
          </button>
        </div>

        <!-- Result display -->
        <div class="penalty-result" id="penaltyResult"></div>

        <!-- Surrender button -->
        <button
          class="surrender-btn"
          id="surrenderBtn"
          onclick="surrenderPenalties()"
          data-t="surrender"
        >
          🏳️ PODDAJ SIĘ
        </button>
      </div>
    </div>

    <!-- ==================== ONLINE LOBBY ==================== -->

    <!-- ==================== SQUAD SCREEN ==================== -->
    <div class="screen" id="squadScreen">
      <h1 class="game-title" data-t="squadTitle">📋 MÓJ SKŁAD</h1>

      <div class="formation-selector" id="formationSelector">
        <button class="formation-btn selected" data-formation="4-3-3">
          4-3-3
        </button>
        <button class="formation-btn" data-formation="4-4-2">4-4-2</button>
        <button class="formation-btn" data-formation="3-5-2">3-5-2</button>
        <button class="formation-btn" data-formation="4-2-3-1">4-2-3-1</button>
        <button class="formation-btn" data-formation="5-3-2">5-3-2</button>
      </div>

      <div class="pitch-container" id="pitchContainer">
        <div class="pitch-center-circle"></div>
        <div class="pitch-penalty-area top"></div>
        <div class="pitch-penalty-area bottom"></div>
        <div class="pitch-goal-area top"></div>
        <div class="pitch-goal-area bottom"></div>
        <!-- Slots will be generated by JS -->
      </div>

      <div class="bench-section">
        <h3 class="bench-title" data-t="bench">🪑 ŁAWKA REZERWOWYCH</h3>
        <div class="bench-players" id="benchPlayers">
          <!-- Bench players will be generated by JS -->
        </div>
      </div>

      <div style="margin-top: 1rem">
        <button class="menu-btn" onclick="showScreen('mainMenu')" data-t="back">
          🔙 POWRÓT
        </button>
      </div>
    </div>

    <!-- ==================== PLAYER SELECTION MODAL ==================== -->
    <div class="player-select-modal" id="playerSelectModal">
      <div class="player-select-panel">
        <div class="player-select-header">
          <h2 data-t="selectPlayer">WYBIERZ ZAWODNIKA</h2>
          <div class="player-select-slot-info" id="slotInfo">Pozycja: ST</div>
        </div>
        <div class="player-select-tabs">
          <button class="player-tab active" data-tab="squad" data-t="squadTab">
            SKŁAD
          </button>
          <button class="player-tab" data-tab="bench" data-t="benchTab">
            ŁAWKA
          </button>
        </div>
        <div class="player-select-list" id="playerSelectList">
          <!-- Players will be generated by JS -->
        </div>
        <div class="player-select-buttons">
          <button
            class="menu-btn"
            onclick="closePlayerSelect()"
            data-t="cancel"
          >
            ❌ ANULUJ
          </button>
        </div>
      </div>
    </div>

    <!-- ==================== MARKET SCREEN ==================== -->
    <div class="screen" id="marketScreen">
      <h1 class="game-title" data-t="marketTitle">🏪 RYNEK TRANSFEROWY</h1>

      <div class="market-container">
        <div class="market-header">
          <div class="account-balance" id="marketBalance">10000</div>
          <div class="market-timer">
            <span data-t="refresh">Nowe karty za</span>:
            <span id="marketTimer">5:00:00</span>
          </div>
        </div>

        <div class="market-cards" id="marketCards">
          <!-- Cards will be generated by JS -->
        </div>
      </div>

      <div style="margin-top: 2rem">
        <button class="menu-btn" onclick="showScreen('mainMenu')" data-t="back">
          🔙 POWRÓT
        </button>
      </div>
    </div>

    <!-- ==================== MATCH SCREEN ==================== -->
    <div class="screen" id="matchScreen">
      <div class="match-screen-3d" id="matchScreen3d">
        <!-- HUD -->
        <div class="match-hud-3d">
          <div class="match-score-panel">
            <span class="team-name">TY</span>
            <span class="score" id="team1Score">0</span>
            <span class="separator">:</span>
            <span class="score" id="team2Score">0</span>
            <span class="team-name">PRZECIWNIK</span>
          </div>
          <div class="match-time-3d" id="matchTime">00:00</div>
        </div>

        <!-- Turn timer -->
        <div class="turn-timer" id="turnTimer">
          <div class="turn-timer-bar" id="turnTimerBar"></div>
          <span class="turn-timer-text" id="turnTimerText"
            >TWOJA TURA - 10s</span
          >
        </div>

        <!-- Turn indicator -->
        <div class="turn-indicator" id="turnIndicator">TWOJA TURA</div>

        <!-- Match buttons -->
        <div class="match-buttons-3d">
          <button class="match-btn" onclick="pauseMatch()">⏸️</button>
          <button class="match-btn" onclick="exitMatch()">✕</button>
        </div>

        <!-- 3D World -->
        <div class="world-3d" id="world3d">
          <div class="pitch-3d" id="matchPitch3d">
            <!-- Grass with lines -->
            <div class="grass-3d">
              <div class="pitch-line center"></div>
              <div class="pitch-circle"></div>
              <div class="penalty-box near"></div>
              <div class="penalty-box far"></div>
            </div>

            <!-- Far goal (opponent's) -->
            <div class="goal-3d far" id="goalFar">
              <div class="goal-post left"></div>
              <div class="goal-post right"></div>
              <div class="goal-crossbar"></div>
              <div class="goal-net"></div>
            </div>

            <!-- Near goal (player's) -->
            <div class="goal-3d near" id="goalNear">
              <div class="goal-post left"></div>
              <div class="goal-post right"></div>
              <div class="goal-crossbar"></div>
              <div class="goal-net"></div>
            </div>

            <!-- Players will be added by JS -->
          </div>
        </div>

        <!-- Controls help -->
        <div class="controls-help-3d">
          <div>🖱️ <b>KLIK</b> = drybling</div>
          <div>🖱️🖱️ <b>2x KLIK</b> = sprint</div>
          <div>↔️ <b>PRZECIĄGNIJ</b> = podanie</div>
          <div>🎯 <b>PRZY BRAMCE</b> = strzał</div>
          <div>🔄 <b>PRAWY PRZYCISK</b> = obróć kamerę</div>
        </div>

        <!-- Player with ball info -->
        <div class="ball-holder-panel" id="ballHolderPanel">
          <div class="holder-name" id="holderName">-</div>
          <div class="holder-pos" id="holderPos">-</div>
          <div class="holder-stats" id="holderStats"></div>
        </div>

        <!-- Pass line indicator -->
        <svg class="pass-line-svg" id="passLineSvg">
          <defs>
            <marker
              id="arrowhead"
              markerWidth="10"
              markerHeight="7"
              refX="9"
              refY="3.5"
              orient="auto"
            >
              <polygon points="0 0, 10 3.5, 0 7" fill="#ffd700" />
            </marker>
          </defs>
          <line
            id="passLine"
            x1="0"
            y1="0"
            x2="0"
            y2="0"
            stroke="#ffd700"
            stroke-width="3"
            marker-end="url(#arrowhead)"
          />
        </svg>

        <!-- Cards display -->
        <div class="cards-display-3d" id="cardsDisplay"></div>

        <!-- Foul message -->
        <div class="foul-message" id="foulMessage">FAUL!</div>

        <!-- Card display -->
        <div class="card-display" id="cardDisplay"></div>

        <!-- Goal celebration -->
        <div class="goal-celebration" id="goalCelebration">
          <div class="goal-text">GOOOL!</div>
        </div>
      </div>
    </div>

    <!-- ==================== NEGOTIATION MODAL ==================== -->
    <div class="negotiation-modal" id="negotiationModal">
      <div class="negotiation-panel">
        <!-- Chat header with player card -->
        <div class="chat-header">
          <div id="negotiationCard"></div>
          <div class="chat-player-info">
            <h3 id="negotiationPlayerName">Zawodnik</h3>
            <p id="negotiationPlayerDetails">ST | 🇵🇱 | OVR 75</p>
            <p class="price">
              <span data-t="marketPrice">Cena rynkowa</span>:
              <span id="negotiationPrice">€0</span>
            </p>
          </div>
          <button class="chat-close" onclick="closeNegotiation()">✕</button>
        </div>

        <!-- Tension bar -->
        <div class="tension-bar-container">
          <div class="tension-label" data-t="agentMood">😊 Nastrój agenta</div>
          <div class="tension-bar">
            <div class="tension-fill" id="tensionFill"></div>
          </div>
          <div
            class="tension-warning"
            id="tensionWarning"
            data-t="agentWarning"
          >
            ⚠️ Agent traci cierpliwość!
          </div>
        </div>

        <!-- Chat messages -->
        <div class="chat-messages" id="negotiationChat">
          <!-- Messages will be added by JS -->
        </div>

        <!-- Phase 1: Price negotiation -->
        <div class="chat-offer-area" id="pricePhase">
          <div class="phase-title" data-t="phase1">
            💰 FAZA 1: CENA TRANSFERU
          </div>
          <div class="offer-grid">
            <div class="offer-input" style="grid-column: span 2">
              <label data-t="yourOffer">💵 Twoja oferta cenowa</label>
              <input type="number" id="offerPrice" placeholder="€" />
            </div>
          </div>
          <div class="swap-section">
            <label class="swap-toggle">
              <input
                type="checkbox"
                id="includeSwap"
                onchange="toggleSwapPlayer()"
              />
              <span data-t="addSwap">🔄 Dodaj gracza w rozliczeniu</span>
            </label>
            <div
              class="swap-player-select"
              id="swapPlayerSelect"
              style="display: none"
            >
              <select id="swapPlayerDropdown">
                <option value="" data-t="selectSwapPlayer">
                  -- Wybierz gracza --
                </option>
              </select>
              <div class="swap-player-value" id="swapPlayerValue"></div>
            </div>
          </div>
          <div class="chat-buttons">
            <button
              class="btn-send"
              onclick="sendPriceOffer()"
              data-t="sendOffer"
            >
              📤 ZŁÓŻ OFERTĘ
            </button>
            <button
              class="btn-leave"
              onclick="closeNegotiation()"
              data-t="leave"
            >
              ❌ ODEJDŹ
            </button>
          </div>
        </div>

        <!-- Phase 2: Contract negotiation -->
        <div class="chat-offer-area" id="contractPhase" style="display: none">
          <div class="phase-title" data-t="phase2">
            📋 FAZA 2: WARUNKI KONTRAKTU
          </div>
          <div class="offer-grid">
            <div class="offer-input">
              <label data-t="salaryWeek">💰 Pensja/tyg</label>
              <input
                type="number"
                id="offerSalary"
                value="1000"
                placeholder="€"
              />
            </div>
            <div class="offer-input">
              <label data-t="contractYears">📅 Kontrakt (lata)</label>
              <input type="number" id="offerLength" value="3" min="1" max="5" />
            </div>
            <div class="offer-input">
              <label data-t="signingBonus">🎁 Bonus za podpis</label>
              <input
                type="number"
                id="offerBonus"
                value="0"
                data-t-placeholder="optional"
                placeholder="€ (opcjonalne)"
              />
            </div>
            <div class="offer-input">
              <label data-t="releaseClause">🔓 Klauzula wykupu</label>
              <input
                type="number"
                id="offerClause"
                data-t-placeholder="optional"
                placeholder="€ (opcjonalne)"
              />
            </div>
          </div>
          <div class="chat-buttons">
            <button
              class="btn-send"
              onclick="sendContractOffer()"
              data-t="sendOffer"
            >
              📤 ZŁÓŻ OFERTĘ
            </button>
            <button
              class="btn-leave"
              onclick="closeNegotiation()"
              data-t="leave"
            >
              ❌ ODEJDŹ
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- ==================== INSTRUCTIONS MODAL ==================== -->
    <div class="negotiation-modal" id="instructionsModal">
      <div class="negotiation-panel" style="max-width: 800px">
        <h2 style="color: var(--gold); margin-bottom: 1rem">📖 JAK GRAĆ</h2>
        <div style="max-height: 60vh; overflow-y: auto; line-height: 1.6">
          <h3 style="color: var(--gold)">⚽ Podstawy</h3>
          <p>Zarządzaj swoją drużyną, kupuj zawodników i wygrywaj mecze!</p>

          <h3 style="color: var(--gold); margin-top: 1rem">💰 Ekonomia</h3>
          <p>• Wygrane mecze = +€ (więcej za silniejszych przeciwników)</p>
          <p>• Przegrane mecze = -€</p>
          <p>• Mecze ze słabszymi = tylko 100€</p>

          <h3 style="color: var(--gold); margin-top: 1rem">
            🎴 Karty Zawodników
          </h3>
          <p>• Overall 0-40: Bronze</p>
          <p>• Overall 41-60: Silver</p>
          <p>• Overall 61-85: Gold</p>
          <p>• Overall 86-99: Elite</p>
          <p>• Overall 100-200: Ikona (wymaga odblokowania)</p>

          <h3 style="color: var(--gold); margin-top: 1rem">🏪 Rynek</h3>
          <p>
            Co 5 godzin pojawiają się nowe karty. Im wyższy overall, tym
            szybciej znikają!
          </p>

          <h3 style="color: var(--gold); margin-top: 1rem">
            🎮 Sterowanie w meczu
          </h3>
          <p>• Kliknij na boisko = biegnij w to miejsce</p>
          <p>• Przeciągnij myszką = podaj piłkę</p>
          <p>• Statystyki zawodnika wpływają na skuteczność akcji</p>
        </div>
        <button
          class="menu-btn"
          onclick="closeInstructions()"
          style="width: 100%; margin-top: 1rem"
        >
          ZAMKNIJ
        </button>
      </div>
    </div>

    <script>
      // ==================== LANGUAGE SYSTEM ====================
      let currentLang = localStorage.getItem("footballLang") || "pl";

      const translations = {
        pl: {
          // Main menu
          title: "⚽ FOOTBALL MANAGER ULTIMATE",
          managerName: "Nazwa Managera",
          balance: "SALDO",
          play: "⚽ ZAGRAJ",
          squad: "📋 MÓJ SKŁAD",
          market: "🏪 RYNEK TRANSFEROWY",
          legends: "⭐ LEGENDY",
          settings: "⚙️ USTAWIENIA",
          upgrades: "⬆️ ULEPSZENIA",
          reset: "🗑️ RESETUJ GRĘ",

          // Play menu
          penalties: "⚽ RZUTY KARNE",
          easy: "🟢 ŁATWY",
          medium: "🟡 ŚREDNI",
          hard: "🔴 TRUDNY",
          online: "🌐 ONLINE VS GRACZ",
          back: "🔙 POWRÓT",

          // Penalties
          round: "Runda",
          you: "TY",
          opponent: "PRZECIWNIK",
          chooseShot: "🎯 WYBIERZ KIERUNEK STRZAŁU",
          chooseDefense: "🧤 WYBIERZ KIERUNEK OBRONY",
          left: "⬅️ LEWO",
          center: "⬆️ ŚRODEK",
          right: "➡️ PRAWO",
          goal: "⚽ GOOOL!",
          saved: "🧤 OBRONIONE!",
          miss: "💨 PUDŁO!",
          timeMiss: "⏱️ CZAS! PUDŁO!",
          opponentGoal: "⚽ GOL DLA PRZECIWNIKA",
          youWin: "🏆 WYGRAŁEŚ!",
          youLose: "😞 PRZEGRAŁEŚ",
          finalScore: "Końcowy wynik",
          reward: "Nagroda",
          consolation: "Nagroda pocieszenia",
          congrats: "Gratulacje! Wygrałeś rzuty karne!",
          lost: "Przegrałeś rzuty karne.",
          exit: "🔙 WYJDŹ",
          surrender: "🏳️ PODDAJ SIĘ",
          surrenderConfirm: "Czy na pewno chcesz się poddać?",
          playAgain: "🔄 ZAGRAJ PONOWNIE",
          mainMenu: "🏠 MENU GŁÓWNE",
          shoot: "STRZELAJ!",

          // Online
          onlinePenalties: "🌐 KARNE ONLINE",
          chooseOption: "WYBIERZ OPCJĘ",
          createRoom: "🏠 UTWÓRZ POKÓJ",
          or: "— lub —",
          pasteCode: "Wklej link lub kod",
          joinRoom: "🔗 DOŁĄCZ DO POKOJU",
          yourRoom: "TWÓJ POKÓJ",
          copyLink: "📋 KOPIUJ LINK",
          waiting: "Oczekiwanie na przeciwnika...",
          opponentJoined: "✅ Przeciwnik dołączył!",
          start: "ROZPOCZNIJ",
          joining: "DOŁĄCZANIE...",
          connecting: "Łączenie z pokojem...",
          connected: "✅ Połączono! Oczekiwanie na start...",
          linkCopied: "Link skopiowany!",
          waitingOpponent: "⏳ Oczekiwanie na przeciwnika...",
          disconnect: "🏠 ROZŁĄCZ",
          opponentDisconnected: "Przeciwnik rozłączył się",
          hostDisconnected: "Host rozłączył się",
          rematchRequest: "Przeciwnik chce zagrać ponownie. Zgadzasz się?",
          rematchDeclined: "Przeciwnik odmówił rewanżu.",
          waitingForOpponent: "Czekam na przeciwnika...",

          // Squad
          squadTitle: "📋 MÓJ SKŁAD",
          formation: "FORMACJA",
          overall: "ŚREDNIA",
          chemistry: "CHEMIA",
          bench: "🪑 ŁAWKA REZERWOWYCH",
          selectPlayer: "WYBIERZ ZAWODNIKA",
          position: "Pozycja",
          squadTab: "SKŁAD",
          benchTab: "ŁAWKA",
          cancel: "❌ ANULUJ",

          // Market
          marketTitle: "🏪 RYNEK TRANSFEROWY",
          refresh: "Nowe karty za",
          marketPrice: "Cena rynkowa",

          // Negotiation
          phase1: "💰 FAZA 1: CENA TRANSFERU",
          phase2: "📋 FAZA 2: WARUNKI KONTRAKTU",
          yourOffer: "Twoja oferta cenowa",
          addSwap: "🔄 Dodaj gracza w rozliczeniu",
          selectSwapPlayer: "-- Wybierz gracza --",
          swapValue: "Wartość wymiany",
          salaryWeek: "Pensja/tyg",
          contractYears: "Kontrakt (lata)",
          signingBonus: "Bonus za podpis",
          releaseClause: "Klauzula wykupu",
          optional: "(opcjonalne)",
          sendOffer: "📤 ZŁÓŻ OFERTĘ",
          leave: "❌ ODEJDŹ",
          agentMood: "😊 Nastrój agenta",
          agentWarning: "⚠️ Agent traci cierpliwość!",
          notEnoughMoney: "Nie macie wystarczających środków na tę ofertę.",
          playerJoined: "dołączył do Twojej drużyny!",

          // Legends
          legendsTitle: "⭐ LEGENDY NA EMERYTURZE",
          noLegends:
            "Brak legend. Rozwijaj graczy do 90+ OVR i pozwól im przejść na emeryturę!",

          // Player card
          positions: "Pozycje",
          age: "Wiek",

          // Aging
          retired: "przeszedł na emeryturę!",
          retiredLegend: "przeszedł na emeryturę jako LEGENDA!",
          newPlayer: "Nowy gracz dołączył do składu.",

          // Upgrades
          upgradesTitle: "⬆️ ULEPSZENIA ZAWODNIKÓW",
          upgradeStats: "ULEPSZ STATYSTYKĘ",
          upgradePositions: "DODAJ POZYCJĘ",
          confirm: "✅ POTWIERDŹ",
          selectOption: "Wybierz opcję",
          maxLevel: "MAX",
          currentPosition: "obecna",
          positionCostNear: "Podobna pozycja",
          positionCostFar: "Odległa pozycja",
          statUpgraded: "Statystyka ulepszona!",
          positionAdded: "Pozycja dodana!",

          // Settings
          settingsTitle: "⚙️ USTAWIENIA",
          language: "JĘZYK",

          // Mobile block
          mobileTitle: "Tylko na komputerze",
          mobileMsg: "Ta gra wymaga komputera z klawiaturą i myszką.",

          // Instructions
          howToPlay: "📖 JAK GRAĆ",
          basics: "⚽ Podstawy",
          basicsDesc:
            "Zarządzaj swoją drużyną, kupuj zawodników i wygrywaj mecze!",
          economy: "💰 Ekonomia",
          cards: "🎴 Karty Zawodników",
          close: "ZAMKNIJ",

          // Misc
          resetConfirm:
            "Czy na pewno chcesz zresetować grę? Stracisz cały postęp!",
          generating: "Generowanie...",
          unknown: "Nieznany",

          // Squad reveal
          yourSquad: "TWÓJ SKŁAD",
          goalkeeper: "BRAMKARZ",
          defenders: "OBROŃCY",
          midfielders: "POMOCNICY",
          attackers: "NAPASTNICY",
          ready: "✅ GOTOWY!",
          waitingForOpponent: "Oczekiwanie na przeciwnika...",
          bothReady: "Obaj gracze gotowi! Zaczynamy...",

          // Additional alerts
          enterCode: "Wprowadź kod lub link pokoju",
          pasteCodeAlert: "Wklej kod pokoju!",
          notEnoughFunds: "Nie masz wystarczających środków!",
          exitMatchConfirm: "Czy na pewno chcesz wyjść z meczu?",
          result: "Wynik",
          earnings: "Zarobek",
          stats: "Statystyki",
          matches: "Mecze",
          wins: "W",
          draws: "R",
          losses: "P",
          copied: "Skopiowano!",

          // Match results
          victory: "🏆 ZWYCIĘSTWO!",
          defeat: "😞 PORAŻKA",
          draw: "🤝 REMIS",

          // Penalty
          left: "LEWO",
          center: "ŚRODEK",
          right: "PRAWO",
          miss: "💨 PUDŁO!",
          saved: "🧤 OBRONIONE!",
          goal: "⚽ GOOOL!",
          opponentGoal: "⚽ GOL DLA PRZECIWNIKA",
          youWin: "🏆 ZWYCIĘSTWO!",
          youLose: "😞 PORAŻKA",
          finalScore: "Wynik",
          playAgain: "🔄 ZAGRAJ PONOWNIE",
          mainMenu: "🏠 MENU GŁÓWNE",
          rematch: "🔄 REWANŻ",
          exitGame: "🚪 WYJDŹ",
          shooterShoots: "Strzela",
          opponentShoots: "Przeciwnik strzela",
          chooseShot: "🎯 WYBIERZ KIERUNEK STRZAŁU",
          chooseDefense: "🧤 WYBIERZ KIERUNEK OBRONY",
          surrenderConfirm: "Czy na pewno chcesz się poddać?",
          congrats: "Gratulacje! Wygrałeś!",
          lost: "Przegrałeś...",
          reward: "Nagroda",
          consolation: "Pocieszenie",
          roomReady: "Pokój gotowy! Czekam na przeciwnika...",
          connectionError: "Błąd połączenia. Odśwież stronę.",
          cannotConnect: "Nie można połączyć z pokojem.",
          checkCode: "Sprawdź kod.",
          wantRematch: "Przeciwnik chce rewanż. Zgadzasz się?",

          // Emails
          emailTitle: "SKRZYNKA ODBIORCZA",
          noEmails: "Brak wiadomości",
          contractExpiring: "Kontrakt wygasa!",
          contractExpired: "Kontrakt wygasł",
          raiseRequest: "Prośba o podwyżkę",
          renewContract: "Odnów kontrakt",
          fromAgent: "Od: Agent",
          currentSalary: "Obecna pensja",
          requestedSalary: "Żądana pensja",
          contractLength: "Długość kontraktu",
          yearsLeft: "Pozostało lat",
          daysLeft: "Dni na decyzję",
          accept: "✅ AKCEPTUJ",
          negotiate: "💬 NEGOCJUJ",
          reject: "❌ ODRZUĆ",
          closeEmail: "ZAMKNIJ",
          playerLeft: "opuścił klub!",
          salaryPaid: "Wypłata pensji",
          weeklyExpenses: "Wydatki tygodniowe",
          negotiateRenewal: "Negocjuj odnowienie",
          reduceSalary: "Obniż pensję",
          selectPlayerForAction: "-- Wybierz zawodnika --",
          noFundsForSalary: "Brak środków na pensję! Zawodnik może odejść.",
          contractRenewed: "Kontrakt odnowiony!",
          raiseAccepted: "Podwyżka zaakceptowana.",
          raiseRejected: "Podwyżka odrzucona.",
          playerUnhappy: "Gracz jest niezadowolony.",

          // Compose email
          composeEmail: "✉️ WYŚLIJ WIADOMOŚĆ",
          selectPlayerEmail: "Wybierz zawodnika:",
          messageType: "Typ wiadomości:",
          reduceSalaryOption: "Obniż pensję",
          extendContractOption: "Przedłuż kontrakt",
          newSalary: "Nowa pensja (€/tyg):",
          offerSalary: "Proponowana pensja (€/tyg):",
          contractYearsLabel: "Długość kontraktu (lata):",
          sendMessage: "WYŚLIJ",
          currentSalaryIs: "Obecna pensja:",
          contractEndsIn: "Kontrakt kończy się za:",
          years: "lat",
          messageSent: "Wiadomość wysłana! Oczekuj odpowiedzi.",
          playerAccepted: "zaakceptował propozycję!",
          playerRejected: "odrzucił propozycję.",
          playerThinking: "rozważa twoją propozycję...",
          responseTimeout: "Czas na odpowiedź minął.",
          startNegotiation: "💬 NEGOCJUJ",
          acceptDecision: "✅ ZAAKCEPTUJ DECYZJĘ",
          startChat: "ROZPOCZNIJ ROZMOWĘ",
          endChat: "ZAKOŃCZ",
          raiseSalaryOption: "Podwyżka pensji",

          // Squad overall
          squadOverall: "OVR",
          salary: "Pensja:",
          salaryPerWeek: "€/tyg",
          contractYearsShort: "Lata:",

          // Chat messages
          chatGreeting:
            "Cześć, chciałem porozmawiać o twojej sytuacji w klubie.",
          chatGreetingPlayer: "Jasne, słucham Panie Trenerze.",
          chatReduceIntro:
            "Muszę z tobą porozmawiać o pensji. Sytuacja klubu wymaga pewnych zmian.",
          chatReducePlayerAsk: "O co dokładnie chodzi?",
          chatExtendIntro:
            "Chciałbym porozmawiać o przedłużeniu twojego kontraktu.",
          chatExtendPlayerAsk: "Słucham, jaka jest propozycja?",
          chatRaiseIntro:
            "Doceniam twoją pracę i chciałbym porozmawiać o podwyżce.",
          chatRaisePlayerAsk: "To miło słyszeć, co masz na myśli?",
          chatSelectReasons: "Wybierz argumenty (min. 1):",
          selectReasons: "Wybierz argumenty (min. 1):",
          chatEnterOffer: "Teraz podaj swoją ofertę:",
          chatPlayerThinking: "zastanawia się...",
          chatPlayerAccepted:
            "Zgadzam się na tę propozycję! Dziękuję za rozmowę.",
          chatPlayerRejected:
            "Niestety nie mogę się na to zgodzić. Ta oferta jest dla mnie nie do przyjęcia.",
          chatPlayerCounter:
            "Rozumiem twoje argumenty, ale oczekuję lepszych warunków.",
          chatDealDone: "✅ Umowa została zawarta!",
          chatDealFailed: "❌ Negocjacje zakończyły się niepowodzeniem.",
          chatNewOffer: "Co powiesz na taką propozycję?",

          // Reduce salary reasons (20)
          // Reduce salary reasons (50)
          reduceReason1: "Wyniki ostatnich meczów były słabe",
          reduceReason2: "Klub ma problemy finansowe",
          reduceReason3: "Pensja nie odpowiada poziomowi gry",
          reduceReason4: "Młodsi zawodnicy czekają na szansę",
          reduceReason5: "Restrukturyzacja płac w klubie",
          reduceReason6: "Kontuzje ograniczyły twoją grę",
          reduceReason7: "Inni gracze zarabiają mniej za podobną grę",
          reduceReason8: "Potrzebujemy środków na transfery",
          reduceReason9: "Twoja wartość rynkowa spadła",
          reduceReason10: "Nowa strategia płacowa klubu",
          reduceReason11: "Mniej minut na boisku w tym sezonie",
          reduceReason12: "Liga stała się bardziej konkurencyjna",
          reduceReason13: "Sponsorzy zmniejszyli budżet",
          reduceReason14: "Musisz udowodnić swoją wartość",
          reduceReason15: "Wiek wpływa na twoje możliwości",
          reduceReason16: "Brak postępu w rozwoju umiejętności",
          reduceReason17: "Konkurencja na twojej pozycji wzrosła",
          reduceReason18: "Oczekiwania kibiców są wysokie",
          reduceReason19: "Musimy zbalansować budżet",
          reduceReason20: "To sprawiedliwa oferta rynkowa",
          reduceReason21: "Twoja dyspozycja fizyczna spadła",
          reduceReason22: "Brak bramek i asyst w ostatnim czasie",
          reduceReason23: "Trener ma inne plany taktyczne",
          reduceReason24: "Zespół gra lepiej bez ciebie na boisku",
          reduceReason25: "Zarząd wymaga cięć kosztów",
          reduceReason26: "Twoje zachowanie na boisku było krytykowane",
          reduceReason27: "Oczekiwania transferowe się nie spełniły",
          reduceReason28: "Musisz odbudować formę",
          reduceReason29: "Rynek piłkarski się zmienił",
          reduceReason30: "Twoja pensja jest najwyższa w zespole",
          reduceReason31: "Brak zaangażowania na treningach",
          reduceReason32: "Inne priorytety finansowe klubu",
          reduceReason33: "Twoja pozycja w hierarchii spadła",
          reduceReason34: "Musimy inwestować w młodzież",
          reduceReason35: "Poprzedni kontrakt był zbyt hojny",
          reduceReason36: "Wyniki drużyny są rozczarowujące",
          reduceReason37: "Twoja skuteczność spadła",
          reduceReason38: "Brak liderskich zachowań",
          reduceReason39: "Regulamin finansowy ligi wymaga zmian",
          reduceReason40: "Twoje żółte kartki kosztują zespół",
          reduceReason41: "Mniej meczów w tym sezonie",
          reduceReason42: "Inni zawodnicy awansowali ponad ciebie",
          reduceReason43: "Potrzebujemy elastyczności budżetowej",
          reduceReason44: "Twój wpływ na wyniki jest mniejszy",
          reduceReason45: "Kryzys ekonomiczny dotknął klub",
          reduceReason46: "Twoje statystyki nie imponują",
          reduceReason47: "Czas na nowy rozdział w karierze",
          reduceReason48: "Twoja motywacja wydaje się niższa",
          reduceReason49: "Potrzebujemy funduszy na infrastrukturę",
          reduceReason50: "To ostateczna oferta klubu",

          // Extend contract reasons (50)
          extendReason1: "Jesteś kluczowym zawodnikiem drużyny",
          extendReason2: "Twoje doświadczenie jest bezcenne",
          extendReason3: "Kibice cię uwielbiają",
          extendReason4: "Chcemy budować drużynę wokół ciebie",
          extendReason5: "Twoja forma jest doskonała",
          extendReason6: "Widzimy w tobie przyszłego kapitana",
          extendReason7: "Masz świetne relacje z kolegami",
          extendReason8: "Stabilność składu jest dla nas ważna",
          extendReason9: "Doceniamy twoją lojalność",
          extendReason10: "Masz duży potencjał rozwoju",
          extendReason11: "Twoje statystyki są imponujące",
          extendReason12: "Pasujemy do siebie taktycznie",
          extendReason13: "Inwestujemy w twoją przyszłość",
          extendReason14: "Chcemy uniknąć utraty za darmo",
          extendReason15: "Jesteś wzorem dla młodych",
          extendReason16: "Twoja mentalność jest wzorowa",
          extendReason17: "Masz świetny wpływ na szatnię",
          extendReason18: "Oferujemy stabilność finansową",
          extendReason19: "Razem możemy osiągnąć sukces",
          extendReason20: "To najlepsza oferta jaką możemy dać",
          extendReason21: "Trener bardzo cię ceni",
          extendReason22: "Twoje umiejętności są unikalne",
          extendReason23: "Pasjonujesz się grą dla tego klubu",
          extendReason24: "Masz świetną chemię z kolegami",
          extendReason25: "Twoja wszechstronność jest cenna",
          extendReason26: "Znasz nasz system gry doskonale",
          extendReason27: "Jesteś profesjonalistą na i poza boiskiem",
          extendReason28: "Twoja determinacja nas inspiruje",
          extendReason29: "Masz jeszcze wiele do zaoferowania",
          extendReason30: "Widzimy cię w długoterminowych planach",
          extendReason31: "Twoja wartość dla klubu rośnie",
          extendReason32: "Kibice chcą żebyś został",
          extendReason33: "Masz świetne relacje z trenerem",
          extendReason34: "Twoja etyka pracy jest wzorowa",
          extendReason35: "Jesteś ambasadorem klubu",
          extendReason36: "Twoje doświadczenie jest nieocenione",
          extendReason37: "Sponsorzy doceniają twoją obecność",
          extendReason38: "Twoja pozycja w zespole jest bezpieczna",
          extendReason39: "Chcemy nagrodzić twoją wierność",
          extendReason40: "Twój rozwój nas cieszy",
          extendReason41: "Masz kluczową rolę w strategii",
          extendReason42: "Twoja obecność podnosi morale zespołu",
          extendReason43: "Chcemy zapewnić ci przyszłość",
          extendReason44: "Jesteś częścią rodziny klubowej",
          extendReason45: "Twoje osiągnięcia mówią same za siebie",
          extendReason46: "Masz naturalne zdolności przywódcze",
          extendReason47: "Chcemy zbudować legendę razem",
          extendReason48: "Twoja jakość jest niepodważalna",
          extendReason49: "Jesteś sercem tego zespołu",
          extendReason50: "To oferta godna twojej klasy",

          // Raise salary reasons (50)
          raiseReason1: "Twoje wyniki są wybitne",
          raiseReason2: "Zasługujesz na uznanie",
          raiseReason3: "Chcemy pokazać że cię doceniamy",
          raiseReason4: "Inflacja wymaga korekty pensji",
          raiseReason5: "Twoja wartość rynkowa wzrosła",
          raiseReason6: "Inne kluby oferują więcej",
          raiseReason7: "Przeszedłeś wszystkie oczekiwania",
          raiseReason8: "Twój wkład jest nieoceniony",
          raiseReason9: "Chcemy zmotywować cię do dalszej pracy",
          raiseReason10: "Klub rozwija się dzięki tobie",
          raiseReason11: "Zasługujesz na sprawiedliwą płacę",
          raiseReason12: "Twoje poświęcenie jest widoczne",
          raiseReason13: "Chcemy zatrzymać cię na dłużej",
          raiseReason14: "Budżet klubu pozwala na podwyżkę",
          raiseReason15: "Jesteś niedoceniany finansowo",
          raiseReason16: "To nagroda za ciężką pracę",
          raiseReason17: "Chcemy wyrównać do innych graczy",
          raiseReason18: "Twoja pozycja w drużynie wzrosła",
          raiseReason19: "Sponsorzy doceniają twoją grę",
          raiseReason20: "To inwestycja w przyszłość klubu",
          raiseReason21: "Twoje bramki są kluczowe",
          raiseReason22: "Twoja gra obronna jest solidna",
          raiseReason23: "Masz najlepsze statystyki w zespole",
          raiseReason24: "Twoja forma jest stabilna",
          raiseReason25: "Kibice skandują twoje imię",
          raiseReason26: "Twoje asysty zmieniają mecze",
          raiseReason27: "Jesteś motorem napędowym drużyny",
          raiseReason28: "Twoja kreatywność jest wyjątkowa",
          raiseReason29: "Masz świetną etykę pracy",
          raiseReason30: "Twoja charyzma jednoczy zespół",
          raiseReason31: "Zasługujesz na wyższą pensję",
          raiseReason32: "Twoja konsekwencja jest imponująca",
          raiseReason33: "Rozwijasz się z każdym meczem",
          raiseReason34: "Twoja inteligencja boiskowa jest wysoka",
          raiseReason35: "Jesteś niezawodny w kluczowych momentach",
          raiseReason36: "Twoja profesjonalność jest wzorowa",
          raiseReason37: "Masz naturalny talent",
          raiseReason38: "Twoje umiejętności techniczne rosną",
          raiseReason39: "Jesteś liderem na boisku",
          raiseReason40: "Twoja obecność dodaje pewności zespołowi",
          raiseReason41: "Masz świetne zrozumienie gry",
          raiseReason42: "Twoja wszechstronność jest cenna",
          raiseReason43: "Jesteś jednym z najlepszych na pozycji",
          raiseReason44: "Twoja determinacja jest inspirująca",
          raiseReason45: "Masz wpływ na wyniki drużyny",
          raiseReason46: "Zasłużyłeś na to ciężką pracą",
          raiseReason47: "Twoje podania są precyzyjne",
          raiseReason48: "Masz świetne wyczucie pozycji",
          raiseReason49: "Jesteś perełką w naszym składzie",
          raiseReason50: "Ta podwyżka to minimum co możemy zrobić",

          // Match ratings
          avgRating: "Średnia ocena",
          matchRating: "Ocena meczowa",
          goals: "Gole",
          assists: "Asysty",
          cleanSheets: "Czyste konta",
          saves: "Obrony",
          noRatings: "Brak ocen",

          // Injury system
          injured: "KONTUZJA",
          injuryAlert:
            "🏥 {player} doznał kontuzji! Będzie niedostępny przez 1 dzień.",
          playerInjured: "KONTUZJOWANY",
          injuryWarning:
            "⚠️ {player} jest kontuzjowany! Czy na pewno chcesz go wystawić?",
          injuryProtest: "😤 {player} protestuje przeciwko grze z kontuzją!",
          wrongPositionWarning:
            "⚠️ {player} gra na niewłaściwej pozycji ({current} zamiast {original})!",
          wrongPositionProtest:
            "😤 {player} protestuje przeciwko grze na złej pozycji!",
          protestOptions: "Co chcesz zrobić?",
          ignoreProtest: "🚫 Ignoruj protest",
          acceptProtest: "✅ Zaakceptuj (zdejmij gracza)",
          payFine: "💰 Zapłać grzywnę",
          fineAmount: "Grzywna: €{amount}",
          playerRefuses: "❌ {player} odmawia gry i żąda grzywny €{amount}!",
          playerBanned:
            "🚫 {player} nie zagra w tym meczu i nie może być zastąpiony!",
          overallDropped:
            "📉 {player} stracił {points} OVR przez grę na złej pozycji!",
          injuryHealed: "✅ {player} wyzdrowiał z kontuzji!",
          stillInjured:
            "🏥 {player} nadal jest kontuzjowany ({hours}h pozostało)",

          // Transfer list system
          transferList: "💰 LISTA TRANSFEROWA",
          listForSale: "🏷️ WYSTAW NA SPRZEDAŻ",
          removeFromList: "❌ USUŃ Z LISTY",
          askingPrice: "Cena wywoławcza",
          playerListed: "✅ {player} wystawiony na sprzedaż!",
          playerUnlisted: "❌ {player} usunięty z listy transferowej",
          noOffersYet: "Brak ofert - poczekaj...",
          newOffer: "📨 Nowa oferta!",
          offersReceived: "Otrzymane oferty",
          fromClub: "od",
          acceptOffer: "✅ Akceptuj",
          rejectOffer: "❌ Odrzuć",
          negotiateOffer: "💬 Negocjuj",
          offerAccepted: "✅ Sprzedałeś {player} do {club} za €{price}!",
          offerRejected: "❌ Odrzuciłeś ofertę od {club}",
          listedPlayers: "Gracze na liście",
          clickToSell: "Kliknij kartę aby wystawić na sprzedaż",
          marketValue: "WARTOŚĆ RYNKOWA",
          listedForSale: "WYSTAWIONE NA SPRZEDAŻ",
          clickToFlip: "Kliknij kartę aby obrócić",
          alreadyListed: "Ten gracz jest już na liście transferowej",

          // Sell negotiation reasons (50)
          sellReason1: "Gracz jest kluczowy dla naszego składu",
          sellReason2: "Cena jest zbyt niska jak na jego talent",
          sellReason3: "Mamy długoterminowe plany z tym graczem",
          sellReason4: "Kibice go uwielbiają",
          sellReason5: "Jest w szczytowej formie",
          sellReason6: "Inne kluby oferowały więcej",
          sellReason7: "Jego wartość rynkowa rośnie",
          sellReason8: "Potrzebujemy go do końca sezonu",
          sellReason9: "To niesprawiedliwa oferta",
          sellReason10: "Ma duży potencjał rozwoju",
          sellReason11: "Trudno będzie go zastąpić",
          sellReason12: "Kontrakt jest długoterminowy",
          sellReason13: "Sponsor wymaga jego obecności",
          sellReason14: "Jest liderem szatni",
          sellReason15: "Media go uwielbiają",
          sellReason16: "Statystyki mówią same za siebie",
          sellReason17: "Inwestowaliśmy w jego rozwój",
          sellReason18: "Byłby stratą dla ligi",
          sellReason19: "Nie jesteśmy zdesperowani",
          sellReason20: "Cena musi odzwierciedlać jego klasę",
          sellReason21: "To nasz najlepszy strzelec",
          sellReason22: "Ma świetne statystyki w tym sezonie",
          sellReason23: "Jest częścią naszego projektu sportowego",
          sellReason24: "Jego umiejętności są unikalne",
          sellReason25: "Dopiero co przedłużył kontrakt",
          sellReason26: "Nie możemy go stracić w środku sezonu",
          sellReason27: "Trener uważa go za niezbędnego",
          sellReason28: "Ma świetną chemię z drużyną",
          sellReason29: "Jest gwarancją bramek",
          sellReason30: "Jego obrona jest kluczowa",
          sellReason31: "Ma najlepsze podania w zespole",
          sellReason32: "Jest naszym najszybszym graczem",
          sellReason33: "Jego doświadczenie jest bezcenne",
          sellReason34: "Młodzi gracze się od niego uczą",
          sellReason35: "Jest twarzą naszego klubu",
          sellReason36: "Sponsorzy podpisali z nim umowę",
          sellReason37: "Nie znajdziemy godnego zastępcy",
          sellReason38: "Rynek transferowy jest zamknięty",
          sellReason39: "Mamy ambicje mistrzowskie",
          sellReason40: "Jest w najlepszym wieku",
          sellReason41: "Jego wartość tylko rośnie",
          sellReason42: "Byłby to cios dla morale drużyny",
          sellReason43: "Kibice by nas za to znienawidzili",
          sellReason44: "Ma klauzulę wykupu wyższą od oferty",
          sellReason45: "Jest niezawodny w kluczowych meczach",
          sellReason46: "Jego etyka pracy jest wzorowa",
          sellReason47: "Jest gwiazdą mediów społecznościowych",
          sellReason48: "Rywale by zyskali za dużo",
          sellReason49: "To strategiczny zawodnik dla nas",
          sellReason50: "Ta oferta to obraza dla jego klasy",

          // Free kicks
          freeKicks: "⚽ RZUTY WOLNE",
          penaltiesMode: "⚽ KARNE (DOGRYWKA)",
          distance: "Odległość",
          meters: "m",
          curve: "ZAKRĘCENIE",
          power: "SIŁA",
          clickToAim: "KLIKNIJ GDZIE CELUJESZ",
          setCurve: "KLIKNIJ ABY USTAWIĆ ZAKRĘCENIE",
          setPower: "KLIKNIJ ABY USTAWIĆ SIŁĘ",
          tiebreaker: "REMIS! DOGRYWKA - KARNE",

          // Upgrade modal
          upgradePlayer: "ULEPSZ ZAWODNIKA",
          currentStats: "Obecne statystyki",
          afterUpgrade: "Po ulepszeniu",
          cost: "Koszt",

          // Negotiation agent messages
          agentGreeting:
            "Dzień dobry. Reprezentuję {player}. Cena wywoławcza to €{price}. Jaką kwotę Państwo proponują?",
          agentPriceOk:
            "Cena zaakceptowana! Przejdźmy teraz do warunków kontraktu.",
          agentPriceLow: "To za mało. Proszę o lepszą ofertę.",
          agentLeaves: "Dosyć! Negocjacje zakończone.",
          agentContractOk: "Świetnie! Podpisujemy kontrakt. Witamy w klubie!",
          totalOffer: "łącznie",

          // Arena system
          arenas: "ARENY",
          currentArena: "Aktualna Arena",
          win: "Wygrana",
          lose: "Przegrana",
          botOVR: "OVR Bota",
          playMatch: "⚽ ZAGRAJ MECZ",
          changeArena: "🏟️ ZMIEŃ ARENĘ",
          selectArena: "WYBIERZ ARENĘ",
          unlocked: "ODBLOKOWANA",
          current: "AKTUALNA",

          // Training points
          trainingPoints: "Punkty Treningowe",
          upgradeStats: "ULEPSZENIE STATYSTYK",
          selectStat: "Wybierz statystykę",
          pointsToAdd: "Ile punktów dodać",
          currentValue: "Aktualna wartość",
          newValue: "Nowa wartość",
          upgradeCost: "Koszt",
          confirmUpgrade: "ULEPSZ",
          notEnoughTP: "Za mało punktów treningowych!",

          // Settings
          dangerZone: "⚠️ STREFA ZAGROŻENIA",
          resetProgress: "🗑️ RESETUJ POSTĘPY",

          // Penalty messages
          youScored: "⚽ GOOOL! Strzeliłeś!",
          youMissed: "💨 PUDŁO! Spudłowałeś!",
          youSaved: "🧤 OBRONA! Obroniłeś!",
          opponentScored: "⚽ GOL! Przeciwnik strzelił!",
          opponentSaved: "🧤 OBRONIONE! Bramkarz obronił!",
          opponentMissed: "💨 PUDŁO! Przeciwnik spudłował!",
        },
        en: {
          // Main menu
          title: "⚽ FOOTBALL MANAGER ULTIMATE",
          managerName: "Manager Name",
          balance: "BALANCE",
          play: "⚽ PLAY",
          squad: "📋 MY SQUAD",
          market: "🏪 TRANSFER MARKET",
          legends: "⭐ LEGENDS",
          settings: "⚙️ SETTINGS",
          upgrades: "⬆️ UPGRADES",
          reset: "🗑️ RESET GAME",

          // Play menu
          penalties: "⚽ PENALTY SHOOTOUT",
          easy: "🟢 EASY",
          medium: "🟡 MEDIUM",
          hard: "🔴 HARD",
          online: "🌐 ONLINE VS PLAYER",
          back: "🔙 BACK",

          // Penalties
          round: "Round",
          you: "YOU",
          opponent: "OPPONENT",
          chooseShot: "🎯 CHOOSE SHOT DIRECTION",
          chooseDefense: "🧤 CHOOSE SAVE DIRECTION",
          left: "⬅️ LEFT",
          center: "⬆️ CENTER",
          right: "➡️ RIGHT",
          goal: "⚽ GOAAL!",
          saved: "🧤 SAVED!",
          miss: "💨 MISS!",
          timeMiss: "⏱️ TIME! MISS!",
          opponentGoal: "⚽ OPPONENT SCORES",
          youWin: "🏆 YOU WIN!",
          youLose: "😞 YOU LOSE",
          finalScore: "Final score",
          reward: "Reward",
          consolation: "Consolation prize",
          congrats: "Congratulations! You won the penalty shootout!",
          lost: "You lost the penalty shootout.",
          exit: "🔙 EXIT",
          surrender: "🏳️ SURRENDER",
          surrenderConfirm: "Are you sure you want to surrender?",
          playAgain: "🔄 PLAY AGAIN",
          mainMenu: "🏠 MAIN MENU",
          shoot: "SHOOT!",

          // Online
          onlinePenalties: "🌐 ONLINE PENALTIES",
          chooseOption: "CHOOSE OPTION",
          createRoom: "🏠 CREATE ROOM",
          or: "— or —",
          pasteCode: "Paste link or code",
          joinRoom: "🔗 JOIN ROOM",
          yourRoom: "YOUR ROOM",
          copyLink: "📋 COPY LINK",
          waiting: "Waiting for opponent...",
          opponentJoined: "✅ Opponent joined!",
          start: "START",
          joining: "JOINING...",
          connecting: "Connecting to room...",
          connected: "✅ Connected! Waiting for start...",
          linkCopied: "Link copied!",
          waitingOpponent: "⏳ Waiting for opponent...",
          disconnect: "🏠 DISCONNECT",
          opponentDisconnected: "Opponent disconnected",
          hostDisconnected: "Host disconnected",
          rematchRequest: "Opponent wants a rematch. Do you accept?",
          rematchDeclined: "Opponent declined rematch.",
          waitingForOpponent: "Waiting for opponent...",

          // Squad
          squadTitle: "📋 MY SQUAD",
          formation: "FORMATION",
          overall: "AVERAGE",
          chemistry: "CHEMISTRY",
          bench: "🪑 BENCH",
          selectPlayer: "SELECT PLAYER",
          position: "Position",
          squadTab: "SQUAD",
          benchTab: "BENCH",
          cancel: "❌ CANCEL",

          // Market
          marketTitle: "🏪 TRANSFER MARKET",
          refresh: "New cards in",
          marketPrice: "Market price",

          // Negotiation
          phase1: "💰 PHASE 1: TRANSFER FEE",
          phase2: "📋 PHASE 2: CONTRACT TERMS",
          yourOffer: "Your price offer",
          addSwap: "🔄 Add player in exchange",
          selectSwapPlayer: "-- Select player --",
          swapValue: "Exchange value",
          salaryWeek: "Salary/week",
          contractYears: "Contract (years)",
          signingBonus: "Signing bonus",
          releaseClause: "Release clause",
          optional: "(optional)",
          sendOffer: "📤 SEND OFFER",
          leave: "❌ LEAVE",
          agentMood: "😊 Agent mood",
          agentWarning: "⚠️ Agent is losing patience!",
          notEnoughMoney: "You don't have enough funds for this offer.",
          playerJoined: "joined your team!",

          // Legends
          legendsTitle: "⭐ RETIRED LEGENDS",
          noLegends:
            "No legends yet. Develop players to 90+ OVR and let them retire!",

          // Player card
          positions: "Positions",
          age: "Age",

          // Aging
          retired: "has retired!",
          retiredLegend: "has retired as a LEGEND!",
          newPlayer: "New player joined the squad.",

          // Upgrades
          upgradesTitle: "⬆️ PLAYER UPGRADES",
          upgradeStats: "UPGRADE STAT",
          upgradePositions: "ADD POSITION",
          confirm: "✅ CONFIRM",
          selectOption: "Select option",
          maxLevel: "MAX",
          currentPosition: "current",
          positionCostNear: "Similar position",
          positionCostFar: "Distant position",
          statUpgraded: "Stat upgraded!",
          positionAdded: "Position added!",

          // Settings
          settingsTitle: "⚙️ SETTINGS",
          language: "LANGUAGE",

          // Mobile block
          mobileTitle: "Desktop Only",
          mobileMsg: "This game requires a computer with keyboard and mouse.",

          // Instructions
          howToPlay: "📖 HOW TO PLAY",
          basics: "⚽ Basics",
          basicsDesc: "Manage your team, buy players and win matches!",
          economy: "💰 Economy",
          cards: "🎴 Player Cards",
          close: "CLOSE",

          // Misc
          resetConfirm:
            "Are you sure you want to reset? You will lose all progress!",
          generating: "Generating...",
          unknown: "Unknown",

          // Squad reveal
          yourSquad: "YOUR SQUAD",
          goalkeeper: "GOALKEEPER",
          defenders: "DEFENDERS",
          midfielders: "MIDFIELDERS",
          attackers: "ATTACKERS",
          ready: "✅ READY!",
          waitingForOpponent: "Waiting for opponent...",
          bothReady: "Both players ready! Starting...",

          // Additional alerts
          enterCode: "Enter room code or link",
          pasteCodeAlert: "Paste room code!",
          notEnoughFunds: "You don't have enough funds!",
          exitMatchConfirm: "Are you sure you want to exit the match?",
          result: "Result",
          earnings: "Earnings",
          stats: "Stats",
          matches: "Matches",
          wins: "W",
          draws: "D",
          losses: "L",
          copied: "Copied!",

          // Match results
          victory: "🏆 VICTORY!",
          defeat: "😞 DEFEAT",
          draw: "🤝 DRAW",

          // Penalty
          left: "LEFT",
          center: "CENTER",
          right: "RIGHT",
          miss: "💨 MISS!",
          saved: "🧤 SAVED!",
          goal: "⚽ GOAAL!",
          opponentGoal: "⚽ OPPONENT SCORES",
          youWin: "🏆 VICTORY!",
          youLose: "😞 DEFEAT",
          finalScore: "Score",
          playAgain: "🔄 PLAY AGAIN",
          mainMenu: "🏠 MAIN MENU",
          rematch: "🔄 REMATCH",
          exitGame: "🚪 EXIT",
          shooterShoots: "Shoots",
          opponentShoots: "Opponent shoots",
          chooseShot: "🎯 CHOOSE SHOT DIRECTION",
          chooseDefense: "🧤 CHOOSE SAVE DIRECTION",
          surrenderConfirm: "Are you sure you want to surrender?",
          congrats: "Congratulations! You won!",
          lost: "You lost...",
          reward: "Reward",
          consolation: "Consolation",
          roomReady: "Room ready! Waiting for opponent...",
          connectionError: "Connection error. Refresh the page.",
          cannotConnect: "Cannot connect to room.",
          checkCode: "Check the code.",
          wantRematch: "Opponent wants rematch. Accept?",

          // Emails
          emailTitle: "INBOX",
          noEmails: "No messages",
          contractExpiring: "Contract expiring!",
          contractExpired: "Contract expired",
          raiseRequest: "Raise request",
          renewContract: "Renew contract",
          fromAgent: "From: Agent",
          currentSalary: "Current salary",
          requestedSalary: "Requested salary",
          contractLength: "Contract length",
          yearsLeft: "Years left",
          daysLeft: "Days to decide",
          accept: "✅ ACCEPT",
          negotiate: "💬 NEGOTIATE",
          reject: "❌ REJECT",
          closeEmail: "CLOSE",
          playerLeft: "left the club!",
          salaryPaid: "Salary payment",
          weeklyExpenses: "Weekly expenses",
          negotiateRenewal: "Negotiate renewal",
          reduceSalary: "Reduce salary",
          selectPlayerForAction: "-- Select player --",
          noFundsForSalary: "No funds for salary! Player may leave.",
          contractRenewed: "Contract renewed!",
          raiseAccepted: "Raise accepted.",
          raiseRejected: "Raise rejected.",
          playerUnhappy: "Player is unhappy.",

          // Compose email
          composeEmail: "✉️ SEND MESSAGE",
          selectPlayerEmail: "Select player:",
          messageType: "Message type:",
          reduceSalaryOption: "Reduce salary",
          extendContractOption: "Extend contract",
          newSalary: "New salary (€/week):",
          offerSalary: "Offered salary (€/week):",
          contractYearsLabel: "Contract length (years):",
          sendMessage: "SEND",
          currentSalaryIs: "Current salary:",
          contractEndsIn: "Contract ends in:",
          years: "years",
          messageSent: "Message sent! Awaiting response.",
          playerAccepted: "accepted the offer!",
          playerRejected: "rejected the offer.",
          playerThinking: "is considering your offer...",
          responseTimeout: "Response time expired.",
          startNegotiation: "💬 NEGOTIATE",
          acceptDecision: "✅ ACCEPT DECISION",
          startChat: "START CONVERSATION",
          endChat: "FINISH",
          raiseSalaryOption: "Salary raise",

          // Squad overall
          squadOverall: "OVR",
          salary: "Salary:",
          salaryPerWeek: "€/wk",
          contractYearsShort: "Years:",

          // Chat messages
          chatGreeting:
            "Hi, I wanted to talk about your situation at the club.",
          chatGreetingPlayer: "Sure, I'm listening Coach.",
          chatReduceIntro:
            "I need to talk to you about your salary. The club situation requires some changes.",
          chatReducePlayerAsk: "What exactly do you mean?",
          chatExtendIntro: "I'd like to discuss extending your contract.",
          chatExtendPlayerAsk: "I'm listening, what's the offer?",
          chatRaiseIntro:
            "I appreciate your work and would like to discuss a raise.",
          chatRaisePlayerAsk: "That's nice to hear, what do you have in mind?",
          chatSelectReasons: "Select your arguments (min. 1):",
          selectReasons: "Select your arguments (min. 1):",
          chatEnterOffer: "Now enter your offer:",
          chatPlayerThinking: "is thinking...",
          chatPlayerAccepted:
            "I agree to this proposal! Thank you for the conversation.",
          chatPlayerRejected:
            "Unfortunately I cannot agree to this. This offer is unacceptable to me.",
          chatPlayerCounter:
            "I understand your arguments, but I expect better terms.",
          chatDealDone: "✅ Deal has been made!",
          chatDealFailed: "❌ Negotiations have failed.",
          chatNewOffer: "What do you think about this proposal?",

          // Reduce salary reasons (20)
          // Reduce salary reasons (50)
          reduceReason1: "Recent match performances were poor",
          reduceReason2: "Club is facing financial issues",
          reduceReason3: "Salary doesn't match performance level",
          reduceReason4: "Younger players are waiting for a chance",
          reduceReason5: "Club wage restructuring",
          reduceReason6: "Injuries have limited your playing time",
          reduceReason7: "Other players earn less for similar performance",
          reduceReason8: "We need funds for transfers",
          reduceReason9: "Your market value has dropped",
          reduceReason10: "New club salary policy",
          reduceReason11: "Less minutes on the pitch this season",
          reduceReason12: "The league has become more competitive",
          reduceReason13: "Sponsors have reduced the budget",
          reduceReason14: "You need to prove your worth",
          reduceReason15: "Age is affecting your abilities",
          reduceReason16: "Lack of progress in skill development",
          reduceReason17: "Competition for your position has increased",
          reduceReason18: "Fan expectations are high",
          reduceReason19: "We need to balance the budget",
          reduceReason20: "This is a fair market offer",
          reduceReason21: "Your physical condition has declined",
          reduceReason22: "No goals or assists recently",
          reduceReason23: "Coach has different tactical plans",
          reduceReason24: "Team plays better without you on pitch",
          reduceReason25: "Board demands cost cuts",
          reduceReason26: "Your on-pitch behavior was criticized",
          reduceReason27: "Transfer expectations weren't met",
          reduceReason28: "You need to rebuild your form",
          reduceReason29: "Football market has changed",
          reduceReason30: "Your salary is the highest in the team",
          reduceReason31: "Lack of training commitment",
          reduceReason32: "Other financial priorities for the club",
          reduceReason33: "Your position in hierarchy has dropped",
          reduceReason34: "We must invest in youth",
          reduceReason35: "Previous contract was too generous",
          reduceReason36: "Team results are disappointing",
          reduceReason37: "Your effectiveness has dropped",
          reduceReason38: "Lack of leadership behavior",
          reduceReason39: "League financial regulations require changes",
          reduceReason40: "Your yellow cards cost the team",
          reduceReason41: "Fewer matches this season",
          reduceReason42: "Other players have advanced above you",
          reduceReason43: "We need budget flexibility",
          reduceReason44: "Your impact on results is smaller",
          reduceReason45: "Economic crisis has hit the club",
          reduceReason46: "Your statistics aren't impressive",
          reduceReason47: "Time for a new chapter in your career",
          reduceReason48: "Your motivation seems lower",
          reduceReason49: "We need funds for infrastructure",
          reduceReason50: "This is the club's final offer",

          // Extend contract reasons (50)
          extendReason1: "You are a key player for the team",
          extendReason2: "Your experience is invaluable",
          extendReason3: "Fans love you",
          extendReason4: "We want to build the team around you",
          extendReason5: "Your form is excellent",
          extendReason6: "We see you as a future captain",
          extendReason7: "You have great relationships with teammates",
          extendReason8: "Squad stability is important to us",
          extendReason9: "We appreciate your loyalty",
          extendReason10: "You have great development potential",
          extendReason11: "Your statistics are impressive",
          extendReason12: "We fit together tactically",
          extendReason13: "We're investing in your future",
          extendReason14: "We want to avoid losing you for free",
          extendReason15: "You're a role model for the youth",
          extendReason16: "Your mentality is exemplary",
          extendReason17: "You have great influence in the locker room",
          extendReason18: "We offer financial stability",
          extendReason19: "Together we can achieve success",
          extendReason20: "This is the best offer we can give",
          extendReason21: "The coach values you highly",
          extendReason22: "Your skills are unique",
          extendReason23: "You're passionate about playing for this club",
          extendReason24: "You have great chemistry with teammates",
          extendReason25: "Your versatility is valuable",
          extendReason26: "You know our playing system perfectly",
          extendReason27: "You're a professional on and off the pitch",
          extendReason28: "Your determination inspires us",
          extendReason29: "You still have much to offer",
          extendReason30: "We see you in our long-term plans",
          extendReason31: "Your value to the club is growing",
          extendReason32: "Fans want you to stay",
          extendReason33: "You have great relationship with the coach",
          extendReason34: "Your work ethic is exemplary",
          extendReason35: "You're a club ambassador",
          extendReason36: "Your experience is priceless",
          extendReason37: "Sponsors appreciate your presence",
          extendReason38: "Your position in the team is secure",
          extendReason39: "We want to reward your loyalty",
          extendReason40: "Your development pleases us",
          extendReason41: "You have a key role in our strategy",
          extendReason42: "Your presence boosts team morale",
          extendReason43: "We want to secure your future",
          extendReason44: "You're part of the club family",
          extendReason45: "Your achievements speak for themselves",
          extendReason46: "You have natural leadership qualities",
          extendReason47: "We want to build a legacy together",
          extendReason48: "Your quality is undeniable",
          extendReason49: "You are the heart of this team",
          extendReason50: "This offer is worthy of your class",

          // Raise salary reasons (50)
          raiseReason1: "Your results are outstanding",
          raiseReason2: "You deserve recognition",
          raiseReason3: "We want to show we appreciate you",
          raiseReason4: "Inflation requires salary adjustment",
          raiseReason5: "Your market value has increased",
          raiseReason6: "Other clubs are offering more",
          raiseReason7: "You've exceeded all expectations",
          raiseReason8: "Your contribution is invaluable",
          raiseReason9: "We want to motivate you to continue",
          raiseReason10: "The club is growing because of you",
          raiseReason11: "You deserve fair pay",
          raiseReason12: "Your dedication is visible",
          raiseReason13: "We want to keep you longer",
          raiseReason14: "Club budget allows for a raise",
          raiseReason15: "You are financially undervalued",
          raiseReason16: "This is a reward for hard work",
          raiseReason17: "We want to match other players",
          raiseReason18: "Your position in the team has grown",
          raiseReason19: "Sponsors appreciate your play",
          raiseReason20: "This is an investment in the club's future",
          raiseReason21: "Your goals are crucial",
          raiseReason22: "Your defensive work is solid",
          raiseReason23: "You have the best stats in the team",
          raiseReason24: "Your form is stable",
          raiseReason25: "Fans chant your name",
          raiseReason26: "Your assists change games",
          raiseReason27: "You're the driving force of the team",
          raiseReason28: "Your creativity is exceptional",
          raiseReason29: "You have great work ethic",
          raiseReason30: "Your charisma unites the team",
          raiseReason31: "You deserve a higher salary",
          raiseReason32: "Your consistency is impressive",
          raiseReason33: "You improve with every match",
          raiseReason34: "Your tactical intelligence is high",
          raiseReason35: "You're reliable in key moments",
          raiseReason36: "Your professionalism is exemplary",
          raiseReason37: "You have natural talent",
          raiseReason38: "Your technical skills are growing",
          raiseReason39: "You're a leader on the pitch",
          raiseReason40: "Your presence gives the team confidence",
          raiseReason41: "You have great understanding of the game",
          raiseReason42: "Your versatility is valuable",
          raiseReason43: "You're one of the best in your position",
          raiseReason44: "Your determination is inspiring",
          raiseReason45: "You impact team results",
          raiseReason46: "You've earned this through hard work",
          raiseReason47: "Your passes are precise",
          raiseReason48: "You have great positional sense",
          raiseReason49: "You're a gem in our squad",
          raiseReason50: "This raise is the minimum we can do",

          // Match ratings
          avgRating: "Avg rating",
          matchRating: "Match rating",
          goals: "Goals",
          assists: "Assists",
          cleanSheets: "Clean sheets",
          saves: "Saves",
          noRatings: "No ratings",

          // Injury system
          injured: "INJURED",
          injuryAlert:
            "🏥 {player} got injured! Will be unavailable for 1 day.",
          playerInjured: "INJURED",
          injuryWarning:
            "⚠️ {player} is injured! Are you sure you want to play him?",
          injuryProtest: "😤 {player} protests against playing while injured!",
          wrongPositionWarning:
            "⚠️ {player} is playing in wrong position ({current} instead of {original})!",
          wrongPositionProtest:
            "😤 {player} protests against playing in wrong position!",
          protestOptions: "What do you want to do?",
          ignoreProtest: "🚫 Ignore protest",
          acceptProtest: "✅ Accept (remove player)",
          payFine: "💰 Pay fine",
          fineAmount: "Fine: €{amount}",
          playerRefuses:
            "❌ {player} refuses to play and demands €{amount} fine!",
          playerBanned:
            "🚫 {player} won't play this match and cannot be replaced!",
          overallDropped:
            "📉 {player} lost {points} OVR from playing wrong position!",
          injuryHealed: "✅ {player} has recovered from injury!",
          stillInjured: "🏥 {player} is still injured ({hours}h remaining)",

          // Transfer list system
          transferList: "💰 TRANSFER LIST",
          listForSale: "🏷️ LIST FOR SALE",
          removeFromList: "❌ REMOVE FROM LIST",
          askingPrice: "Asking price",
          playerListed: "✅ {player} listed for sale!",
          playerUnlisted: "❌ {player} removed from transfer list",
          noOffersYet: "No offers yet - wait...",
          newOffer: "📨 New offer!",
          offersReceived: "Offers received",
          fromClub: "from",
          acceptOffer: "✅ Accept",
          rejectOffer: "❌ Reject",
          negotiateOffer: "💬 Negotiate",
          offerAccepted: "✅ You sold {player} to {club} for €{price}!",
          offerRejected: "❌ You rejected offer from {club}",
          listedPlayers: "Listed players",
          clickToSell: "Click a card to list for sale",
          marketValue: "MARKET VALUE",
          listedForSale: "LISTED FOR SALE",
          clickToFlip: "Click card to flip",
          alreadyListed: "This player is already on the transfer list",

          // Sell negotiation reasons (20)
          // Sell negotiation reasons (50)
          sellReason1: "Player is key to our squad",
          sellReason2: "Price is too low for his talent",
          sellReason3: "We have long-term plans with this player",
          sellReason4: "Fans love him",
          sellReason5: "He is in peak form",
          sellReason6: "Other clubs offered more",
          sellReason7: "His market value is rising",
          sellReason8: "We need him until end of season",
          sellReason9: "This is an unfair offer",
          sellReason10: "He has great development potential",
          sellReason11: "He will be hard to replace",
          sellReason12: "Contract is long-term",
          sellReason13: "Sponsor requires his presence",
          sellReason14: "He is a locker room leader",
          sellReason15: "Media loves him",
          sellReason16: "Statistics speak for themselves",
          sellReason17: "We invested in his development",
          sellReason18: "He would be a loss for the league",
          sellReason19: "We are not desperate",
          sellReason20: "Price must reflect his class",
          sellReason21: "He is our top scorer",
          sellReason22: "He has great stats this season",
          sellReason23: "He is part of our sporting project",
          sellReason24: "His skills are unique",
          sellReason25: "He just renewed his contract",
          sellReason26: "We cannot lose him mid-season",
          sellReason27: "Coach considers him essential",
          sellReason28: "He has great chemistry with the team",
          sellReason29: "He is a goal guarantee",
          sellReason30: "His defense is crucial",
          sellReason31: "He has the best passes in the team",
          sellReason32: "He is our fastest player",
          sellReason33: "His experience is priceless",
          sellReason34: "Young players learn from him",
          sellReason35: "He is the face of our club",
          sellReason36: "Sponsors signed a deal with him",
          sellReason37: "We won't find a worthy replacement",
          sellReason38: "Transfer window is closed",
          sellReason39: "We have championship ambitions",
          sellReason40: "He is in his prime age",
          sellReason41: "His value only keeps rising",
          sellReason42: "It would be a blow to team morale",
          sellReason43: "Fans would hate us for this",
          sellReason44: "His buyout clause is higher than the offer",
          sellReason45: "He is reliable in crucial matches",
          sellReason46: "His work ethic is exemplary",
          sellReason47: "He is a social media star",
          sellReason48: "Rivals would gain too much",
          sellReason49: "He is a strategic player for us",
          sellReason50: "This offer is an insult to his class",

          // Free kicks
          freeKicks: "⚽ FREE KICKS",
          penaltiesMode: "⚽ PENALTIES (TIEBREAKER)",
          distance: "Distance",
          meters: "m",
          curve: "CURVE",
          power: "POWER",
          clickToAim: "CLICK WHERE TO AIM",
          setCurve: "CLICK TO SET CURVE",
          setPower: "CLICK TO SET POWER",
          tiebreaker: "DRAW! TIEBREAKER - PENALTIES",

          // Upgrade modal
          upgradePlayer: "UPGRADE PLAYER",
          currentStats: "Current stats",
          afterUpgrade: "After upgrade",
          cost: "Cost",

          // Negotiation agent messages
          agentGreeting:
            "Hello. I represent {player}. Starting price is €{price}. What is your offer?",
          agentPriceOk: "Price accepted! Let's discuss contract terms.",
          agentPriceLow: "That's too low. Please make a better offer.",
          agentLeaves: "Enough! Negotiations are over.",
          agentContractOk:
            "Great! We're signing the contract. Welcome to the club!",
          totalOffer: "total",

          // Arena system
          arenas: "ARENAS",
          currentArena: "Current Arena",
          win: "Win",
          lose: "Lose",
          botOVR: "Bot OVR",
          playMatch: "⚽ PLAY MATCH",
          changeArena: "🏟️ CHANGE ARENA",
          selectArena: "SELECT ARENA",
          unlocked: "UNLOCKED",
          current: "CURRENT",

          // Training points
          trainingPoints: "Training Points",
          upgradeStats: "UPGRADE STATS",
          selectStat: "Select stat",
          pointsToAdd: "Points to add",
          currentValue: "Current value",
          newValue: "New value",
          upgradeCost: "Cost",
          confirmUpgrade: "UPGRADE",
          notEnoughTP: "Not enough training points!",

          // Settings
          dangerZone: "⚠️ DANGER ZONE",
          resetProgress: "🗑️ RESET PROGRESS",

          // Penalty messages
          youScored: "⚽ GOOOL! You scored!",
          youMissed: "💨 MISS! You missed!",
          youSaved: "🧤 SAVE! You saved it!",
          opponentScored: "⚽ GOAL! Opponent scored!",
          opponentSaved: "🧤 SAVED! Goalkeeper saved!",
          opponentMissed: "💨 MISS! Opponent missed!",
        },
      };

      function t(key) {
        return translations[currentLang][key] || translations["en"][key] || key;
      }

      function setLanguage(lang) {
        currentLang = lang;
        localStorage.setItem("footballLang", lang);
        updateAllText();
        updateLanguageButtons();
      }

      function updateAllText() {
        // Update all elements with data-t attribute
        document.querySelectorAll("[data-t]").forEach((el) => {
          const key = el.dataset.t;
          if (translations[currentLang][key]) {
            el.textContent = t(key);
          }
        });
        document.querySelectorAll("[data-t-placeholder]").forEach((el) => {
          const key = el.dataset.tPlaceholder;
          if (translations[currentLang][key]) {
            el.placeholder = t(key);
          }
        });
      }

      // ==================== UI HELPERS ====================
      function showScreen(screenId) {
        document
          .querySelectorAll(".screen")
          .forEach((s) => s.classList.remove("active"));
        const screen = document.getElementById(screenId);
        if (screen) screen.classList.add("active");

        // Apply translations after showing screen
        updateAllText();

        if (screenId === "squadScreen") {
          if (typeof renderPitch === "function") renderPitch();
        } else if (screenId === "marketScreen") {
          if (
            typeof generateMarketCards === "function" &&
            typeof renderMarket === "function"
          ) {
            if (
              !GameState.market.lastRefresh ||
              Date.now() - GameState.market.lastRefresh >
                GameState.market.refreshInterval
            ) {
              generateMarketCards();
            } else {
              renderMarket();
            }
          }
        } else if (screenId === "upgradeScreen") {
          if (typeof renderUpgradePlayers === "function")
            renderUpgradePlayers();
          // Update TP display
          const tpEl = document.getElementById("upgradeTP");
          if (tpEl)
            tpEl.textContent = (GameState.trainingPoints || 0).toLocaleString();
        } else if (screenId === "playMenu") {
          updateArenaDisplay();
        } else if (screenId === "legendsScreen") {
          if (typeof renderLegends === "function") renderLegends();
        } else if (screenId === "settingsScreen") {
          if (typeof updateLanguageButtons === "function")
            updateLanguageButtons();
        } else if (screenId === "emailScreen") {
          if (typeof renderEmails === "function") renderEmails();
        }
      }

      // ==================== GAME STATE ====================
      const GameState = {
        manager: {
          name: "",
          balance: 10000,
          iconUnlocked: false,
        },
        squad: {
          formation: "4-3-3",
          players: [],
          bench: [],
        },
        market: {
          cards: [],
          lastRefresh: null,
          refreshInterval: 10 * 60 * 1000, // 10 minutes
        },
        match: {
          mode: null,
          difficulty: "medium",
          score: [0, 0],
          time: 0,
          ballPos: { x: 50, y: 50 },
          selectedPlayer: null,
        },
        stats: {
          matchesPlayed: 0,
          matchesWon: 0,
          matchesLost: 0,
          matchesDraw: 0,
          goalsScored: 0,
          goalsConceded: 0,
        },
        legends: [], // Retired legends collection
        emails: [], // Email inbox
        lastWeekCheck: null, // For weekly salary/contract check
        gameTime: {
          startDate: null, // When game started
          yearLength: 17.5 * 24 * 60 * 60 * 1000, // 2.5 weeks = 17.5 days in ms
          weekLength: 2.5 * 24 * 60 * 60 * 1000, // 2.5 days = 1 week in game
          lastAgeCheck: null,
        },
        arena: {
          current: 1, // Current arena (1-15)
          unlocked: [1], // Which arenas are unlocked
        },
        trainingPoints: 0, // Training points for upgrades
      };

      // ==================== ARENA SYSTEM ====================
      const ARENAS = [
        {
          id: 1,
          namePL: "Arena Początkującego",
          nameEN: "Beginner Arena",
          winReward: 5000,
          loseReward: 2500,
          unlockCost: 0,
          botOVR: [45, 55],
          tpReward: 5,
        },
        {
          id: 2,
          namePL: "Arena Amatora",
          nameEN: "Amateur Arena",
          winReward: 10000,
          loseReward: 5000,
          unlockCost: 15000,
          botOVR: [50, 60],
          tpReward: 10,
        },
        {
          id: 3,
          namePL: "Arena Młodzieżowa",
          nameEN: "Youth Arena",
          winReward: 25000,
          loseReward: 12500,
          unlockCost: 40000,
          botOVR: [55, 65],
          tpReward: 15,
        },
        {
          id: 4,
          namePL: "Arena Regionalna",
          nameEN: "Regional Arena",
          winReward: 50000,
          loseReward: 25000,
          unlockCost: 100000,
          botOVR: [60, 70],
          tpReward: 25,
        },
        {
          id: 5,
          namePL: "Arena Miejska",
          nameEN: "City Arena",
          winReward: 100000,
          loseReward: 50000,
          unlockCost: 250000,
          botOVR: [65, 75],
          tpReward: 40,
        },
        {
          id: 6,
          namePL: "Arena Krajowa",
          nameEN: "National Arena",
          winReward: 200000,
          loseReward: 100000,
          unlockCost: 500000,
          botOVR: [68, 78],
          tpReward: 60,
        },
        {
          id: 7,
          namePL: "Arena Profesjonalna",
          nameEN: "Professional Arena",
          winReward: 400000,
          loseReward: 200000,
          unlockCost: 1000000,
          botOVR: [72, 82],
          tpReward: 85,
        },
        {
          id: 8,
          namePL: "Arena Pierwszej Ligi",
          nameEN: "First League Arena",
          winReward: 750000,
          loseReward: 375000,
          unlockCost: 2000000,
          botOVR: [75, 85],
          tpReward: 120,
        },
        {
          id: 9,
          namePL: "Arena Ekstraklasy",
          nameEN: "Premier Arena",
          winReward: 1500000,
          loseReward: 750000,
          unlockCost: 4000000,
          botOVR: [78, 88],
          tpReward: 170,
        },
        {
          id: 10,
          namePL: "Arena Europejska",
          nameEN: "European Arena",
          winReward: 3000000,
          loseReward: 1500000,
          unlockCost: 8000000,
          botOVR: [80, 90],
          tpReward: 250,
        },
        {
          id: 11,
          namePL: "Arena Elity",
          nameEN: "Elite Arena",
          winReward: 5000000,
          loseReward: 2500000,
          unlockCost: 15000000,
          botOVR: [83, 93],
          tpReward: 350,
        },
        {
          id: 12,
          namePL: "Arena Mistrzów",
          nameEN: "Champions Arena",
          winReward: 10000000,
          loseReward: 5000000,
          unlockCost: 30000000,
          botOVR: [85, 95],
          tpReward: 500,
        },
        {
          id: 13,
          namePL: "Arena Legend",
          nameEN: "Legends Arena",
          winReward: 20000000,
          loseReward: 10000000,
          unlockCost: 60000000,
          botOVR: [88, 98],
          tpReward: 750,
        },
        {
          id: 14,
          namePL: "Arena Ikon",
          nameEN: "Icons Arena",
          winReward: 50000000,
          loseReward: 25000000,
          unlockCost: 150000000,
          botOVR: [90, 99],
          tpReward: 1000,
        },
        {
          id: 15,
          namePL: "Arena Bogów",
          nameEN: "Gods Arena",
          winReward: 100000000,
          loseReward: 50000000,
          unlockCost: 500000000,
          botOVR: [95, 99],
          tpReward: 2000,
        },
      ];

      function getArenaName(arena) {
        return currentLang === "pl" ? arena.namePL : arena.nameEN;
      }

      function getCurrentArena() {
        return (
          ARENAS.find((a) => a.id === GameState.arena.current) || ARENAS[0]
        );
      }

      function updateArenaDisplay() {
        const arena = getCurrentArena();
        const nameEl = document.getElementById("currentArenaName");
        const winEl = document.getElementById("arenaWinReward");
        const loseEl = document.getElementById("arenaLoseReward");
        const botEl = document.getElementById("arenaBotOVR");
        const tpEl = document.getElementById("arenaTpReward");
        const currentTpEl = document.getElementById("currentTP");

        if (nameEl) nameEl.textContent = getArenaName(arena);
        if (winEl) winEl.textContent = "+€" + arena.winReward.toLocaleString();
        if (loseEl)
          loseEl.textContent = "-€" + arena.loseReward.toLocaleString();
        if (botEl) botEl.textContent = `${arena.botOVR[0]}-${arena.botOVR[1]}`;
        if (tpEl) tpEl.textContent = "+" + arena.tpReward + " TP";
        if (currentTpEl)
          currentTpEl.textContent = (
            GameState.trainingPoints || 0
          ).toLocaleString();
      }

      function showArenaSelect() {
        const list = document.getElementById("arenaList");
        if (!list) return;

        const maxUnlocked = Math.max(...GameState.arena.unlocked);

        list.innerHTML = ARENAS.map((arena) => {
          const isUnlocked = GameState.arena.unlocked.includes(arena.id);
          const isCurrent = GameState.arena.current === arena.id;
          const canAfford = GameState.manager.balance >= arena.unlockCost;
          const isNextToUnlock = arena.id === maxUnlocked + 1;
          const arenaName = getArenaName(arena);

          let statusHTML = "";
          if (isCurrent) {
            statusHTML = `<span class="arena-unlocked">✓ ${t(
              "current"
            )}</span>`;
          } else if (isUnlocked) {
            statusHTML = `<span class="arena-unlocked">✓ ${t(
              "unlocked"
            )}</span>`;
          } else if (isNextToUnlock) {
            statusHTML = `<span class="arena-unlock-price ${
              canAfford ? "" : "locked"
            }">🔒 €${arena.unlockCost.toLocaleString()}</span>`;
          } else {
            statusHTML = `<span class="arena-unlock-price locked">🔒</span>`;
          }

          const canClick = isUnlocked || (isNextToUnlock && canAfford);

          return `
                    <div class="arena-item ${isCurrent ? "current" : ""} ${
            !isUnlocked ? "locked" : ""
          }" 
                         onclick="${
                           isUnlocked
                             ? `selectArena(${arena.id})`
                             : isNextToUnlock && canAfford
                             ? `unlockArena(${arena.id})`
                             : ""
                         }">
                        <div class="arena-item-info">
                            <div class="arena-item-name">${
                              arena.id
                            }. ${arenaName}</div>
                            <div class="arena-item-rewards">
                                🏆 +€${arena.winReward.toLocaleString()} | 💀 -€${arena.loseReward.toLocaleString()} | 🎯 +${
            arena.tpReward
          } TP
                            </div>
                            <div class="arena-item-bot">🤖 ${t("botOVR")}: ${
            arena.botOVR[0]
          }-${arena.botOVR[1]}</div>
                        </div>
                        <div class="arena-item-action">
                            ${statusHTML}
                        </div>
                    </div>
                `;
        }).join("");

        showScreen("arenaSelectScreen");
      }

      function selectArena(arenaId) {
        if (!GameState.arena.unlocked.includes(arenaId)) return;
        GameState.arena.current = arenaId;
        updateArenaDisplay();
        autoSave();
        showScreen("playMenu");
      }

      function unlockArena(arenaId) {
        const arena = ARENAS.find((a) => a.id === arenaId);
        if (!arena) return;

        // Check if previous arena is unlocked (must unlock in order)
        const maxUnlocked = Math.max(...GameState.arena.unlocked);
        if (arenaId !== maxUnlocked + 1) {
          alert(
            currentLang === "pl"
              ? "Musisz odblokować areny po kolei!"
              : "You must unlock arenas in order!"
          );
          return;
        }

        if (GameState.manager.balance < arena.unlockCost) {
          alert(
            currentLang === "pl"
              ? "Nie masz wystarczająco pieniędzy!"
              : "Not enough money!"
          );
          return;
        }

        const arenaName = getArenaName(arena);
        if (
          confirm(
            (currentLang === "pl" ? "Odblokować " : "Unlock ") +
              arenaName +
              (currentLang === "pl" ? " za €" : " for €") +
              arena.unlockCost.toLocaleString() +
              "?"
          )
        ) {
          GameState.manager.balance -= arena.unlockCost;
          GameState.arena.unlocked.push(arenaId);
          GameState.arena.current = arenaId;
          updateAccountDisplay();
          updateArenaDisplay();
          autoSave();
          showArenaSelect(); // Refresh list
        }
      }

      function playArenaMatch() {
        // Check if squad has 11 players
        const squadCount = GameState.squad.players.filter((p) => p).length;
        if (squadCount < 11) {
          alert(
            currentLang === "pl"
              ? `Nie możesz zagrać meczu! Masz tylko ${squadCount}/11 zawodników w składzie.`
              : `Cannot play match! You only have ${squadCount}/11 players in squad.`
          );
          return;
        }

        const arena = getCurrentArena();
        // Generate bot OVR based on arena
        const botOVR =
          arena.botOVR[0] +
          Math.floor(Math.random() * (arena.botOVR[1] - arena.botOVR[0] + 1));
        startPenaltiesWithArena(botOVR, arena);
      }

      function startPenaltiesWithArena(botOVR, arena) {
        GameState.match.difficulty = "arena";
        GameState.match.currentArena = arena;
        GameState.match.botOVR = botOVR;

        // Reset penalty state
        penaltyState = {
          round: 1,
          maxRounds: 5,
          playerScore: 0,
          opponentScore: 0,
          playerShots: [],
          opponentShots: [],
          phase: "player_shoot",
          shooters: getPlayerShooters(),
          opponentShooters: getOpponentShooters(botOVR),
          currentShooterIndex: 0,
          selectedDirection: null,
          opponentOVR: botOVR,
          lastShooter: null,
          currentShooter: null,
        };

        isOnlinePenalty = false;

        // Setup dots display
        const playerDots = document.getElementById("playerDots");
        const opponentDots = document.getElementById("opponentDots");
        if (playerDots)
          playerDots.innerHTML = '<span class="dot"></span>'.repeat(5);
        if (opponentDots)
          opponentDots.innerHTML = '<span class="dot"></span>'.repeat(5);

        // Set player names
        const myName = GameState.manager.name || t("you");
        document.getElementById("penaltyPlayerLabel").textContent = myName;
        document.getElementById(
          "penaltyOpponentLabel"
        ).textContent = `Bot (${botOVR} OVR)`;

        showScreen("penaltyScreen");
        setupPenaltyPhase();
      }

      // ==================== TIME SYSTEM ====================
      function initGameTime() {
        if (!GameState.gameTime.startDate) {
          GameState.gameTime.startDate = Date.now();
          GameState.gameTime.lastAgeCheck = Date.now();
        }
      }

      function getCurrentGameYear() {
        if (!GameState.gameTime.startDate) return 0;
        const elapsed = Date.now() - GameState.gameTime.startDate;
        return Math.floor(elapsed / GameState.gameTime.yearLength);
      }

      function checkYearPassed() {
        if (!GameState.gameTime.lastAgeCheck) {
          GameState.gameTime.lastAgeCheck = Date.now();
          return false;
        }

        const elapsed = Date.now() - GameState.gameTime.lastAgeCheck;
        if (elapsed >= GameState.gameTime.yearLength) {
          GameState.gameTime.lastAgeCheck = Date.now();
          return true;
        }
        return false;
      }

      // Check for aging every minute
      setInterval(() => {
        if (checkYearPassed()) {
          processSeasonEnd();
        }
      }, 60000);

      // Check for weekly events every 30 seconds
      setInterval(() => {
        checkWeeklyEvents();
      }, 30000);

      // ==================== EMAIL & CONTRACT SYSTEM ====================

      function checkWeeklyEvents() {
        if (!GameState.lastWeekCheck) {
          GameState.lastWeekCheck = Date.now();
          return;
        }

        const elapsed = Date.now() - GameState.lastWeekCheck;
        const weekLength =
          GameState.gameTime.weekLength || 2.5 * 24 * 60 * 60 * 1000;

        if (elapsed >= weekLength) {
          GameState.lastWeekCheck = Date.now();
          processWeeklyEvents();
        }
      }

      function processWeeklyEvents() {
        // Pay salaries
        let totalSalary = 0;
        const allPlayers = [
          ...(GameState.squad.players || []),
          ...(GameState.squad.bench || []),
        ].filter((p) => p);

        allPlayers.forEach((player) => {
          if (player.salary) {
            totalSalary += player.salary;
          }

          // Decrease contract years (52 weeks per year, so 1/52 per week)
          if (player.contractYears) {
            player.contractYears -= 1 / 52;

            // Check for expiring contracts
            if (player.contractYears <= 0.1 && player.contractYears > 0) {
              // 3 days warning
              sendContractExpiringEmail(player);
            } else if (player.contractYears <= 0) {
              // Contract expired
              removePlayerFromClub(player, "expired");
            }
          }
        });

        // Deduct salary
        if (totalSalary > 0) {
          if (GameState.manager.balance >= totalSalary) {
            GameState.manager.balance -= totalSalary;
            updateAccountDisplay();
            autoSave();
          } else {
            // Not enough money - players may leave
            sendNoFundsEmail(totalSalary);
          }
        }

        // Random raise request (10% chance per week)
        if (Math.random() < 0.1 && allPlayers.length > 0) {
          const randomPlayer =
            allPlayers[Math.floor(Math.random() * allPlayers.length)];
          if (randomPlayer && randomPlayer.salary) {
            sendRaiseRequestEmail(randomPlayer);
          }
        }
      }

      function sendContractExpiringEmail(player) {
        // Check if email already sent
        const existing = GameState.emails.find(
          (e) =>
            e.type === "contract_expiring" &&
            e.playerId === player.id &&
            !e.resolved
        );
        if (existing) return;

        const email = {
          id: Date.now() + Math.random(),
          type: "contract_expiring",
          playerId: player.id,
          playerName: player.name,
          player: player,
          subject: t("contractExpiring"),
          urgent: true,
          unread: true,
          resolved: false,
          timestamp: Date.now(),
          requestedSalary: Math.floor(
            player.salary * (1 + Math.random() * 0.3)
          ), // 0-30% raise
          requestedYears: Math.floor(Math.random() * 3) + 1,
        };

        GameState.emails.unshift(email);
        updateEmailBadge();
        autoSave();
      }

      function sendRaiseRequestEmail(player) {
        // Check if email already sent recently
        const existing = GameState.emails.find(
          (e) =>
            e.type === "raise_request" &&
            e.playerId === player.id &&
            !e.resolved
        );
        if (existing) return;

        const raisePercent = 10 + Math.floor(Math.random() * 30); // 10-40% raise

        const email = {
          id: Date.now() + Math.random(),
          type: "raise_request",
          playerId: player.id,
          playerName: player.name,
          player: player,
          subject: t("raiseRequest"),
          urgent: false,
          unread: true,
          resolved: false,
          timestamp: Date.now(),
          requestedSalary: Math.floor(player.salary * (1 + raisePercent / 100)),
          raisePercent: raisePercent,
        };

        GameState.emails.unshift(email);
        updateEmailBadge();
        autoSave();
      }

      function sendNoFundsEmail(amount) {
        const email = {
          id: Date.now() + Math.random(),
          type: "no_funds",
          subject: t("noFundsForSalary"),
          urgent: true,
          unread: true,
          resolved: false,
          timestamp: Date.now(),
          amount: amount,
        };

        GameState.emails.unshift(email);
        updateEmailBadge();
        autoSave();
      }

      function removePlayerFromClub(player, reason) {
        // Remove from squad
        GameState.squad.players = GameState.squad.players.map((p) =>
          p && p.id === player.id ? null : p
        );
        GameState.squad.bench = GameState.squad.bench.filter(
          (p) => p && p.id !== player.id
        );

        // Send notification email
        const email = {
          id: Date.now() + Math.random(),
          type: "player_left",
          playerId: player.id,
          playerName: player.name,
          player: player,
          subject: `${player.name} ${t("playerLeft")}`,
          urgent: false,
          unread: true,
          resolved: true,
          timestamp: Date.now(),
          reason: reason,
        };

        GameState.emails.unshift(email);
        updateEmailBadge();
        autoSave();
      }

      function updateEmailBadge() {
        const unreadCount = GameState.emails.filter((e) => e.unread).length;
        const badge = document.getElementById("emailBadge");

        if (unreadCount > 0) {
          badge.textContent = unreadCount > 9 ? "9+" : unreadCount;
          badge.style.display = "flex";
        } else {
          badge.style.display = "none";
        }
      }

      function renderEmails() {
        const list = document.getElementById("emailList");
        const noEmails = document.getElementById("noEmails");

        if (!GameState.emails || GameState.emails.length === 0) {
          list.innerHTML = "";
          noEmails.style.display = "block";
          return;
        }

        noEmails.style.display = "none";

        list.innerHTML = GameState.emails
          .map((email) => {
            const icon =
              email.type === "contract_expiring"
                ? "📝"
                : email.type === "raise_request"
                ? "💰"
                : email.type === "player_left"
                ? "🚪"
                : email.type === "no_funds"
                ? "⚠️"
                : "📧";

            const timeAgo = getTimeAgo(email.timestamp);
            const urgentClass = email.urgent ? "urgent" : "";
            const unreadClass = email.unread ? "unread" : "";

            return `
                    <div class="email-item ${urgentClass} ${unreadClass}" onclick="openEmail('${
              email.id
            }')">
                        <div class="email-icon">${icon}</div>
                        <div class="email-content">
                            <div class="email-subject">${email.subject}</div>
                            <div class="email-preview">${
                              email.playerName || t("fromAgent")
                            }</div>
                        </div>
                        <div class="email-time">${timeAgo}</div>
                    </div>
                `;
          })
          .join("");
      }

      function getTimeAgo(timestamp) {
        const diff = Date.now() - timestamp;
        const minutes = Math.floor(diff / 60000);
        const hours = Math.floor(diff / 3600000);
        const days = Math.floor(diff / 86400000);

        if (days > 0)
          return currentLang === "pl" ? `${days}d temu` : `${days}d ago`;
        if (hours > 0)
          return currentLang === "pl" ? `${hours}h temu` : `${hours}h ago`;
        if (minutes > 0)
          return currentLang === "pl" ? `${minutes}m temu` : `${minutes}m ago`;
        return currentLang === "pl" ? "teraz" : "now";
      }

      let currentEmailId = null;

      function openEmail(emailId) {
        const email = GameState.emails.find((e) => e.id == emailId);
        if (!email) return;

        currentEmailId = emailId;
        email.unread = false;
        updateEmailBadge();

        const modal = document.getElementById("emailModal");
        const subject = document.getElementById("emailSubject");
        const from = document.getElementById("emailFrom");
        const body = document.getElementById("emailBody");
        const playerCard = document.getElementById("emailPlayerCard");
        const actions = document.getElementById("emailActions");

        subject.textContent = email.subject;
        from.textContent = email.playerName
          ? `${t("fromAgent")} - ${email.playerName}`
          : t("fromAgent");

        // Generate body based on email type
        let bodyText = "";

        if (email.type === "contract_expiring") {
          bodyText = getContractExpiringMessage(email);
        } else if (email.type === "raise_request") {
          bodyText = getRaiseRequestMessage(email);
        } else if (email.type === "player_left") {
          bodyText = getPlayerLeftMessage(email);
        } else if (email.type === "no_funds") {
          bodyText = getNoFundsMessage(email);
        }

        body.textContent = bodyText;

        // Show player card if available
        if (email.player) {
          playerCard.innerHTML = renderPlayerCard(email.player, true);
          playerCard.style.display = "flex";
        } else {
          playerCard.style.display = "none";
        }

        // Generate action buttons
        if (email.resolved) {
          actions.innerHTML = `
                    <button class="email-action-btn close" onclick="closeEmail()">${t(
                      "closeEmail"
                    )}</button>
                    <button class="email-action-btn reject" onclick="deleteEmail('${
                      email.id
                    }')">🗑️</button>
                `;
        } else if (email.type === "contract_expiring") {
          actions.innerHTML = `
                    <button class="email-action-btn accept" onclick="acceptContractRenewal('${
                      email.id
                    }')">${t("accept")}</button>
                    <button class="email-action-btn negotiate" onclick="negotiateContract('${
                      email.id
                    }')">${t("negotiate")}</button>
                    <button class="email-action-btn reject" onclick="rejectContract('${
                      email.id
                    }')">${t("reject")}</button>
                `;
        } else if (email.type === "raise_request") {
          actions.innerHTML = `
                    <button class="email-action-btn accept" onclick="acceptRaise('${
                      email.id
                    }')">${t("accept")}</button>
                    <button class="email-action-btn reject" onclick="rejectRaise('${
                      email.id
                    }')">${t("reject")}</button>
                `;
        } else if (email.type === "offer_rejected") {
          actions.innerHTML = `
                    <button class="email-action-btn negotiate" onclick="negotiateRejectedOffer('${
                      email.id
                    }')">${t("startNegotiation")}</button>
                    <button class="email-action-btn close" onclick="acceptRejection('${
                      email.id
                    }')">${t("acceptDecision")}</button>
                `;
        } else {
          actions.innerHTML = `
                    <button class="email-action-btn close" onclick="closeEmail()">${t(
                      "closeEmail"
                    )}</button>
                `;
        }

        modal.style.display = "flex";
        autoSave();
      }

      function getContractExpiringMessage(email) {
        if (currentLang === "pl") {
          return `Dzień dobry,

Kontrakt mojego klienta ${email.playerName} niedługo wygasa. 

Obecna pensja: €${email.player?.salary?.toLocaleString() || 0}/tyg
Żądana pensja: €${email.requestedSalary?.toLocaleString() || 0}/tyg
Proponowany kontrakt: ${email.requestedYears} lat

Proszę o odpowiedź w ciągu 3 dni, w przeciwnym razie zawodnik odejdzie z klubu.

Z poważaniem,
Agent`;
        } else {
          return `Hello,

My client ${email.playerName}'s contract is expiring soon.

Current salary: €${email.player?.salary?.toLocaleString() || 0}/week
Requested salary: €${email.requestedSalary?.toLocaleString() || 0}/week
Proposed contract: ${email.requestedYears} years

Please respond within 3 days, otherwise the player will leave the club.

Best regards,
Agent`;
        }
      }

      function getRaiseRequestMessage(email) {
        if (currentLang === "pl") {
          return `Dzień dobry,

Mój klient ${email.playerName} prosi o podwyżkę.

Obecna pensja: €${email.player?.salary?.toLocaleString() || 0}/tyg
Żądana pensja: €${email.requestedSalary?.toLocaleString() || 0}/tyg (+${
            email.raisePercent
          }%)

Zawodnik uważa, że jego wkład w drużynę zasługuje na wyższą pensję.

Z poważaniem,
Agent`;
        } else {
          return `Hello,

My client ${email.playerName} requests a raise.

Current salary: €${email.player?.salary?.toLocaleString() || 0}/week
Requested salary: €${email.requestedSalary?.toLocaleString() || 0}/week (+${
            email.raisePercent
          }%)

The player believes his contribution deserves higher compensation.

Best regards,
Agent`;
        }
      }

      function getPlayerLeftMessage(email) {
        if (currentLang === "pl") {
          return `${email.playerName} opuścił klub z powodu: ${
            email.reason === "expired" ? "wygaśnięcie kontraktu" : email.reason
          }.`;
        } else {
          return `${email.playerName} left the club due to: ${
            email.reason === "expired" ? "contract expiration" : email.reason
          }.`;
        }
      }

      function getNoFundsMessage(email) {
        if (currentLang === "pl") {
          return `Uwaga! Nie masz wystarczających środków na wypłatę pensji (€${email.amount?.toLocaleString()}).

Zawodnicy mogą być niezadowoleni i zacząć żądać transferów.`;
        } else {
          return `Warning! You don't have enough funds to pay salaries (€${email.amount?.toLocaleString()}).

Players may become unhappy and start requesting transfers.`;
        }
      }

      function closeEmail() {
        document.getElementById("emailModal").style.display = "none";
        currentEmailId = null;
        renderEmails();
      }

      function deleteEmail(emailId) {
        GameState.emails = GameState.emails.filter((e) => e.id != emailId);
        closeEmail();
        autoSave();
      }

      function acceptContractRenewal(emailId) {
        const email = GameState.emails.find((e) => e.id == emailId);
        if (!email) return;

        // Find player and update contract
        const player = findPlayerById(email.playerId);
        if (player) {
          player.salary = email.requestedSalary;
          player.contractYears = email.requestedYears;
        }

        email.resolved = true;
        alert(`✅ ${t("contractRenewed")}`);
        closeEmail();
        autoSave();
      }

      function negotiateContract(emailId) {
        const email = GameState.emails.find((e) => e.id == emailId);
        if (!email || !email.player) return;

        // Open negotiation with this player
        closeEmail();
        showScreen("mainMenu");

        // Start contract negotiation (reuse market negotiation system)
        currentNegotiationPlayer = email.player;
        negotiationPhase = "contract";
        negotiationRound = 0;
        negotiationTension = 20;
        agreedPrice = 0; // No transfer fee for renewal
        swapPlayer = null;

        const modal = document.getElementById("negotiationModal");
        document.getElementById("negotiationChat").innerHTML = "";
        document.getElementById("negotiationPhase1").style.display = "none";
        document.getElementById("negotiationPhase2").style.display = "block";

        // Set default values
        document.getElementById("offerSalary").value =
          email.player.salary || 1000;
        document.getElementById("offerLength").value = 2;
        document.getElementById("offerBonus").value = "";
        document.getElementById("offerClause").value = "";

        updateTensionBar();
        addChatMessage(
          "agent",
          getRandomMessage(getAgentMessages().greetingsPrice, {
            player: email.player.name,
            price: email.requestedSalary?.toLocaleString() || "0",
          })
        );

        modal.style.display = "flex";

        // Mark email as resolved
        email.resolved = true;
        autoSave();
      }

      function rejectContract(emailId) {
        const email = GameState.emails.find((e) => e.id == emailId);
        if (!email) return;

        email.resolved = true;
        // Player will leave when contract expires
        closeEmail();
        autoSave();
      }

      function acceptRaise(emailId) {
        const email = GameState.emails.find((e) => e.id == emailId);
        if (!email) return;

        const player = findPlayerById(email.playerId);
        if (player) {
          player.salary = email.requestedSalary;
        }

        email.resolved = true;
        alert(`✅ ${t("raiseAccepted")}`);
        closeEmail();
        autoSave();
      }

      function rejectRaise(emailId) {
        const email = GameState.emails.find((e) => e.id == emailId);
        if (!email) return;

        email.resolved = true;
        // Player becomes unhappy (could add mood system later)
        alert(`❌ ${t("raiseRejected")} ${t("playerUnhappy")}`);
        closeEmail();
        autoSave();
      }

      function negotiateRejectedOffer(emailId) {
        const email = GameState.emails.find((e) => e.id == emailId);
        if (!email || !email.player) return;

        // Mark as resolved
        email.resolved = true;
        closeEmail();

        // Open compose email with this player pre-selected
        setTimeout(() => {
          openComposeEmail();

          // Pre-select the player
          const select = document.getElementById("composePlayerSelect");
          select.value = email.playerId;
          updateComposePreview();

          // Pre-select the same type
          if (email.originalOffer?.originalType === "reduce_salary") {
            selectComposeType("reduce_salary");
          } else if (email.originalOffer?.originalType === "extend_contract") {
            selectComposeType("extend_contract");
          }
        }, 100);

        autoSave();
      }

      function acceptRejection(emailId) {
        const email = GameState.emails.find((e) => e.id == emailId);
        if (!email) return;

        email.resolved = true;
        closeEmail();
        autoSave();
      }

      function findPlayerById(playerId) {
        const idStr = String(playerId);
        const inSquad = GameState.squad.players.find(
          (p) => p && String(p.id) === idStr
        );
        if (inSquad) return inSquad;

        const onBench = GameState.squad.bench.find(
          (p) => p && String(p.id) === idStr
        );
        return onBench;
      }

      // ==================== COMPOSE EMAIL SYSTEM ====================

      let composeState = {
        selectedPlayer: null,
        messageType: null,
        pendingMessages: [], // Messages awaiting response
      };

      function openComposeEmail() {
        const modal = document.getElementById("composeEmailModal");
        const select = document.getElementById("composePlayerSelect");

        // Reset state
        composeState.selectedPlayer = null;
        composeState.messageType = null;

        // Populate player list
        const allPlayers = [
          ...(GameState.squad.players || []),
          ...(GameState.squad.bench || []),
        ].filter((p) => p);

        select.innerHTML =
          `<option value="">${t("selectPlayerForAction")}</option>` +
          allPlayers
            .map(
              (p) =>
                `<option value="${p.id}">${p.name} (${p.position}, OVR ${p.overall})</option>`
            )
            .join("");

        // Reset UI
        document.getElementById("composePlayerPreview").style.display = "none";
        document
          .querySelectorAll(".compose-option")
          .forEach((o) => o.classList.remove("selected"));
        document.getElementById("composeSendBtn").disabled = true;

        modal.style.display = "flex";
      }

      function closeComposeEmail() {
        document.getElementById("composeEmailModal").style.display = "none";
        composeState.messageType = null;
        document
          .querySelectorAll(".compose-option")
          .forEach((o) => o.classList.remove("selected"));
      }

      function updateComposePreview() {
        const select = document.getElementById("composePlayerSelect");
        const preview = document.getElementById("composePlayerPreview");
        const playerId = select.value;

        if (!playerId) {
          preview.style.display = "none";
          composeState.selectedPlayer = null;
          updateComposeSendButton();
          return;
        }

        const player = findPlayerById(parseFloat(playerId));
        if (!player) {
          preview.style.display = "none";
          composeState.selectedPlayer = null;
          updateComposeSendButton();
          return;
        }

        composeState.selectedPlayer = player;

        // Show player card and info
        const yearsLeft = player.contractYears
          ? player.contractYears.toFixed(1)
          : "?";
        preview.innerHTML = `
                <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; justify-content: center;">
                    ${renderPlayerCard(player, true)}
                    <div class="contract-info" style="min-width: 200px;">
                        <div class="contract-row">
                            <span class="contract-label">${t(
                              "currentSalaryIs"
                            )}</span>
                            <span class="contract-value">€${
                              player.salary?.toLocaleString() || 0
                            }/${currentLang === "pl" ? "tyg" : "wk"}</span>
                        </div>
                        <div class="contract-row">
                            <span class="contract-label">${t(
                              "contractEndsIn"
                            )}</span>
                            <span class="contract-value ${
                              yearsLeft < 0.5 ? "urgent" : ""
                            }">${yearsLeft} ${t("years")}</span>
                        </div>
                    </div>
                </div>
            `;
        preview.style.display = "flex";

        updateComposeSendButton();
      }

      function selectComposeType(type) {
        composeState.messageType = type;

        // Update UI
        document
          .querySelectorAll(".compose-option")
          .forEach((o) => o.classList.remove("selected"));

        if (type === "reduce_salary") {
          document.getElementById("optReduceSalary").classList.add("selected");
        } else if (type === "extend_contract") {
          document
            .getElementById("optExtendContract")
            .classList.add("selected");
        } else if (type === "raise_salary") {
          document.getElementById("optRaiseSalary").classList.add("selected");
        }

        updateComposeSendButton();
      }

      function updateComposeSendButton() {
        const canSend = composeState.selectedPlayer && composeState.messageType;
        document.getElementById("composeSendBtn").disabled = !canSend;
      }

      // ==================== NEGOTIATION CHAT SYSTEM ====================

      let chatState = {
        player: null,
        type: null, // 'reduce_salary', 'extend_contract', 'raise_salary'
        phase: "greeting", // greeting, reasons, offer, response, done
        messages: [],
        selectedReasons: [],
        offerSalary: 0,
        offerYears: 2,
        attempts: 0,
        maxAttempts: 3,
      };

      function startNegotiationChat() {
        if (!composeState.selectedPlayer || !composeState.messageType) return;

        chatState = {
          player: composeState.selectedPlayer,
          type: composeState.messageType,
          phase: "greeting",
          messages: [],
          selectedReasons: [],
          offerSalary: composeState.selectedPlayer.salary,
          offerYears: 2,
          attempts: 0,
          maxAttempts: 3,
        };

        closeComposeEmail();

        // Setup chat modal
        document.getElementById("chatPlayerName").textContent =
          chatState.player.name;
        document.getElementById("chatPlayerAvatar").textContent =
          getPositionEmoji(chatState.player.position);
        document.getElementById("chatMessages").innerHTML = "";
        document.getElementById("chatReasonsPanel").style.display = "none";
        document.getElementById("chatInputPanel").style.display = "none";
        document.getElementById("chatSendBtn").style.display = "none";
        document.getElementById("chatEndBtn").style.display = "none";

        document.getElementById("negotiationChatModal").style.display = "flex";

        // Start conversation immediately
        startChatConversation();
      }

      function getPositionEmoji(pos) {
        const emojis = {
          GK: "🧤",
          CB: "🛡️",
          LB: "⬅️",
          RB: "➡️",
          CDM: "⚙️",
          CM: "🎯",
          CAM: "🎨",
          LW: "💨",
          RW: "💨",
          ST: "⚽",
        };
        return emojis[pos] || "👤";
      }

      function startChatConversation() {
        // Manager greeting
        addPlayerChatMessage(t("chatGreeting"), "manager");
        addPlayerChatMessage(t("chatGreetingPlayer"), "player");

        // Type-specific intro
        let intro = "";
        let playerResponse = "";

        if (chatState.type === "reduce_salary") {
          intro = t("chatReduceIntro");
          playerResponse = t("chatReducePlayerAsk");
        } else if (chatState.type === "extend_contract") {
          intro = t("chatExtendIntro");
          playerResponse = t("chatExtendPlayerAsk");
        } else if (chatState.type === "raise_salary") {
          intro = t("chatRaiseIntro");
          playerResponse = t("chatRaisePlayerAsk");
        }

        addPlayerChatMessage(intro, "manager");
        addPlayerChatMessage(playerResponse, "player");

        chatState.phase = "reasons";
        showReasonsPanel();
      }

      function addPlayerChatMessage(text, sender) {
        const container = document.getElementById("chatMessages");
        if (!container) {
          console.error("chatMessages container not found");
          return;
        }
        const msg = document.createElement("div");
        msg.className = `chat-message ${sender}`;
        msg.textContent = text;
        container.appendChild(msg);
        container.scrollTop = container.scrollHeight;
        chatState.messages.push({ text, sender });
      }

      function showTypingIndicator() {
        const container = document.getElementById("chatMessages");
        const typing = document.createElement("div");
        typing.className = "chat-message player";
        typing.id = "typingIndicator";
        typing.innerHTML =
          '<div class="chat-typing"><span></span><span></span><span></span></div>';
        container.appendChild(typing);
        container.scrollTop = container.scrollHeight;
      }

      function removeTypingIndicator() {
        const typing = document.getElementById("typingIndicator");
        if (typing) typing.remove();
      }

      function showReasonsPanel() {
        const panel = document.getElementById("chatReasonsPanel");
        const list = document.getElementById("chatReasonsList");
        const player = chatState.player;

        // Get reasons based on type
        let reasonPrefix = "";
        let validReasons = [];

        if (chatState.type === "reduce_salary") {
          reasonPrefix = "reduceReason";
          validReasons = getValidReduceReasons(player);
        } else if (chatState.type === "extend_contract") {
          reasonPrefix = "extendReason";
          validReasons = getValidExtendReasons(player);
        } else if (chatState.type === "raise_salary") {
          reasonPrefix = "raiseReason";
          validReasons = getValidRaiseReasons(player);
        }

        list.innerHTML = "";
        validReasons.forEach((i) => {
          const reason = t(reasonPrefix + i);
          const item = document.createElement("label");
          item.className = "chat-reason-item";
          item.innerHTML = `<input type="checkbox" value="${i}" onchange="updateChatReasons()"> <span>${reason}</span>`;
          list.appendChild(item);
        });

        panel.style.display = "block";
        document.getElementById("chatSendBtn").style.display = "block";
        document.getElementById("chatSendBtn").disabled = true;

        // Show input panel
        showOfferInputs();
      }

      // Valid reasons for salary reduction
      function getValidReduceReasons(player) {
        const validReasons = [];
        const avgRating = getAverageRating(player);
        const isInSquad = GameState.squad.players.some(
          (p) => p && p.id === player.id
        );
        const totalSalary = [
          ...GameState.squad.players,
          ...GameState.squad.bench,
        ]
          .filter((p) => p && p.salary)
          .reduce((sum, p) => sum + p.salary, 0);
        const samePos = [
          ...GameState.squad.players,
          ...GameState.squad.bench,
        ].filter((p) => p && p.position === player.position).length;
        const playerStats = player.matchStats || {};
        const goals = playerStats.goals || 0;
        const assists = playerStats.assists || 0;
        const allPlayers = [
          ...GameState.squad.players,
          ...GameState.squad.bench,
        ].filter((p) => p);
        const avgTeamSalary =
          allPlayers.length > 0
            ? allPlayers.reduce((sum, p) => sum + (p.salary || 0), 0) /
              allPlayers.length
            : 0;

        // Każdy powód ma konkretny warunek
        // 1: Wyniki ostatnich meczów były słabe
        if (!avgRating || avgRating < 6.5) validReasons.push(1);
        // 2: Klub ma problemy finansowe
        if (GameState.manager.balance < 50000) validReasons.push(2);
        // 3: Pensja nie odpowiada poziomowi gry
        if (player.salary > player.overall * 15) validReasons.push(3);
        // 4: Młodsi zawodnicy czekają na szansę
        if (player.age > 28 && samePos > 1) validReasons.push(4);
        // 5: Restrukturyzacja płac w klubie
        if (totalSalary > GameState.manager.balance * 0.3) validReasons.push(5);
        // 6: Kontuzje ograniczyły twoją grę
        if (player.injuredUntil || player.wasInjured) validReasons.push(6);
        // 7: Inni gracze zarabiają mniej za podobną grę
        if (player.salary > avgTeamSalary * 1.3) validReasons.push(7);
        // 8: Potrzebujemy środków na transfery
        if (GameState.manager.balance < 80000) validReasons.push(8);
        // 9: Twoja wartość rynkowa spadła
        if (player.age > 30 || (avgRating && avgRating < 6.0))
          validReasons.push(9);
        // 10: Nowa strategia płacowa klubu
        if (totalSalary > GameState.manager.balance * 0.4)
          validReasons.push(10);
        // 11: Mniej minut na boisku w tym sezonie
        if (!isInSquad) validReasons.push(11);
        // 12: Liga stała się bardziej konkurencyjna
        if (player.overall < 75) validReasons.push(12);
        // 13: Sponsorzy zmniejszyli budżet
        if (GameState.manager.balance < 40000) validReasons.push(13);
        // 14: Musisz udowodnić swoją wartość
        if (!avgRating || avgRating < 6.8) validReasons.push(14);
        // 15: Wiek wpływa na twoje możliwości
        if (player.age > 32) validReasons.push(15);
        // 16: Brak postępu w rozwoju umiejętności
        if (player.age > 26 && player.overall < 75) validReasons.push(16);
        // 17: Konkurencja na twojej pozycji wzrosła
        if (samePos > 2) validReasons.push(17);
        // 18: Oczekiwania kibiców są wysokie
        if (avgRating && avgRating < 7.0 && player.overall >= 75)
          validReasons.push(18);
        // 19: Musimy zbalansować budżet
        if (GameState.manager.balance < 60000) validReasons.push(19);
        // 20: To sprawiedliwa oferta rynkowa
        if (player.salary > player.overall * 12) validReasons.push(20);
        // 21: Twoja dyspozycja fizyczna spadła
        if (player.stats && player.stats.Physical && player.stats.Physical < 65)
          validReasons.push(21);
        // 22: Brak bramek i asyst w ostatnim czasie
        if (
          goals === 0 &&
          assists === 0 &&
          ["ST", "CF", "LW", "RW", "CAM"].includes(player.position)
        )
          validReasons.push(22);
        // 23: Trener ma inne plany taktyczne
        if (!isInSquad && samePos > 1) validReasons.push(23);
        // 24: Zespół gra lepiej bez ciebie na boisku
        if (!isInSquad && avgRating && avgRating < 6.5) validReasons.push(24);
        // 25: Zarząd wymaga cięć kosztów
        if (GameState.manager.balance < 30000) validReasons.push(25);
        // 26: Twoje zachowanie na boisku było krytykowane
        if (player.yellowCards && player.yellowCards > 3) validReasons.push(26);
        // 27: Oczekiwania transferowe się nie spełniły
        if (player.overall < 70 && player.salary > 800) validReasons.push(27);
        // 28: Musisz odbudować formę
        if (avgRating && avgRating < 6.0) validReasons.push(28);
        // 29: Rynek piłkarski się zmienił
        if (player.age > 29 && player.salary > 1000) validReasons.push(29);
        // 30: Twoja pensja jest najwyższa w zespole
        if (player.salary >= Math.max(...allPlayers.map((p) => p.salary || 0)))
          validReasons.push(30);
        // 31: Brak zaangażowania na treningach
        if (!avgRating && !isInSquad) validReasons.push(31);
        // 32: Inne priorytety finansowe klubu
        if (GameState.manager.balance < 70000) validReasons.push(32);
        // 33: Twoja pozycja w hierarchii spadła
        if (!isInSquad && player.overall < 75) validReasons.push(33);
        // 34: Musimy inwestować w młodzież
        if (player.age > 28) validReasons.push(34);
        // 35: Poprzedni kontrakt był zbyt hojny
        if (player.salary > player.overall * 18) validReasons.push(35);
        // 36: Wyniki drużyny są rozczarowujące
        if (avgRating && avgRating < 6.5) validReasons.push(36);
        // 37: Twoja skuteczność spadła
        if (
          player.stats &&
          player.stats.Shooting &&
          player.stats.Shooting < 60 &&
          ["ST", "CF"].includes(player.position)
        )
          validReasons.push(37);
        // 38: Brak liderskich zachowań
        if (player.age >= 28 && !isInSquad) validReasons.push(38);
        // 39: Regulamin finansowy ligi wymaga zmian
        if (totalSalary > GameState.manager.balance * 0.5)
          validReasons.push(39);
        // 40: Twoje żółte kartki kosztują zespół
        if (player.yellowCards && player.yellowCards > 2) validReasons.push(40);
        // 41: Mniej meczów w tym sezonie
        if (!avgRating) validReasons.push(41);
        // 42: Inni zawodnicy awansowali ponad ciebie
        if (samePos > 2 && !isInSquad) validReasons.push(42);
        // 43: Potrzebujemy elastyczności budżetowej
        if (GameState.manager.balance < 55000) validReasons.push(43);
        // 44: Twój wpływ na wyniki jest mniejszy
        if (!isInSquad && player.overall < 72) validReasons.push(44);
        // 45: Kryzys ekonomiczny dotknął klub
        if (GameState.manager.balance < 35000) validReasons.push(45);
        // 46: Twoje statystyki nie imponują
        if (avgRating && avgRating < 6.7) validReasons.push(46);
        // 47: Czas na nowy rozdział w karierze
        if (player.age > 31) validReasons.push(47);
        // 48: Twoja motywacja wydaje się niższa
        if (avgRating && avgRating < 6.2 && !isInSquad) validReasons.push(48);
        // 49: Potrzebujemy funduszy na infrastrukturę
        if (GameState.manager.balance < 65000) validReasons.push(49);
        // 50: To ostateczna oferta klubu
        if (
          player.salary > player.overall * 14 &&
          GameState.manager.balance < 80000
        )
          validReasons.push(50);

        return validReasons;
      }

      function getValidExtendReasons(player) {
        const validReasons = [];
        const avgRating = getAverageRating(player);
        const isInSquad = GameState.squad.players.some(
          (p) => p && p.id === player.id
        );
        const playerStats = player.matchStats || {};
        const goals = playerStats.goals || 0;
        const assists = playerStats.assists || 0;
        const samePos = [
          ...GameState.squad.players,
          ...GameState.squad.bench,
        ].filter((p) => p && p.position === player.position).length;

        // Każdy powód ma konkretny warunek
        // 1: Jesteś kluczowym zawodnikiem drużyny
        if (isInSquad && player.overall >= 70) validReasons.push(1);
        // 2: Widzimy twoją przyszłość w klubie
        if (player.age < 30) validReasons.push(2);
        // 3: Twoje występy były świetne
        if (avgRating && avgRating >= 7.0) validReasons.push(3);
        // 4: Kibice cię uwielbiają
        if (player.overall >= 75 && isInSquad) validReasons.push(4);
        // 5: Chcemy budować drużynę wokół ciebie
        if (player.overall >= 80) validReasons.push(5);
        // 6: Twoja lojalność jest doceniana
        if (player.contractYears && player.contractYears <= 1)
          validReasons.push(6);
        // 7: Masz potencjał na więcej
        if (player.age < 27 && player.overall >= 68) validReasons.push(7);
        // 8: Twój profesjonalizm jest wzorowy
        if (avgRating && avgRating >= 6.5 && isInSquad) validReasons.push(8);
        // 9: Inwestujemy w twoją przyszłość
        if (player.age < 25 && player.overall >= 65) validReasons.push(9);
        // 10: Jesteś ważny dla szatni
        if (player.age >= 28 && isInSquad) validReasons.push(10);
        // 11: Rozwijasz się w dobrym kierunku
        if (player.age < 26 && player.overall >= 68) validReasons.push(11);
        // 12: Twoje doświadczenie jest cenne
        if (player.age >= 27 && player.overall >= 72) validReasons.push(12);
        // 13: Chcemy zatrzymać cię na dłużej
        if (isInSquad && player.overall >= 72) validReasons.push(13);
        // 14: Jesteś częścią naszych planów
        if (isInSquad && player.age < 32) validReasons.push(14);
        // 15: Twoja wartość dla klubu rośnie
        if (avgRating && avgRating >= 6.8) validReasons.push(15);
        // 16: Widzimy twoje zaangażowanie
        if (avgRating && goals + assists >= 1) validReasons.push(16);
        // 17: Trener bardzo cię ceni
        if (isInSquad && avgRating && avgRating >= 6.5) validReasons.push(17);
        // 18: Twoja postawa zasługuje na nagrodę
        if (isInSquad && player.overall >= 70) validReasons.push(18);
        // 19: Jesteś filarem tego zespołu
        if (player.overall >= 75 && isInSquad) validReasons.push(19);
        // 20: Chcemy cię docenić
        if (avgRating && avgRating >= 6.5) validReasons.push(20);
        // 21: Trener bardzo cię ceni
        if (isInSquad && player.overall >= 72) validReasons.push(21);
        // 22: Twoje umiejętności są unikalne
        if (player.overall >= 78) validReasons.push(22);
        // 23: Stabilność kadry jest kluczowa
        if (isInSquad && samePos <= 2) validReasons.push(23);
        // 24: Twoja obecność wzmacnia zespół
        if (isInSquad && player.overall >= 70) validReasons.push(24);
        // 25: Twoja wszechstronność jest atutem
        if (player.positions && player.positions.length > 1)
          validReasons.push(25);
        // 26: Możesz być kapitanem w przyszłości
        if (isInSquad && player.age >= 25 && player.overall >= 75)
          validReasons.push(26);
        // 27: Jesteś wzorem dla młodych
        if (player.overall >= 70 && player.age >= 26) validReasons.push(27);
        // 28: Twoje statystyki robią wrażenie
        if (avgRating && avgRating >= 6.8) validReasons.push(28);
        // 29: Masz wiele do zaoferowania
        if (player.age < 28 && player.overall >= 70) validReasons.push(29);
        // 30: Twoja kariera dopiero rozkwita
        if (player.age < 29 && player.overall >= 72) validReasons.push(30);
        // 31: Widzimy w tobie gwiazdę
        if (player.age < 26 && player.overall >= 68) validReasons.push(31);
        // 32: Twoja klasa jest niepodważalna
        if (player.overall >= 77) validReasons.push(32);
        // 33: Zależy nam na tobie
        if (isInSquad && avgRating && avgRating >= 6.5) validReasons.push(33);
        // 34: Twój wkład jest doceniany
        if (avgRating && avgRating >= 6.5 && isInSquad) validReasons.push(34);
        // 35: Jesteś ambasadorem klubu
        if (player.overall >= 80 && isInSquad) validReasons.push(35);
        // 36: Twoje doświadczenie jest bezcenne
        if (player.age >= 28 && player.overall >= 73) validReasons.push(36);
        // 37: Jesteś jednym z najlepszych
        if (player.overall >= 82) validReasons.push(37);
        // 38: Twoja rola jest kluczowa
        if (isInSquad && samePos <= 2) validReasons.push(38);
        // 39: Chcemy przedłużyć współpracę
        if (isInSquad && player.contractYears && player.contractYears <= 2)
          validReasons.push(39);
        // 40: Twoja młodość to atut
        if (player.age < 25 && player.overall >= 66) validReasons.push(40);
        // 41: Trener buduje taktykę wokół ciebie
        if (isInSquad && player.overall >= 73) validReasons.push(41);
        // 42: Twoja jakość jest widoczna
        if (player.overall >= 74) validReasons.push(42);
        // 43: Masz przed sobą świetlane lata
        if (player.age < 28 && player.overall >= 70) validReasons.push(43);
        // 44: Twoja praca nie idzie na marne
        if (avgRating && avgRating >= 6.3 && isInSquad) validReasons.push(44);
        // 45: Twoje bramki/asysty są kluczowe
        if (goals >= 3 || assists >= 3) validReasons.push(45);
        // 46: Twoja dojrzałość jest atutem
        if (player.age >= 26 && player.overall >= 72) validReasons.push(46);
        // 47: Jakość twojej gry jest wysoka
        if (player.overall >= 75) validReasons.push(47);
        // 48: Jesteś ważnym ogniwem
        if (player.overall >= 76 && isInSquad) validReasons.push(48);
        // 49: Klub wierzy w twój talent
        if (isInSquad && player.overall >= 74) validReasons.push(49);
        // 50: To oferta godna twojej klasy
        if (player.overall >= 75 && avgRating && avgRating >= 6.5)
          validReasons.push(50);

        return validReasons;
      }

      function getValidRaiseReasons(player) {
        const validReasons = [];
        const avgRating = getAverageRating(player);
        const isInSquad = GameState.squad.players.some(
          (p) => p && p.id === player.id
        );
        const playerStats = player.matchStats || {};
        const goals = playerStats.goals || 0;
        const assists = playerStats.assists || 0;
        const allPlayers = [
          ...GameState.squad.players,
          ...GameState.squad.bench,
        ].filter((p) => p);
        const avgTeamSalary =
          allPlayers.length > 0
            ? allPlayers.reduce((sum, p) => sum + (p.salary || 0), 0) /
              allPlayers.length
            : 0;

        // Każdy powód ma konkretny warunek
        // 1: Twoje wyniki są wybitne
        if (avgRating && avgRating >= 6.5) validReasons.push(1);
        // 2: Zasługujesz na podwyżkę
        if (avgRating && avgRating >= 7.0) validReasons.push(2);
        // 3: Doceniamy twoją ciężką pracę
        if (isInSquad && avgRating && avgRating >= 6.3) validReasons.push(3);
        // 4: Twoja lojalność jest nagradzana
        if (player.contractYears && player.contractYears >= 2 && isInSquad)
          validReasons.push(4);
        // 5: Inwestujemy w twoją przyszłość
        if (player.age < 28 && player.overall >= 70) validReasons.push(5);
        // 6: Budżet na to pozwala
        if (GameState.manager.balance > 100000) validReasons.push(6);
        // 7: Jesteś kluczowy dla taktyki
        if (isInSquad && player.overall >= 72) validReasons.push(7);
        // 8: Twój rozwój nas cieszy
        if (player.age < 27 && player.overall >= 68) validReasons.push(8);
        // 9: Zasługujesz na uznanie
        if (avgRating && avgRating >= 6.7) validReasons.push(9);
        // 10: Twoja wartość wzrosła
        if (player.salary < player.overall * 10) validReasons.push(10);
        // 11: Twoja młodość to atut
        if (player.age < 27 && player.overall >= 66) validReasons.push(11);
        // 12: Chcemy cię zmotywować
        if (isInSquad && avgRating && avgRating >= 6.0) validReasons.push(12);
        // 13: Trener widzi twoje postępy
        if (isInSquad && player.overall >= 70) validReasons.push(13);
        // 14: Twój wpływ na grę jest duży
        if (isInSquad && (goals >= 2 || assists >= 2)) validReasons.push(14);
        // 15: Twoja kariera idzie w górę
        if (player.age < 28 && player.overall >= 72) validReasons.push(15);
        // 16: Jakość twojej gry jest wysoka
        if (player.overall >= 75) validReasons.push(16);
        // 17: Doceniamy twoje zaangażowanie
        if (isInSquad && avgRating && avgRating >= 6.5) validReasons.push(17);
        // 18: Jesteś gwiazdą tego zespołu
        if (player.overall >= 78) validReasons.push(18);
        // 19: Stać nas na to
        if (
          GameState.manager.balance > 50000 &&
          player.salary < avgTeamSalary * 1.2
        )
          validReasons.push(19);
        // 20: To wyraz naszego szacunku
        if (isInSquad && player.overall >= 73) validReasons.push(20);
        // 21: Twoje bramki są kluczowe
        if (goals >= 3) validReasons.push(21);
        // 22: Twoja obrona jest niezawodna
        if (
          ["CB", "LB", "RB", "CDM", "GK"].includes(player.position) &&
          isInSquad &&
          player.overall >= 70
        )
          validReasons.push(22);
        // 23: Twoje oceny mówią same za siebie
        if (avgRating && avgRating >= 7.2) validReasons.push(23);
        // 24: Widzimy twój wysiłek
        if (avgRating && avgRating >= 6.8) validReasons.push(24);
        // 25: Jesteś jednym z najlepszych
        if (player.overall >= 80) validReasons.push(25);
        // 26: Twoje asysty zmieniają mecze
        if (assists >= 3) validReasons.push(26);
        // 27: Trener buduje taktykę wokół ciebie
        if (isInSquad && player.overall >= 72) validReasons.push(27);
        // 28: Twoje dryblingi zachwycają
        if (player.stats && player.stats.Dribbling >= 75) validReasons.push(28);
        // 29: Twoja forma jest imponująca
        if (avgRating && avgRating >= 6.7) validReasons.push(29);
        // 30: Jesteś filarem drużyny
        if (isInSquad && player.overall >= 74) validReasons.push(30);
        // 31: Twoja jakość jest widoczna
        if (player.overall >= 73) validReasons.push(31);
        // 32: Twoje występy są stabilne
        if (avgRating && avgRating >= 6.9) validReasons.push(32);
        // 33: Twoja młodość to bonus
        if (player.age < 26 && player.overall >= 68) validReasons.push(33);
        // 34: Twoje podania są precyzyjne
        if (player.stats && player.stats.Passing >= 72) validReasons.push(34);
        // 35: Twój poziom jest top
        if (avgRating && avgRating >= 7.0) validReasons.push(35);
        // 36: Rozwijasz się świetnie
        if (player.overall >= 71 && player.age < 28) validReasons.push(36);
        // 37: Masz wielki potencjał
        if (player.age < 25 && player.overall >= 66) validReasons.push(37);
        // 38: Twoja klasa jest niepodważalna
        if (player.overall >= 72) validReasons.push(38);
        // 39: Jesteś ważny dla nas
        if (isInSquad && player.overall >= 73) validReasons.push(39);
        // 40: Twoja obecność dodaje pewności zespołowi
        if (isInSquad && player.overall >= 70) validReasons.push(40);
        // 41: Twoja gra kreuje szanse
        if (player.stats && player.stats.Passing >= 70 && isInSquad)
          validReasons.push(41);
        // 42: Twoja wszechstronność jest cenna
        if (player.positions && player.positions.length > 1 && isInSquad)
          validReasons.push(42);
        // 43: Twój poziom gry wzrósł
        if (player.overall >= 76) validReasons.push(43);
        // 44: Twoja dyspozycja jest świetna
        if (avgRating && avgRating >= 6.8) validReasons.push(44);
        // 45: Twoje statystyki są imponujące
        if (isInSquad && (goals >= 1 || assists >= 1)) validReasons.push(45);
        // 46: Twoja regularność jest godna pochwały
        if (avgRating && avgRating >= 6.6) validReasons.push(46);
        // 47: Twoja wizja gry jest świetna
        if (player.stats && player.stats.Passing >= 73) validReasons.push(47);
        // 48: Twoja defensywa jest solidna
        if (
          ["GK", "CB", "CDM"].includes(player.position) &&
          player.overall >= 70 &&
          isInSquad
        )
          validReasons.push(48);
        // 49: Zasługujesz na więcej
        if (player.overall >= 74 && player.salary < player.overall * 12)
          validReasons.push(49);
        // 50: Ta podwyżka to minimum co możemy zrobić
        if (
          isInSquad &&
          avgRating &&
          avgRating >= 6.5 &&
          player.salary < avgTeamSalary
        )
          validReasons.push(50);

        return validReasons;
      }

      function showOfferInputs() {
        const panel = document.getElementById("chatInputPanel");
        const yearsInput = document.getElementById("chatYearsInput");
        const salaryInput = document.getElementById("chatSalaryInput");
        const salaryLabel = document.getElementById("chatSalaryLabel");
        const salaryUnit = document.getElementById("chatSalaryUnit");

        // Update unit translation
        if (salaryUnit) {
          salaryUnit.textContent = currentLang === "pl" ? "€/tyg" : "€/wk";
        }

        if (chatState.type === "reduce_salary") {
          salaryLabel.textContent =
            currentLang === "pl" ? "Nowa pensja:" : "New salary:";
          salaryInput.value = Math.floor(chatState.player.salary * 0.8);
          yearsInput.style.display = "none";
        } else if (chatState.type === "extend_contract") {
          salaryLabel.textContent =
            currentLang === "pl" ? "Pensja:" : "Salary:";
          salaryInput.value = chatState.player.salary;
          yearsInput.style.display = "flex";
        } else if (chatState.type === "raise_salary") {
          salaryLabel.textContent =
            currentLang === "pl" ? "Nowa pensja:" : "New salary:";
          salaryInput.value = Math.floor(chatState.player.salary * 1.2);
          yearsInput.style.display = "none";
        }

        panel.style.display = "flex";
      }

      function updateChatReasons() {
        const selected = [];
        document
          .querySelectorAll("#chatReasonsList input:checked")
          .forEach((cb) => {
            selected.push(parseInt(cb.value));
          });
        chatState.selectedReasons = selected;

        // Update send button
        document.getElementById("chatSendBtn").disabled = selected.length === 0;
      }

      function sendNegotiationMessage() {
        if (chatState.selectedReasons.length === 0) return;

        const salary =
          parseInt(document.getElementById("chatSalaryInput").value) || 0;
        const years =
          parseInt(document.getElementById("chatContractYears").value) || 2;

        chatState.offerSalary = salary;
        chatState.offerYears = years;
        chatState.attempts++;

        // Hide panels
        document.getElementById("chatReasonsPanel").style.display = "none";
        document.getElementById("chatInputPanel").style.display = "none";
        document.getElementById("chatSendBtn").style.display = "none";

        // Build manager's message with reasons
        let reasonPrefix = "";
        if (chatState.type === "reduce_salary") reasonPrefix = "reduceReason";
        else if (chatState.type === "extend_contract")
          reasonPrefix = "extendReason";
        else if (chatState.type === "raise_salary")
          reasonPrefix = "raiseReason";

        const reasonTexts = chatState.selectedReasons
          .map((i) => "• " + t(reasonPrefix + i))
          .join("\n");
        const managerMsg =
          reasonTexts +
          "\n\n" +
          t("chatNewOffer") +
          "\n💰 €" +
          salary.toLocaleString() +
          "/" +
          (currentLang === "pl" ? "tyg" : "wk") +
          (chatState.type === "extend_contract"
            ? "\n📅 " + years + " " + t("years")
            : "");

        addPlayerChatMessage(managerMsg, "manager");

        // Player responds immediately
        processPlayerChatResponse();
      }

      function processPlayerChatResponse() {
        const player = chatState.player;
        let accepted = false;
        let counterOffer = false;

        // Calculate acceptance chance
        if (chatState.type === "reduce_salary") {
          const reduction = 1 - chatState.offerSalary / player.salary;
          let acceptChance =
            reduction < 0.1 ? 0.7 : reduction < 0.2 ? 0.4 : 0.15;
          acceptChance += chatState.selectedReasons.length * 0.025; // Each reason adds 2.5%
          acceptChance = Math.min(0.9, acceptChance);

          if (Math.random() < acceptChance) {
            accepted = true;
          } else if (
            chatState.attempts < chatState.maxAttempts &&
            Math.random() < 0.6
          ) {
            counterOffer = true;
          }
        } else if (chatState.type === "extend_contract") {
          const expectedSalary = player.overall * 60;
          const salaryRatio = chatState.offerSalary / expectedSalary;
          let acceptChance = Math.min(0.85, salaryRatio * 0.6 + 0.15);
          acceptChance += chatState.selectedReasons.length * 0.02;
          acceptChance = Math.min(0.9, acceptChance);

          if (Math.random() < acceptChance) {
            accepted = true;
          } else if (
            chatState.attempts < chatState.maxAttempts &&
            Math.random() < 0.6
          ) {
            counterOffer = true;
          }
        } else if (chatState.type === "raise_salary") {
          const increase = chatState.offerSalary / player.salary - 1;
          let acceptChance = increase > 0.3 ? 0.9 : increase > 0.15 ? 0.6 : 0.3;
          acceptChance += chatState.selectedReasons.length * 0.02;
          acceptChance = Math.min(0.95, acceptChance);

          if (Math.random() < acceptChance) {
            accepted = true;
          } else if (
            chatState.attempts < chatState.maxAttempts &&
            Math.random() < 0.5
          ) {
            counterOffer = true;
          }
        }

        if (accepted) {
          addPlayerChatMessage(t("chatPlayerAccepted"), "player");
          addPlayerChatMessage(t("chatDealDone"), "system");

          // Apply changes
          if (chatState.type === "reduce_salary") {
            player.salary = chatState.offerSalary;
          } else if (chatState.type === "extend_contract") {
            player.salary = chatState.offerSalary;
            player.contractYears = chatState.offerYears;
          } else if (chatState.type === "raise_salary") {
            player.salary = chatState.offerSalary;
          }

          chatState.phase = "done";
          document.getElementById("chatEndBtn").style.display = "block";
          autoSave();
        } else if (counterOffer) {
          addPlayerChatMessage(t("chatPlayerCounter"), "player");

          // Reset for new attempt
          chatState.selectedReasons = [];
          document
            .querySelectorAll("#chatReasonsList input")
            .forEach((cb) => (cb.checked = false));
          showReasonsPanel();
        } else {
          addPlayerChatMessage(t("chatPlayerRejected"), "player");
          addPlayerChatMessage(t("chatDealFailed"), "system");
          chatState.phase = "done";
          document.getElementById("chatEndBtn").style.display = "block";
        }
      }

      function closeNegotiationChat() {
        document.getElementById("negotiationChatModal").style.display = "none";
      }

      function endNegotiationChat() {
        closeNegotiationChat();
      }

      // Old function kept for compatibility
      function sendComposeEmail() {
        startNegotiationChat();
      }

      function schedulePlayerResponse(emailData) {
        // Quick response: 5-10 seconds
        const minTime = 5 * 1000; // 5 seconds
        const maxTime = 10 * 1000; // 10 seconds

        const responseTime = minTime + Math.random() * (maxTime - minTime);

        setTimeout(() => {
          processPlayerResponse(emailData);
        }, responseTime);
      }

      function processPlayerResponse(emailData) {
        const player = findPlayerById(emailData.playerId);
        if (!player) return;

        let accepted = false;

        if (emailData.originalType === "reduce_salary") {
          // Calculate acceptance chance based on salary reduction AND number of reasons
          const reduction = 1 - emailData.newSalary / player.salary;
          // Base chance: 80% if reduction < 10%, 50% if 10-20%, 20% if > 20%
          let acceptChance =
            reduction < 0.1 ? 0.8 : reduction < 0.2 ? 0.5 : 0.2;

          // Bonus for more reasons (each reason adds 5%, max +50% from 10 reasons)
          const reasonsBonus = (emailData.reasons?.length || 0) * 0.05;
          acceptChance = Math.min(0.95, acceptChance + reasonsBonus);

          accepted = Math.random() < acceptChance;
        } else if (emailData.originalType === "extend_contract") {
          // Calculate acceptance based on salary offer
          const expectedSalary = player.overall * 60;
          const salaryRatio = emailData.newSalary / expectedSalary;
          // Higher salary = higher chance
          const acceptChance = Math.min(0.9, salaryRatio * 0.7 + 0.2);
          accepted = Math.random() < acceptChance;
        }

        // Create response email
        const responseEmail = {
          id: Date.now() + Math.random(),
          type: accepted ? "offer_accepted" : "offer_rejected",
          playerId: emailData.playerId,
          playerName: emailData.playerName,
          player: player,
          subject: accepted
            ? `✅ ${emailData.playerName} ${t("playerAccepted")}`
            : `❌ ${emailData.playerName} ${t("playerRejected")}`,
          urgent: false,
          unread: true,
          resolved: accepted, // Only resolved if accepted, rejected needs action
          timestamp: Date.now(),
          originalOffer: emailData,
        };

        // Apply changes if accepted
        if (accepted) {
          if (emailData.originalType === "reduce_salary") {
            player.salary = emailData.newSalary;
          } else if (emailData.originalType === "extend_contract") {
            player.salary = emailData.newSalary;
            player.contractYears = emailData.newYears;
          }
        }

        // Add response to emails
        GameState.emails.unshift(responseEmail);

        // Remove from pending
        composeState.pendingMessages = composeState.pendingMessages.filter(
          (m) => m.id !== emailData.id
        );

        updateEmailBadge();
        autoSave();
      }

      // ==================== TRANSFER LIST SYSTEM ====================

      let transferListState = {
        listedPlayers: [], // { playerId, askingPrice, listedAt }
        offers: [], // { id, playerId, clubName, offerAmount, timestamp }
        offerInterval: null,
      };

      const CLUB_NAMES = [
        "FC Barcelona",
        "Real Madrid",
        "Bayern Munich",
        "Manchester City",
        "Liverpool FC",
        "PSG",
        "Juventus",
        "AC Milan",
        "Inter Milan",
        "Chelsea FC",
        "Arsenal",
        "Atletico Madrid",
        "Borussia Dortmund",
        "RB Leipzig",
        "Napoli",
        "AS Roma",
        "Ajax",
        "Porto",
        "Benfica",
        "Sevilla",
        "Leicester City",
        "West Ham",
        "Tottenham",
        "Newcastle",
      ];

      let currentSellPlayer = null;

      function openTransferList() {
        showScreen("transferListScreen");
        document.getElementById("transferListBalance").textContent =
          "€" + GameState.manager.balance.toLocaleString();
        renderTransferSquadView();
        renderTransferOffers();
        startOfferGeneration();
      }

      function renderTransferSquadView() {
        const squadGrid = document.getElementById("transferSquadGrid");
        const benchGrid = document.getElementById("transferBenchGrid");
        const listedGrid = document.getElementById("transferListedGrid");

        // Render squad cards
        let squadHTML = "";
        GameState.squad.players.forEach((player, index) => {
          if (!player) return;
          const isListed = transferListState.listedPlayers.some(
            (l) => l.playerId === player.id
          );
          if (isListed) {
            squadHTML += `
                        <div class="transfer-card-slot listed">
                            ${renderPlayerCard(player, true, true)}
                            <div class="listed-badge">🏷️</div>
                        </div>
                    `;
          } else {
            squadHTML += `
                        <div class="transfer-card-slot" onclick="openSellCardModal('${
                          player.id
                        }')">
                            ${renderPlayerCard(player, true, true)}
                        </div>
                    `;
          }
        });
        squadGrid.innerHTML = squadHTML;

        // Render bench cards
        let benchHTML = "";
        GameState.squad.bench.forEach((player, index) => {
          if (!player) return;
          const isListed = transferListState.listedPlayers.some(
            (l) => l.playerId === player.id
          );
          if (isListed) {
            benchHTML += `
                        <div class="transfer-card-slot listed">
                            ${renderPlayerCard(player, true, true)}
                            <div class="listed-badge">🏷️</div>
                        </div>
                    `;
          } else {
            benchHTML += `
                        <div class="transfer-card-slot" onclick="openSellCardModal('${
                          player.id
                        }')">
                            ${renderPlayerCard(player, true, true)}
                        </div>
                    `;
          }
        });
        benchGrid.innerHTML = benchHTML;

        // Render listed players section
        if (listedGrid) {
          if (transferListState.listedPlayers.length === 0) {
            listedGrid.innerHTML = `<div class="no-listed">${
              currentLang === "pl"
                ? "Brak wystawionych graczy"
                : "No players listed"
            }</div>`;
          } else {
            let listedHTML = "";
            transferListState.listedPlayers.forEach((listing) => {
              const player = findPlayerById(listing.playerId);
              if (!player) return;
              listedHTML += `
                            <div class="listed-card-item">
                                <div class="listed-card-wrapper">
                                    ${renderPlayerCard(player, true, true)}
                                </div>
                                <div class="listed-card-info">
                                    <div class="listed-card-price">€${listing.askingPrice.toLocaleString()}</div>
                                    <button class="listed-remove-btn" onclick="unlistPlayer('${
                                      listing.playerId
                                    }'); renderTransferSquadView();">
                                        ❌ ${
                                          currentLang === "pl"
                                            ? "Usuń"
                                            : "Remove"
                                        }
                                    </button>
                                </div>
                            </div>
                        `;
            });
            listedGrid.innerHTML = listedHTML;
          }
        }
      }

      function renderTransferOffers() {
        const offersContainer = document.getElementById("offersListContainer");

        // Render offers
        if (transferListState.offers.length === 0) {
          offersContainer.innerHTML = `<div class="no-offers">${t(
            "noOffersYet"
          )}</div>`;
        } else {
          offersContainer.innerHTML = transferListState.offers
            .map((offer) => {
              const player = findPlayerById(offer.playerId);
              if (!player) return "";
              const isNew = Date.now() - offer.timestamp < 5000;
              return `
                        <div class="offer-item ${isNew ? "new" : ""}">
                            <div class="offer-header">
                                <div class="offer-club">🏟️ ${
                                  offer.clubName
                                }</div>
                                <div class="offer-amount">€${offer.offerAmount.toLocaleString()}</div>
                            </div>
                            <div class="offer-player">${t("fromClub")}: ${
                player.name
              } (${player.position})</div>
                            <div class="offer-actions">
                                <button class="offer-btn accept" onclick="acceptTransferOffer('${
                                  offer.id
                                }')">✅ ${t("acceptOffer")}</button>
                                <button class="offer-btn reject" onclick="rejectTransferOffer('${
                                  offer.id
                                }')">❌ ${t("rejectOffer")}</button>
                                <button class="offer-btn negotiate" onclick="negotiateTransferOffer('${
                                  offer.id
                                }')">💬 ${t("negotiateOffer")}</button>
                            </div>
                        </div>
                    `;
            })
            .join("");
        }
      }

      function openSellCardModal(playerId) {
        const player = findPlayerById(playerId);
        if (!player) return;

        // Check if already listed
        if (
          transferListState.listedPlayers.some(
            (l) => String(l.playerId) === String(playerId)
          )
        ) {
          // Already listed - ask to remove
          if (
            confirm(
              currentLang === "pl"
                ? "Usunąć gracza z listy transferowej?"
                : "Remove player from transfer list?"
            )
          ) {
            unlistPlayer(playerId);
            renderTransferSquadView();
          }
          return;
        }

        // Check if can sell this player
        const squadIndex = GameState.squad.players.findIndex(
          (p) => p && String(p.id) === String(playerId)
        );
        const benchIndex = GameState.squad.bench.findIndex(
          (p) => p && String(p.id) === String(playerId)
        );

        const squadCount = GameState.squad.players.filter((p) => p).length;
        const benchCount = GameState.squad.bench.filter((p) => p).length;

        // Warn if selling would leave squad/bench short
        if (squadIndex !== -1 && squadCount <= 11) {
          alert(
            currentLang === "pl"
              ? "Nie możesz sprzedać tego gracza! Musisz mieć 11 zawodników w składzie. Najpierw kup lub przenieś kogoś z ławki."
              : "Cannot sell this player! You must have 11 players in squad. Buy or move someone from bench first."
          );
          return;
        }

        if (benchIndex !== -1 && benchCount <= 5) {
          alert(
            currentLang === "pl"
              ? "Nie możesz sprzedać tego gracza! Musisz mieć minimum 5 zawodników na ławce."
              : "Cannot sell this player! You must have at least 5 players on bench."
          );
          return;
        }

        currentSellPlayer = player;

        // Show modal
        const modal = document.getElementById("sellCardModal");
        const front = document.getElementById("sellCardFront");
        const priceInput = document.getElementById("sellCardPrice");
        const hint = document.getElementById("sellCardHint");
        const marketValue = document.getElementById("sellMarketValue");
        const playerName = document.getElementById("sellPlayerName");
        const playerDetails = document.getElementById("sellPlayerDetails");

        // Render player card (small version, WITH flip enabled)
        front.innerHTML = renderPlayerCard(player, true, false);

        // Set player info
        playerName.textContent = player.name;
        playerDetails.textContent = `${player.position} | ${player.country} | OVR ${player.overall}`;

        // Calculate market value
        const suggestedPrice = Math.floor(player.overall * player.overall * 10);
        marketValue.textContent = "€" + suggestedPrice.toLocaleString();
        priceInput.value = suggestedPrice;
        hint.textContent =
          currentLang === "pl"
            ? `Możesz ustawić wyższą cenę`
            : `You can set a higher price`;

        modal.style.display = "flex";
      }

      function closeSellCardModal() {
        document.getElementById("sellCardModal").style.display = "none";
        currentSellPlayer = null;
      }

      function confirmSellCard() {
        if (!currentSellPlayer) return;

        const price = parseInt(document.getElementById("sellCardPrice").value);
        if (!price || price < 1000) {
          alert(
            currentLang === "pl"
              ? "Podaj prawidłową cenę (min. 1000)"
              : "Enter valid price (min. 1000)"
          );
          return;
        }

        // Add to transfer list
        transferListState.listedPlayers.push({
          playerId: currentSellPlayer.id,
          askingPrice: price,
          listedAt: Date.now(),
        });

        alert(
          t("playerListed")
            .replace("{player}", currentSellPlayer.name)
            .replace("{price}", price.toLocaleString())
        );

        closeSellCardModal();
        renderTransferSquadView();
        autoSave();
      }

      // Legacy function for compatibility
      function renderTransferList() {
        renderTransferSquadView();
        renderTransferOffers();
      }

      function openListPlayerModal() {
        const modal = document.getElementById("listPlayerModal");
        const select = document.getElementById("listPlayerSelect");

        // Get unlisted players
        const allPlayers = [
          ...(GameState.squad.players || []),
          ...(GameState.squad.bench || []),
        ].filter((p) => p);
        const listedIds = transferListState.listedPlayers.map(
          (l) => l.playerId
        );
        const unlistedPlayers = allPlayers.filter(
          (p) => !listedIds.includes(p.id)
        );

        select.innerHTML =
          `<option value="">-- ${
            currentLang === "pl" ? "Wybierz" : "Select"
          } --</option>` +
          unlistedPlayers
            .map(
              (p) =>
                `<option value="${p.id}">${p.name} (${p.position}, OVR ${p.overall})</option>`
            )
            .join("");

        document.getElementById("listPlayerPreview").style.display = "none";
        document.getElementById("listPriceSection").style.display = "none";
        document.getElementById("listPlayerBtn").disabled = true;

        modal.style.display = "flex";
      }

      function closeListPlayerModal() {
        document.getElementById("listPlayerModal").style.display = "none";
      }

      function updateListPlayerPreview() {
        const select = document.getElementById("listPlayerSelect");
        const preview = document.getElementById("listPlayerPreview");
        const priceSection = document.getElementById("listPriceSection");
        const playerId = select.value;

        if (!playerId) {
          preview.style.display = "none";
          priceSection.style.display = "none";
          document.getElementById("listPlayerBtn").disabled = true;
          return;
        }

        const player = findPlayerById(parseFloat(playerId));
        if (!player) return;

        const marketValue = Math.floor(player.overall * player.overall * 10);

        preview.innerHTML = `
                <div style="text-align: center; padding: 0.5rem;">
                    <strong>${player.name}</strong><br>
                    ${player.position} | OVR ${player.overall}<br>
                    <span style="color: var(--gold);">${
                      currentLang === "pl" ? "Wartość rynkowa" : "Market value"
                    }: €${marketValue.toLocaleString()}</span>
                </div>
            `;
        preview.style.display = "block";

        document.getElementById("listAskingPrice").value = marketValue;
        document.getElementById("listPriceHint").textContent = `${
          currentLang === "pl" ? "Sugerowana" : "Suggested"
        }: €${marketValue.toLocaleString()}`;
        priceSection.style.display = "block";
        document.getElementById("listPlayerBtn").disabled = false;
      }

      function confirmListPlayer() {
        const playerId = parseFloat(
          document.getElementById("listPlayerSelect").value
        );
        const askingPrice =
          parseInt(document.getElementById("listAskingPrice").value) || 0;

        if (!playerId || askingPrice < 1000) return;

        const player = findPlayerById(playerId);
        if (!player) return;

        transferListState.listedPlayers.push({
          playerId: playerId,
          askingPrice: askingPrice,
          listedAt: Date.now(),
        });

        closeListPlayerModal();
        renderTransferList();
        alert(t("playerListed").replace("{player}", player.name));
        autoSave();
      }

      function unlistPlayer(playerId) {
        const player = findPlayerById(parseFloat(playerId));
        transferListState.listedPlayers =
          transferListState.listedPlayers.filter((l) => l.playerId != playerId);
        transferListState.offers = transferListState.offers.filter(
          (o) => o.playerId != playerId
        );
        renderTransferList();
        if (player) {
          alert(t("playerUnlisted").replace("{player}", player.name));
        }
        autoSave();
      }

      function startOfferGeneration() {
        // Clear existing interval
        if (transferListState.offerInterval) {
          clearInterval(transferListState.offerInterval);
        }

        // Generate offers every 20 seconds
        transferListState.offerInterval = setInterval(() => {
          generateRandomOffer();
        }, 20000);

        // Also generate first offer after 20 seconds
        setTimeout(() => generateRandomOffer(), 20000);
      }

      function generateRandomOffer() {
        if (transferListState.listedPlayers.length === 0) return;

        // Pick random listed player
        const listing =
          transferListState.listedPlayers[
            Math.floor(Math.random() * transferListState.listedPlayers.length)
          ];
        const player = findPlayerById(listing.playerId);
        if (!player) return;

        // Calculate REAL market value based on player stats
        const realMarketValue = Math.floor(
          player.overall * player.overall * 10
        );

        // Generate offer based on REAL value (80-110% of real value)
        const offerPercent = 0.8 + Math.random() * 0.3;
        const offerAmount = Math.floor(realMarketValue * offerPercent);

        // Pick random club
        const clubName =
          CLUB_NAMES[Math.floor(Math.random() * CLUB_NAMES.length)];

        const offer = {
          id: Date.now() + Math.random(),
          playerId: listing.playerId,
          clubName: clubName,
          offerAmount: offerAmount,
          realValue: realMarketValue,
          timestamp: Date.now(),
        };

        transferListState.offers.push(offer);
        renderTransferList();
      }

      function acceptTransferOffer(offerId) {
        const offer = transferListState.offers.find((o) => o.id == offerId);
        if (!offer) return;

        const player = findPlayerById(offer.playerId);
        if (!player) return;

        // Check if player is in squad or bench
        const squadIndex = GameState.squad.players.findIndex(
          (p) => p && p.id === offer.playerId
        );
        const benchIndex = GameState.squad.bench.findIndex(
          (p) => p && p.id === offer.playerId
        );

        // Count current players
        const squadCount = GameState.squad.players.filter((p) => p).length;
        const benchCount = GameState.squad.bench.filter((p) => p).length;

        // Validate: must have 11 in squad
        if (squadIndex !== -1 && squadCount <= 11) {
          alert(
            currentLang === "pl"
              ? "Nie możesz sprzedać tego gracza! Musisz mieć 11 zawodników w składzie."
              : "Cannot sell this player! You must have 11 players in squad."
          );
          return;
        }

        // Validate: must have at least 5 on bench
        if (benchIndex !== -1 && benchCount <= 5) {
          alert(
            currentLang === "pl"
              ? "Nie możesz sprzedać tego gracza! Musisz mieć minimum 5 zawodników na ławce."
              : "Cannot sell this player! You must have at least 5 players on bench."
          );
          return;
        }

        // Add money
        GameState.manager.balance += offer.offerAmount;

        // Remove player from squad
        if (squadIndex !== -1) {
          GameState.squad.players[squadIndex] = null;
        } else if (benchIndex !== -1) {
          GameState.squad.bench.splice(benchIndex, 1); // Actually remove from bench
        }

        // Remove from transfer list
        transferListState.listedPlayers =
          transferListState.listedPlayers.filter(
            (l) => l.playerId !== offer.playerId
          );
        transferListState.offers = transferListState.offers.filter(
          (o) => o.playerId !== offer.playerId
        );

        alert(
          t("offerAccepted")
            .replace("{player}", player.name)
            .replace("{club}", offer.clubName)
            .replace("{price}", offer.offerAmount.toLocaleString())
        );

        // Update ALL balance displays
        updateAccountDisplay();
        updateSquadOverall();
        renderTransferList();
        autoSave();
      }

      function rejectTransferOffer(offerId) {
        const offer = transferListState.offers.find((o) => o.id == offerId);
        if (!offer) return;

        transferListState.offers = transferListState.offers.filter(
          (o) => o.id != offerId
        );
        alert(t("offerRejected").replace("{club}", offer.clubName));
        renderTransferList();
      }

      // Sell Negotiation
      let sellNegotiationState = {
        offer: null,
        player: null,
        selectedReasons: [],
        counterPrice: 0,
        attempts: 0,
        maxAttempts: 3,
      };

      function negotiateTransferOffer(offerId) {
        const offer = transferListState.offers.find((o) => o.id == offerId);
        if (!offer) return;

        const player = findPlayerById(offer.playerId);
        if (!player) return;

        const listing = transferListState.listedPlayers.find(
          (l) => l.playerId === offer.playerId
        );

        sellNegotiationState = {
          offer: offer,
          player: player,
          listing: listing,
          selectedReasons: [],
          counterPrice: listing ? listing.askingPrice : offer.offerAmount * 1.2,
          attempts: 0,
          maxAttempts: 3,
        };

        // Setup modal
        document.getElementById("sellChatClubName").textContent =
          offer.clubName;
        document.getElementById("sellChatMessages").innerHTML = "";
        document.getElementById("sellReasonsPanel").style.display = "none";
        document.getElementById("sellInputPanel").style.display = "none";
        document.getElementById("sellChatSendBtn").style.display = "none";
        document.getElementById("sellChatEndBtn").style.display = "none";

        document.getElementById("sellNegotiationModal").style.display = "flex";

        // Start chat
        startSellNegotiation();
      }

      function addSellChatMessage(text, sender) {
        const container = document.getElementById("sellChatMessages");
        const msg = document.createElement("div");
        msg.className = `chat-message ${sender}`;
        msg.textContent = text;
        container.appendChild(msg);
        container.scrollTop = container.scrollHeight;
      }

      function startSellNegotiation() {
        const offer = sellNegotiationState.offer;
        const player = sellNegotiationState.player;

        // Agent greeting
        const agentGreeting =
          currentLang === "pl"
            ? `Dzień dobry. Reprezentuję ${
                offer.clubName
              }. Oferujemy €${offer.offerAmount.toLocaleString()} za ${
                player.name
              }.`
            : `Hello. I represent ${
                offer.clubName
              }. We offer €${offer.offerAmount.toLocaleString()} for ${
                player.name
              }.`;
        addSellChatMessage(agentGreeting, "player");

        const managerResponse =
          currentLang === "pl"
            ? "Rozumiem. Pozwól że przedstawię swoje argumenty."
            : "I understand. Let me present my arguments.";
        addSellChatMessage(managerResponse, "manager");

        showSellReasonsPanel();
      }

      function showSellReasonsPanel() {
        const panel = document.getElementById("sellReasonsPanel");
        const list = document.getElementById("sellReasonsList");
        const player = sellNegotiationState.player;
        const offer = sellNegotiationState.offer;

        // Get valid reasons for this player
        const validReasons = getValidSellReasons(player, offer);

        list.innerHTML = "";
        validReasons.forEach((reasonNum) => {
          const reason = t("sellReason" + reasonNum);
          const item = document.createElement("label");
          item.className = "chat-reason-item";
          item.innerHTML = `<input type="checkbox" value="${reasonNum}" onchange="updateSellReasons()"> <span>${reason}</span>`;
          list.appendChild(item);
        });

        panel.style.display = "block";

        // Show price input
        const inputPanel = document.getElementById("sellInputPanel");
        document.getElementById("sellPriceInput").value =
          sellNegotiationState.counterPrice;
        document.getElementById("sellPriceLabel").textContent =
          currentLang === "pl" ? "Twoja cena:" : "Your price:";
        inputPanel.style.display = "flex";

        document.getElementById("sellChatSendBtn").style.display = "block";
        document.getElementById("sellChatSendBtn").disabled = true;
      }

      function getValidSellReasons(player, offer) {
        const validReasons = [];
        const marketValue = player.overall * player.overall * 10;
        const avgRating = getAverageRating(player);
        const isInSquad = GameState.squad.players.some(
          (p) => p && p.id === player.id
        );
        const squadCount = GameState.squad.players.filter((p) => p).length;
        const samePositionCount = GameState.squad.players.filter(
          (p) => p && p.position === player.position
        ).length;
        const hasUpgrades =
          player.stats &&
          Object.values(player.stats).some((v) => v > player.overall);
        const playerStats = player.matchStats || {};
        const goals = playerStats.goals || 0;
        const assists = playerStats.assists || 0;

        // Każdy powód ma konkretny warunek
        // 1: Gracz jest kluczowy dla składu
        if (isInSquad && player.overall >= 70) validReasons.push(1);
        // 2: Cena jest zbyt niska
        if (offer && offer.offerAmount < marketValue * 0.9)
          validReasons.push(2);
        // 3: Mamy długoterminowe plany
        if (player.age < 25 && player.overall >= 65) validReasons.push(3);
        // 4: Kibice go uwielbiają
        if (player.overall >= 80 || (avgRating && avgRating > 7.5))
          validReasons.push(4);
        // 5: Jest w szczytowej formie
        if (avgRating && avgRating >= 7.0) validReasons.push(5);
        // 6: Inne kluby oferowały więcej
        if (offer && offer.offerAmount < marketValue * 1.1)
          validReasons.push(6);
        // 7: Wartość rynkowa rośnie
        if (player.age < 27 && player.overall >= 70) validReasons.push(7);
        // 8: Potrzebujemy go do końca sezonu
        if (isInSquad && player.overall >= 68) validReasons.push(8);
        // 9: To niesprawiedliwa oferta
        if (offer && offer.offerAmount < marketValue * 0.8)
          validReasons.push(9);
        // 10: Ma duży potencjał rozwoju
        if (player.age < 24 && player.overall >= 62) validReasons.push(10);
        // 11: Trudno będzie go zastąpić
        if (samePositionCount <= 1 && isInSquad) validReasons.push(11);
        // 12: Kontrakt jest długoterminowy
        if (player.contractYears && player.contractYears > 2)
          validReasons.push(12);
        // 13: Sponsor wymaga jego obecności
        if (player.overall >= 85) validReasons.push(13);
        // 14: Jest liderem szatni
        if (player.age >= 28 && player.overall >= 75 && isInSquad)
          validReasons.push(14);
        // 15: Media go uwielbiają
        if (player.overall >= 82) validReasons.push(15);
        // 16: Statystyki mówią same za siebie
        if (avgRating && avgRating >= 6.5) validReasons.push(16);
        // 17: Inwestowaliśmy w jego rozwój
        if (hasUpgrades) validReasons.push(17);
        // 18: Byłby stratą dla ligi
        if (player.overall >= 85) validReasons.push(18);
        // 19: Nie jesteśmy zdesperowani
        if (GameState.manager.balance > 100000) validReasons.push(19);
        // 20: Cena musi odzwierciedlać jego klasę
        if (offer && offer.offerAmount < marketValue) validReasons.push(20);
        // 21: To nasz najlepszy strzelec
        if (goals >= 5) validReasons.push(21);
        // 22: Ma świetne statystyki w tym sezonie
        if (avgRating && avgRating >= 7.0) validReasons.push(22);
        // 23: Jest częścią naszego projektu sportowego
        if (player.contractYears && player.contractYears >= 2 && isInSquad)
          validReasons.push(23);
        // 24: Jego umiejętności są unikalne
        if (player.overall >= 78) validReasons.push(24);
        // 25: Dopiero co przedłużył kontrakt
        if (player.contractYears && player.contractYears >= 3)
          validReasons.push(25);
        // 26: Nie możemy go stracić w środku sezonu
        if (isInSquad && player.overall >= 70) validReasons.push(26);
        // 27: Trener uważa go za niezbędnego
        if (isInSquad && player.overall >= 72) validReasons.push(27);
        // 28: Ma świetną chemię z drużyną
        if (isInSquad && avgRating && avgRating >= 6.0) validReasons.push(28);
        // 29: Jest gwarancją bramek
        if (goals >= 3 && ["ST", "CF", "LW", "RW"].includes(player.position))
          validReasons.push(29);
        // 30: Jego obrona jest kluczowa
        if (
          ["CB", "LB", "RB", "CDM", "GK"].includes(player.position) &&
          isInSquad &&
          player.overall >= 68
        )
          validReasons.push(30);
        // 31: Ma najlepsze podania w zespole
        if (player.stats && player.stats.Passing >= 75) validReasons.push(31);
        // 32: Jest naszym najszybszym graczem
        if (player.stats && player.stats.Pace >= 80) validReasons.push(32);
        // 33: Jego doświadczenie jest bezcenne
        if (player.age >= 28 && player.overall >= 72) validReasons.push(33);
        // 34: Młodzi gracze się od niego uczą
        if (player.age >= 30 && isInSquad && player.overall >= 70)
          validReasons.push(34);
        // 35: Jest twarzą naszego klubu
        if (player.overall >= 85) validReasons.push(35);
        // 36: Sponsorzy podpisali z nim umowę
        if (player.overall >= 83) validReasons.push(36);
        // 37: Nie znajdziemy godnego zastępcy
        if (samePositionCount <= 1 && player.overall >= 70)
          validReasons.push(37);
        // 38: Potrzebujemy stabilności w składzie
        if (isInSquad && squadCount <= 11) validReasons.push(38);
        // 39: Mamy ambicje mistrzowskie
        if (GameState.manager.balance > 50000 && isInSquad)
          validReasons.push(39);
        // 40: Jest w najlepszym wieku
        if (player.age >= 24 && player.age <= 29 && player.overall >= 72)
          validReasons.push(40);
        // 41: Jego wartość tylko rośnie
        if (player.age < 27 && player.overall >= 68) validReasons.push(41);
        // 42: Byłby to cios dla morale drużyny
        if (isInSquad && player.overall >= 75) validReasons.push(42);
        // 43: Kibice by nas za to znienawidzili
        if (player.overall >= 80) validReasons.push(43);
        // 44: Ma klauzulę wykupu wyższą od oferty
        if (
          offer &&
          offer.offerAmount < marketValue * 1.2 &&
          player.contractYears &&
          player.contractYears >= 2
        )
          validReasons.push(44);
        // 45: Jest niezawodny w kluczowych meczach
        if (avgRating && avgRating >= 7.0) validReasons.push(45);
        // 46: Jego etyka pracy jest wzorowa
        if (player.overall >= 70 && isInSquad) validReasons.push(46);
        // 47: Jest gwiazdą mediów społecznościowych
        if (player.overall >= 82) validReasons.push(47);
        // 48: Rywale by zyskali za dużo
        if (player.overall >= 75 && isInSquad) validReasons.push(48);
        // 49: To strategiczny zawodnik dla nas
        if (isInSquad && player.overall >= 72) validReasons.push(49);
        // 50: Ta oferta to obraza dla jego klasy
        if (offer && offer.offerAmount < marketValue * 0.7)
          validReasons.push(50);

        return validReasons;
      }

      function updateSellReasons() {
        const selected = [];
        document
          .querySelectorAll("#sellReasonsList input:checked")
          .forEach((cb) => {
            selected.push(parseInt(cb.value));
          });
        sellNegotiationState.selectedReasons = selected;
        document.getElementById("sellChatSendBtn").disabled =
          selected.length === 0;
      }

      function sendSellNegotiationMessage() {
        if (sellNegotiationState.selectedReasons.length === 0) return;

        const price =
          parseInt(document.getElementById("sellPriceInput").value) || 0;
        sellNegotiationState.counterPrice = price;
        sellNegotiationState.attempts++;

        // Hide panels
        document.getElementById("sellReasonsPanel").style.display = "none";
        document.getElementById("sellInputPanel").style.display = "none";
        document.getElementById("sellChatSendBtn").style.display = "none";

        // Build message
        const reasonTexts = sellNegotiationState.selectedReasons
          .map((i) => "• " + t("sellReason" + i))
          .join("\n");
        const priceText = currentLang === "pl" ? "Moja cena" : "My price";
        const managerMsg =
          reasonTexts + "\n\n" + priceText + ": €" + price.toLocaleString();

        addSellChatMessage(managerMsg, "manager");

        // Process agent response
        processSellNegotiationResponse();
      }

      function processSellNegotiationResponse() {
        const offer = sellNegotiationState.offer;
        const player = sellNegotiationState.player;
        const counterPrice = sellNegotiationState.counterPrice;

        // Calculate REAL market value
        const realMarketValue = Math.floor(
          player.overall * player.overall * 10
        );

        // Agent analyzes: is the counter price reasonable compared to real value?
        const priceVsReal = counterPrice / realMarketValue;

        let acceptChance = 0;

        // If asking for less than 120% of real value - very likely to accept
        if (priceVsReal <= 1.2) {
          acceptChance = 0.85;
        } else if (priceVsReal <= 1.5) {
          acceptChance = 0.5;
        } else if (priceVsReal <= 2.0) {
          acceptChance = 0.2;
        } else {
          // Asking for 2x+ real value - almost no chance
          acceptChance = 0.05;
        }

        // Bonus for reasons
        acceptChance += sellNegotiationState.selectedReasons.length * 0.015;
        acceptChance = Math.min(0.9, acceptChance);

        let accepted = false;
        let counterOffer = false;

        if (Math.random() < acceptChance) {
          accepted = true;
        } else if (
          sellNegotiationState.attempts < sellNegotiationState.maxAttempts &&
          priceVsReal < 2.5
        ) {
          counterOffer = true;
        }

        if (accepted) {
          const acceptMsg =
            currentLang === "pl"
              ? `Zgadzam się! €${counterPrice.toLocaleString()} to uczciwa cena.`
              : `I agree! €${counterPrice.toLocaleString()} is a fair price.`;
          addSellChatMessage(acceptMsg, "player");
          addSellChatMessage(t("chatDealDone"), "system");

          // Complete sale
          offer.offerAmount = counterPrice;
          acceptTransferOffer(offer.id);

          document.getElementById("sellChatEndBtn").style.display = "block";
        } else if (counterOffer) {
          // Agent makes counter offer - closer to real value
          const maxAgentWillPay = realMarketValue * 1.15;
          const newOffer = Math.floor(
            Math.min(
              maxAgentWillPay,
              offer.offerAmount + (counterPrice - offer.offerAmount) * 0.3
            )
          );
          offer.offerAmount = newOffer;

          const counterMsg =
            currentLang === "pl"
              ? `To za dużo. Wartość rynkowa to około €${realMarketValue.toLocaleString()}. Mogę dać €${newOffer.toLocaleString()}.`
              : `That's too much. Market value is around €${realMarketValue.toLocaleString()}. I can offer €${newOffer.toLocaleString()}.`;
          addSellChatMessage(counterMsg, "player");

          // Reset for new attempt
          sellNegotiationState.selectedReasons = [];
          document
            .querySelectorAll("#sellReasonsList input")
            .forEach((cb) => (cb.checked = false));
          showSellReasonsPanel();
        } else {
          const rejectMsg =
            currentLang === "pl"
              ? `Niestety €${counterPrice.toLocaleString()} to za dużo. Wartość rynkowa to €${realMarketValue.toLocaleString()}. Negocjacje zakończone.`
              : `Unfortunately €${counterPrice.toLocaleString()} is too much. Market value is €${realMarketValue.toLocaleString()}. Negotiations over.`;
          addSellChatMessage(rejectMsg, "player");
          addSellChatMessage(t("chatDealFailed"), "system");

          document.getElementById("sellChatEndBtn").style.display = "block";
        }
      }

      function closeSellNegotiation() {
        document.getElementById("sellNegotiationModal").style.display = "none";
        renderTransferList();
      }

      // ==================== SAVE/LOAD SYSTEM ====================
      const SAVE_KEY = "footballManagerUltimate_save";

      function saveGame() {
        try {
          const saveData = {
            version: 1,
            timestamp: Date.now(),
            manager: GameState.manager,
            squad: GameState.squad,
            market: {
              cards: GameState.market.cards,
              lastRefresh: GameState.market.lastRefresh,
            },
            stats: GameState.stats,
            legends: GameState.legends,
            emails: GameState.emails,
            lastWeekCheck: GameState.lastWeekCheck,
            gameTime: GameState.gameTime,
            transferList: {
              listedPlayers: transferListState.listedPlayers,
              offers: transferListState.offers,
            },
            arena: GameState.arena,
            trainingPoints: GameState.trainingPoints,
          };
          localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
        } catch (e) {}
      }

      function loadGame() {
        try {
          const saved = localStorage.getItem(SAVE_KEY);
          if (!saved) {
            return false;
          }

          const data = JSON.parse(saved);

          if (data.manager) {
            GameState.manager = { ...GameState.manager, ...data.manager };
          }
          if (data.squad) {
            GameState.squad = { ...GameState.squad, ...data.squad };
          }
          if (data.market) {
            GameState.market.cards = data.market.cards || [];
            GameState.market.lastRefresh = data.market.lastRefresh;
          }
          if (data.stats) {
            GameState.stats = { ...GameState.stats, ...data.stats };
          }
          if (data.legends) {
            GameState.legends = data.legends || [];
          }
          if (data.emails) {
            GameState.emails = data.emails || [];
          }
          if (data.lastWeekCheck) {
            GameState.lastWeekCheck = data.lastWeekCheck;
          }
          if (data.gameTime) {
            GameState.gameTime = { ...GameState.gameTime, ...data.gameTime };
          }
          if (data.transferList) {
            transferListState.listedPlayers =
              data.transferList.listedPlayers || [];
            transferListState.offers = data.transferList.offers || [];
          }
          if (data.arena) {
            GameState.arena = { ...GameState.arena, ...data.arena };
          }
          if (data.trainingPoints !== undefined) {
            GameState.trainingPoints = data.trainingPoints;
          }

          return true;
        } catch (e) {
          return false;
        }
      }

      function resetGame() {
        const msg =
          currentLang === "pl"
            ? "Czy na pewno chcesz zresetować wszystkie postępy? Stracisz cały postęp!"
            : "Are you sure you want to reset all progress? You will lose everything!";
        if (confirm(msg)) {
          localStorage.removeItem(SAVE_KEY);
          location.reload();
        }
      }

      // Auto-save after important actions
      function autoSave() {
        saveGame();
      }

      // ==================== COUNTRIES ====================
      const Countries = {
        tier1: ["🇧🇷", "🇦🇷", "🇩🇪", "🇫🇷", "🇪🇸", "🇮🇹", "🇬🇧", "🇳🇱", "🇵🇹", "🇧🇪"],
        tier2: ["🇺🇾", "🇨🇴", "🇲🇽", "🇭🇷", "🇩🇰", "🇨🇭", "🇦🇹", "🇵🇱", "🇸🇪", "🇳🇴"],
        tier3: ["🇺🇸", "🇯🇵", "🇰🇷", "🇦🇺", "🇨🇿", "🇬🇷", "🇷🇸", "🇺🇦", "🇹🇷", "🇷🇴"],
        tier4: ["🇨🇳", "🇮🇳", "🇮🇩", "🇻🇳", "🇹🇭", "🇲🇾", "🇵🇭", "🇿🇦", "🇪🇬", "🇳🇬"],

        getRandomByTier(maxOverall) {
          let tier;
          if (maxOverall >= 85) tier = this.tier1;
          else if (maxOverall >= 70) tier = this.tier2;
          else if (maxOverall >= 50) tier = this.tier3;
          else tier = this.tier4;
          return tier[Math.floor(Math.random() * tier.length)];
        },
      };

      // ==================== POSITIONS ====================
      const Positions = {
        GK: { name: "GK", fullName: "Bramkarz", category: "goalkeeper" },
        CB: { name: "CB", fullName: "Środkowy Obrońca", category: "defender" },
        LB: { name: "LB", fullName: "Lewy Obrońca", category: "defender" },
        RB: { name: "RB", fullName: "Prawy Obrońca", category: "defender" },
        CDM: {
          name: "CDM",
          fullName: "Defensywny Pomocnik",
          category: "midfielder",
        },
        CM: {
          name: "CM",
          fullName: "Środkowy Pomocnik",
          category: "midfielder",
        },
        CAM: {
          name: "CAM",
          fullName: "Ofensywny Pomocnik",
          category: "midfielder",
        },
        LM: { name: "LM", fullName: "Lewy Pomocnik", category: "midfielder" },
        RM: { name: "RM", fullName: "Prawy Pomocnik", category: "midfielder" },
        LW: { name: "LW", fullName: "Lewy Skrzydłowy", category: "attacker" },
        RW: { name: "RW", fullName: "Prawy Skrzydłowy", category: "attacker" },
        ST: { name: "ST", fullName: "Napastnik", category: "attacker" },
        CF: {
          name: "CF",
          fullName: "Środkowy Napastnik",
          category: "attacker",
        },
      };

      // Position change costs (based on similarity)
      const PositionChangeCost = {
        sameCategory: 5000,
        adjacent: 15000, // defender<->midfielder, midfielder<->attacker
        opposite: 50000, // defender<->attacker, goalkeeper<->any
      };

      // ==================== PLAYER STATS ====================
      const StatCategories = {
        goalkeeper: [
          "Diving",
          "Handling",
          "Kicking",
          "Reflexes",
          "Positioning",
          "Speed",
        ],
        outfield: [
          "Pace",
          "Shooting",
          "Passing",
          "Dribbling",
          "Defending",
          "Physical",
        ],
      };

      const SubStats = {
        Pace: [
          "Acceleration",
          "Sprint Speed",
          "Agility",
          "Balance",
          "Stamina",
          "Strength",
          "Jumping",
          "Reactions",
          "Composure",
          "Aggression",
        ],
        Shooting: [
          "Positioning",
          "Finishing",
          "Shot Power",
          "Long Shots",
          "Volleys",
          "Penalties",
          "Heading",
          "Curve",
          "FK Accuracy",
          "Placement",
        ],
        Passing: [
          "Vision",
          "Crossing",
          "Short Pass",
          "Long Pass",
          "Curve",
          "FK Accuracy",
          "Through Ball",
          "Lobbed Pass",
          "Ground Pass",
          "Weighted Pass",
        ],
        Dribbling: [
          "Ball Control",
          "Dribbling",
          "Skill Moves",
          "Flair",
          "Tricks",
          "Body Feints",
          "First Touch",
          "Close Control",
          "Speed Dribbler",
          "Technical",
        ],
        Defending: [
          "Marking",
          "Standing Tackle",
          "Sliding Tackle",
          "Interceptions",
          "Heading",
          "Strength",
          "Aggression",
          "Positioning",
          "Anticipation",
          "Concentration",
        ],
        Physical: [
          "Stamina",
          "Strength",
          "Jumping",
          "Aggression",
          "Balance",
          "Reactions",
          "Composure",
          "Natural Fitness",
          "Work Rate",
          "Determination",
        ],
      };

      // ==================== SURNAMES BY COUNTRY ====================
      const Surnames = {
        "🇧🇷": [
          "Silva",
          "Santos",
          "Oliveira",
          "Souza",
          "Costa",
          "Pereira",
          "Almeida",
          "Ferreira",
          "Rodrigues",
          "Gomes",
          "Neymar",
          "Vinicius",
          "Richarlison",
          "Casemiro",
          "Fabinho",
          "Marquinhos",
          "Thiago",
          "Firmino",
          "Gabriel",
          "Antony",
          "Militao",
          "Paqueta",
          "Raphinha",
          "Martinelli",
          "Rodrygo",
          "Bremer",
          "Danilo",
          "Alex",
          "Wendel",
          "Bruno",
        ],
        "🇦🇷": [
          "González",
          "Rodríguez",
          "Fernández",
          "López",
          "Martínez",
          "García",
          "Pérez",
          "Sánchez",
          "Romero",
          "Díaz",
          "Messi",
          "Alvarez",
          "De Paul",
          "Paredes",
          "Otamendi",
          "Rulli",
          "Montiel",
          "Molina",
          "Tagliafico",
          "Acuña",
          "Mac Allister",
          "Enzo",
          "Lo Celso",
          "Correa",
          "Lautaro",
          "Dybala",
          "Di Maria",
          "Palacios",
          "Garnacho",
          "Foyth",
        ],
        "🇩🇪": [
          "Müller",
          "Schmidt",
          "Schneider",
          "Fischer",
          "Weber",
          "Meyer",
          "Wagner",
          "Becker",
          "Schulz",
          "Hoffmann",
          "Neuer",
          "Kimmich",
          "Gundogan",
          "Havertz",
          "Sane",
          "Gnabry",
          "Musiala",
          "Rudiger",
          "Schlotterbeck",
          "Raum",
          "Fullkrug",
          "Wirtz",
          "Goretzka",
          "Brandt",
          "Werner",
          "Tah",
          "Kroos",
          "Ter Stegen",
          "Reus",
          "Hummels",
        ],
        "🇫🇷": [
          "Martin",
          "Bernard",
          "Dubois",
          "Thomas",
          "Robert",
          "Richard",
          "Petit",
          "Durand",
          "Leroy",
          "Moreau",
          "Mbappe",
          "Griezmann",
          "Giroud",
          "Dembele",
          "Kante",
          "Pogba",
          "Varane",
          "Lloris",
          "Hernandez",
          "Upamecano",
          "Kounde",
          "Rabiot",
          "Tchouameni",
          "Camavinga",
          "Coman",
          "Thuram",
          "Saliba",
          "Maignan",
          "Pavard",
          "Mendy",
        ],
        "🇪🇸": [
          "García",
          "Rodríguez",
          "Martínez",
          "López",
          "González",
          "Hernández",
          "Pérez",
          "Sánchez",
          "Ramírez",
          "Torres",
          "Pedri",
          "Gavi",
          "Rodri",
          "Morata",
          "Alba",
          "Carvajal",
          "Laporte",
          "Busquets",
          "Koke",
          "Ferran",
          "Olmo",
          "Simon",
          "Navas",
          "Llorente",
          "Sarabia",
          "Asensio",
          "Nico",
          "Yeremy",
          "Ansu",
          "Balde",
        ],
        "🇮🇹": [
          "Rossi",
          "Russo",
          "Ferrari",
          "Esposito",
          "Bianchi",
          "Romano",
          "Colombo",
          "Ricci",
          "Marino",
          "Greco",
          "Donnarumma",
          "Bastoni",
          "Barella",
          "Chiesa",
          "Immobile",
          "Insigne",
          "Verratti",
          "Jorginho",
          "Bonucci",
          "Chiellini",
          "Spinazzola",
          "Locatelli",
          "Tonali",
          "Raspadori",
          "Scamacca",
          "Dimarco",
          "Cristante",
          "Pessina",
          "Zaniolo",
          "Pellegrini",
        ],
        "🇬🇧": [
          "Smith",
          "Johnson",
          "Williams",
          "Brown",
          "Jones",
          "Miller",
          "Davis",
          "Wilson",
          "Moore",
          "Taylor",
          "Kane",
          "Sterling",
          "Rashford",
          "Saka",
          "Foden",
          "Bellingham",
          "Rice",
          "Grealish",
          "Maguire",
          "Shaw",
          "Walker",
          "Stones",
          "Pickford",
          "Trippier",
          "Alexander-Arnold",
          "Henderson",
          "Mount",
          "Chilwell",
          "James",
          "Phillips",
        ],
        "🇳🇱": [
          "de Jong",
          "de Vries",
          "van Dijk",
          "van den Berg",
          "Bakker",
          "Janssen",
          "Visser",
          "Smit",
          "Meijer",
          "de Boer",
          "Depay",
          "Gakpo",
          "Dumfries",
          "Blind",
          "de Ligt",
          "Ake",
          "Koopmeiners",
          "Bergwijn",
          "Wijnaldum",
          "Timber",
          "Simons",
          "Weghorst",
          "Gravenberch",
          "Malacia",
          "Frimpong",
          "Berghuis",
          "Klaassen",
          "Til",
          "Lang",
          "Maatsen",
        ],
        "🇵🇹": [
          "Silva",
          "Santos",
          "Ferreira",
          "Pereira",
          "Oliveira",
          "Costa",
          "Rodrigues",
          "Martins",
          "Jesus",
          "Sousa",
          "Ronaldo",
          "Bruno",
          "Bernardo",
          "Cancelo",
          "Dias",
          "Pepe",
          "Leao",
          "Felix",
          "Neves",
          "Carvalho",
          "Otavio",
          "Vitinha",
          "Mendes",
          "Dalot",
          "Patricio",
          "Guerreiro",
          "Horta",
          "Palhinha",
          "Nunes",
          "Ramos",
        ],
        "🇧🇪": [
          "Peeters",
          "Janssens",
          "Maes",
          "Jacobs",
          "Mertens",
          "Willems",
          "Claes",
          "Goossens",
          "Wouters",
          "De Smedt",
          "De Bruyne",
          "Lukaku",
          "Hazard",
          "Courtois",
          "Witsel",
          "Tielemans",
          "Carrasco",
          "Alderweireld",
          "Vertonghen",
          "Dendoncker",
          "Castagne",
          "Meunier",
          "Onana",
          "Doku",
          "Openda",
          "De Ketelaere",
          "Theate",
          "Faes",
          "Trossard",
          "Saelemaekers",
        ],
        "🇵🇱": [
          "Nowak",
          "Kowalski",
          "Wiśniewski",
          "Wójcik",
          "Kowalczyk",
          "Kamiński",
          "Lewandowski",
          "Zieliński",
          "Szymański",
          "Woźniak",
          "Szczęsny",
          "Milik",
          "Glik",
          "Krychowiak",
          "Kiwior",
          "Zalewski",
          "Bednarek",
          "Frankowski",
          "Szczesny",
          "Piatek",
          "Swiderski",
          "Zurkowski",
          "Linetty",
          "Bereszynski",
          "Cash",
          "Grosicki",
          "Moder",
          "Skorupski",
          "Klich",
          "Jozwiak",
        ],
        "🇭🇷": [
          "Horvat",
          "Kovac",
          "Babic",
          "Maric",
          "Juric",
          "Novak",
          "Knezevic",
          "Vukovic",
          "Markovic",
          "Tomic",
          "Modric",
          "Perisic",
          "Kovacic",
          "Brozovic",
          "Kramaric",
          "Gvardiol",
          "Livakovic",
          "Lovren",
          "Rebic",
          "Vlasic",
          "Pasalic",
          "Orsic",
          "Sosa",
          "Stanisic",
          "Juranovic",
          "Vida",
          "Budimir",
          "Majer",
          "Sucic",
          "Pjaca",
        ],
        "🇺🇾": [
          "Rodriguez",
          "Martinez",
          "Garcia",
          "Lopez",
          "Gonzalez",
          "Fernandez",
          "Perez",
          "Sanchez",
          "Diaz",
          "Romero",
          "Suarez",
          "Cavani",
          "Valverde",
          "Nunez",
          "Bentancur",
          "Araujo",
          "Gimenez",
          "Godin",
          "Muslera",
          "Vecino",
          "De Arrascaeta",
          "Nandez",
          "Pellistri",
          "Ugarte",
          "Olivera",
          "Coates",
          "Caceres",
          "Vina",
          "Torreira",
          "Canobbio",
        ],
        "🇨🇴": [
          "Rodriguez",
          "Martinez",
          "Garcia",
          "Lopez",
          "Gonzalez",
          "Hernandez",
          "Diaz",
          "Sanchez",
          "Ramirez",
          "Torres",
          "James",
          "Falcao",
          "Cuadrado",
          "Muriel",
          "Zapata",
          "Ospina",
          "Mina",
          "Arias",
          "Mojica",
          "Borja",
          "Sinisterra",
          "Luis Diaz",
          "Quintero",
          "Barrios",
          "Uribe",
          "Lerma",
          "Moreno",
          "Santos",
          "Cuesta",
          "Lucumi",
        ],
        "🇲🇽": [
          "Garcia",
          "Rodriguez",
          "Martinez",
          "Lopez",
          "Gonzalez",
          "Hernandez",
          "Perez",
          "Sanchez",
          "Ramirez",
          "Torres",
          "Ochoa",
          "Lozano",
          "Jimenez",
          "Alvarez",
          "Herrera",
          "Guardado",
          "Corona",
          "Araujo",
          "Moreno",
          "Gallardo",
          "Vega",
          "Lainez",
          "Antuna",
          "Martin",
          "Gutierrez",
          "Romo",
          "Pineda",
          "Vasquez",
          "Sanchez",
          "Montes",
        ],
        "🇺🇸": [
          "Smith",
          "Johnson",
          "Williams",
          "Brown",
          "Jones",
          "Miller",
          "Davis",
          "Wilson",
          "Moore",
          "Taylor",
          "Pulisic",
          "McKennie",
          "Reyna",
          "Adams",
          "Dest",
          "Musah",
          "Aaronson",
          "Weah",
          "Turner",
          "Robinson",
          "Zimmerman",
          "Richards",
          "Scally",
          "Wright",
          "Ferreira",
          "Morris",
          "Horvath",
          "Steffen",
          "Yedlin",
          "Brooks",
        ],
        "🇯🇵": [
          "Sato",
          "Suzuki",
          "Takahashi",
          "Tanaka",
          "Watanabe",
          "Ito",
          "Yamamoto",
          "Nakamura",
          "Kobayashi",
          "Kato",
          "Kubo",
          "Mitoma",
          "Doan",
          "Kamada",
          "Endo",
          "Tomiyasu",
          "Yoshida",
          "Nagatomo",
          "Minamino",
          "Maeda",
          "Asano",
          "Soma",
          "Ito",
          "Ueda",
          "Osako",
          "Haraguchi",
          "Shibasaki",
          "Morita",
          "Taniguchi",
          "Gonda",
        ],
        "🇰🇷": [
          "Kim",
          "Lee",
          "Park",
          "Choi",
          "Jung",
          "Kang",
          "Cho",
          "Yoon",
          "Jang",
          "Lim",
          "Son",
          "Hwang",
          "Lee Kang-in",
          "Kim Min-jae",
          "Jung Woo-young",
          "Cho Gue-sung",
          "Na Sang-ho",
          "Kwon Chang-hoon",
          "Hong Chul",
          "Kim Young-gwon",
          "Kim Jin-su",
          "Lee Jae-sung",
          "Jeong Woo-yeong",
          "Song Min-kyu",
          "Seol",
          "Paik",
          "Baek",
          "Eom",
          "Yun",
          "Ahn",
        ],
        "🇸🇳": [
          "Diallo",
          "Diop",
          "Ndiaye",
          "Sow",
          "Diouf",
          "Gueye",
          "Sarr",
          "Cisse",
          "Fall",
          "Ba",
          "Mane",
          "Mendy",
          "Koulibaly",
          "Kouyate",
          "Sabaly",
          "Diatta",
          "Bamba",
          "Dia",
          "Gomis",
          "Pape",
          "Ismaila",
          "Krepin",
          "Abdou",
          "Nampalys",
          "Alfred",
          "Iliman",
          "Moussa",
          "Saliou",
          "Famara",
          "Habib",
        ],
        "🇳🇬": [
          "Okafor",
          "Okonkwo",
          "Ibrahim",
          "Mohammed",
          "Adeyemi",
          "Obi",
          "Eze",
          "Chukwu",
          "Nwankwo",
          "Aminu",
          "Osimhen",
          "Iwobi",
          "Ndidi",
          "Lookman",
          "Simon",
          "Awoniyi",
          "Aribo",
          "Ekong",
          "Omeruo",
          "Bassey",
          "Zaidu",
          "Chukwueze",
          "Kalu",
          "Onyeka",
          "Nwabali",
          "Dennis",
          "Uzoho",
          "Success",
          "Ejuke",
          "Balogun",
        ],
        "🇨🇲": [
          "Nkoulou",
          "Mboma",
          "Eto'o",
          "Onana",
          "Milla",
          "Song",
          "Foe",
          "Bassogog",
          "Toko",
          "Choupo",
          "Aboubakar",
          "Choupo-Moting",
          "Toko Ekambi",
          "Hongla",
          "Zambo",
          "Anguissa",
          "Ntcham",
          "Ngamaleu",
          "Kunde",
          "Nkoudou",
          "Moumi",
          "Fai",
          "Ganago",
          "Mbeumo",
          "Marou",
          "Nlend",
          "Wooh",
          "Moukoudi",
          "Ondoa",
          "Castelletto",
        ],
        "🇲🇦": [
          "Alaoui",
          "Bennani",
          "Tazi",
          "Idrissi",
          "Berrada",
          "Fassi",
          "Chraibi",
          "Benjelloun",
          "Lahlou",
          "Kettani",
          "Hakimi",
          "Ziyech",
          "Amrabat",
          "Mazraoui",
          "Bounou",
          "Aguerd",
          "Saiss",
          "Ounahi",
          "Boufal",
          "En-Nesyri",
          "El Yamiq",
          "Dari",
          "Amallah",
          "Chair",
          "Cheddira",
          "Harit",
          "Aboukhlal",
          "Regragui",
          "Sabiri",
          "Louza",
        ],
        "🇩🇰": [
          "Jensen",
          "Nielsen",
          "Hansen",
          "Pedersen",
          "Andersen",
          "Christensen",
          "Larsen",
          "Sorensen",
          "Rasmussen",
          "Petersen",
          "Eriksen",
          "Hojbjerg",
          "Schmeichel",
          "Kjaer",
          "Maehle",
          "Dolberg",
          "Damsgaard",
          "Skov",
          "Wind",
          "Braithwaite",
          "Lindstrom",
          "Hjulmand",
          "Norgaard",
          "Wass",
          "Vestergaard",
          "Poulsen",
          "Cornelius",
          "Delaney",
          "Jorgensen",
          "Kristensen",
        ],
        "🇨🇭": [
          "Muller",
          "Schmid",
          "Keller",
          "Weber",
          "Huber",
          "Meyer",
          "Steiner",
          "Fischer",
          "Gerber",
          "Brunner",
          "Shaqiri",
          "Xhaka",
          "Sommer",
          "Akanji",
          "Embolo",
          "Freuler",
          "Rodriguez",
          "Seferovic",
          "Elvedi",
          "Widmer",
          "Vargas",
          "Zuber",
          "Zakaria",
          "Okafor",
          "Ndoye",
          "Aebischer",
          "Kobel",
          "Rieder",
          "Mvogo",
          "Omlin",
        ],
        "🇦🇹": [
          "Gruber",
          "Huber",
          "Wagner",
          "Muller",
          "Pichler",
          "Steiner",
          "Moser",
          "Mayer",
          "Hofer",
          "Leitner",
          "Alaba",
          "Arnautovic",
          "Sabitzer",
          "Laimer",
          "Schlager",
          "Baumgartner",
          "Lindner",
          "Lainer",
          "Hinteregger",
          "Trimmel",
          "Kalajdzic",
          "Onisiwo",
          "Gregoritsch",
          "Posch",
          "Wober",
          "Grillitsch",
          "Seiwald",
          "Prass",
          "Pentz",
          "Entrup",
        ],
        "🇷🇸": [
          "Jovanovic",
          "Petrovic",
          "Nikolic",
          "Markovic",
          "Djordjevic",
          "Stankovic",
          "Ilic",
          "Popovic",
          "Pavlovic",
          "Todorovic",
          "Vlahovic",
          "Tadic",
          "Mitrovic",
          "Kostic",
          "Milinkovic-Savic",
          "Jovic",
          "Gudelj",
          "Pavlovic",
          "Veljkovic",
          "Zivkovic",
          "Lazovic",
          "Lukic",
          "Maksimovic",
          "Rajkovic",
          "Grujic",
          "Gacinovic",
          "Matic",
          "Sergej",
          "Radonjic",
          "Samardzic",
        ],
        "🇹🇷": [
          "Yilmaz",
          "Kaya",
          "Demir",
          "Celik",
          "Ozturk",
          "Sahin",
          "Arslan",
          "Dogan",
          "Kilic",
          "Aydin",
          "Calhanoglu",
          "Under",
          "Yildirim",
          "Soyuncu",
          "Kokcu",
          "Akturkoglu",
          "Yazici",
          "Kahveci",
          "Unal",
          "Bayindir",
          "Muldur",
          "Ozcan",
          "Ayhan",
          "Demiral",
          "Kabak",
          "Cakir",
          "Erkin",
          "Topal",
          "Karaman",
          "Arda",
        ],
        default: [
          "Smith",
          "Johnson",
          "Williams",
          "Brown",
          "Jones",
          "Garcia",
          "Miller",
          "Davis",
          "Rodriguez",
          "Martinez",
          "Hernandez",
          "Lopez",
          "Gonzalez",
          "Wilson",
          "Anderson",
          "Thomas",
          "Taylor",
          "Moore",
          "Jackson",
          "Martin",
          "Lee",
          "Perez",
          "Thompson",
          "White",
          "Harris",
          "Sanchez",
          "Clark",
          "Lewis",
          "Robinson",
          "Walker",
        ],
      };

      function getRandomSurname(country) {
        const surnames = Surnames[country] || Surnames["default"];
        return surnames[Math.floor(Math.random() * surnames.length)];
      }

      // ==================== PLAYER GENERATOR ====================
      function generatePlayer(overall = 40, position = null, age = null) {
        const pos =
          position ||
          Object.keys(Positions)[
            Math.floor(Math.random() * Object.keys(Positions).length)
          ];
        const posData = Positions[pos];
        const country = Countries.getRandomByTier(overall);
        const surname = getRandomSurname(country);

        const isGK = posData.category === "goalkeeper";
        const statNames = isGK
          ? StatCategories.goalkeeper
          : StatCategories.outfield;

        // Random age (17-34 for new players)
        const playerAge = age || 17 + Math.floor(Math.random() * 17);

        // Generate main stats
        const stats = {};
        statNames.forEach((stat) => {
          // Random variation around overall
          const variation = Math.floor(Math.random() * 20) - 10;
          stats[stat] = Math.max(1, Math.min(99, overall + variation));
        });

        // Generate substats for non-GK
        const subStats = {};
        if (!isGK) {
          Object.keys(SubStats).forEach((mainStat) => {
            subStats[mainStat] = {};
            SubStats[mainStat].forEach((sub) => {
              const variation = Math.floor(Math.random() * 15) - 7;
              subStats[mainStat][sub] = Math.max(
                1,
                Math.min(99, (stats[mainStat] || overall) + variation)
              );
            });
          });
        }

        return {
          id: Date.now() + Math.random(),
          name: surname,
          country: country,
          position: pos,
          positions: [pos], // Can unlock more
          overall: overall,
          stats: stats,
          subStats: subStats,
          isIcon: overall >= 100,
          styleOfPlay: null,
          age: playerAge,
          gamesPlayed: 0,
          salary: Math.floor(overall * 50 + Math.random() * overall * 20), // Weekly salary based on overall
          contractYears: 1 + Math.floor(Math.random() * 3), // 1-3 years
          matchRatings: [], // Array of match ratings (0-10)
          goals: 0, // Total goals scored
          assists: 0, // Total assists
          cleanSheets: 0, // For GK - clean sheets
          saves: 0, // For GK - total saves
        };
      }

      // ==================== AGING SYSTEM ====================
      function getMaxOverallByAge(age, isGK = false) {
        // Icons don't degrade until 38
        // Normal players start degrading at 35
        if (age < 35) return 99;
        if (age === 35) return 95;
        if (age === 36) return 90;
        if (age === 37) return 85;
        if (age === 38) return isGK ? 85 : 80;
        if (age === 39) return isGK ? 82 : 75;
        if (age === 40) return isGK ? 80 : 70;
        if (age === 41) return isGK ? 77 : 65;
        if (age === 42) return isGK ? 75 : 60;
        if (age === 43) return isGK ? 72 : 55;
        if (age === 44) return isGK ? 70 : 50;
        return isGK ? 65 : 45;
      }

      function shouldRetire(player) {
        const isGK = player.position === "GK";
        const minRetireAge = isGK ? 40 : 38;
        const maxRetireAge = isGK ? 45 : 42;

        if (player.age < minRetireAge) return false;
        if (player.age >= maxRetireAge) return true;

        // Random chance between min and max age
        const retireChance =
          (player.age - minRetireAge) / (maxRetireAge - minRetireAge);
        return Math.random() < retireChance * 0.5;
      }

      function agePlayer(player) {
        if (!player) return null;

        player.age = (player.age || 25) + 1;
        player.gamesPlayed = player.gamesPlayed || 0;

        const isGK = player.position === "GK";
        const maxOvr = getMaxOverallByAge(player.age, isGK);

        // Icons only start degrading at 38
        if (player.isIcon && player.age < 38) {
          return player; // No degradation yet
        }

        // Apply stat degradation
        if (player.overall > maxOvr) {
          const degradation = Math.min(5, player.overall - maxOvr);
          player.overall = Math.max(maxOvr, player.overall - degradation);

          // Reduce stats
          Object.keys(player.stats).forEach((stat) => {
            if (player.stats[stat] > maxOvr) {
              player.stats[stat] = Math.max(
                maxOvr,
                player.stats[stat] - degradation
              );
            }
          });
        }

        return player;
      }

      function processSeasonEnd() {
        const retiredPlayers = [];
        const retiredLegends = [];

        // Age all players
        [...GameState.squad.players, ...GameState.squad.bench].forEach(
          (player) => {
            if (!player) return;

            agePlayer(player);

            // Check retirement
            if (shouldRetire(player)) {
              if (player.isIcon || player.overall >= 90) {
                retiredLegends.push({ ...player, retiredAt: player.age });
                GameState.legends.push({ ...player, retiredAt: player.age });
              }
              retiredPlayers.push(player);
            }
          }
        );

        // Remove retired players and add replacements
        retiredPlayers.forEach((retired) => {
          let idx = GameState.squad.players.findIndex(
            (p) => p?.id === retired.id
          );
          if (idx !== -1) {
            GameState.squad.players[idx] = generatePlayer(
              40,
              retired.position,
              18
            );
          } else {
            idx = GameState.squad.bench.findIndex((p) => p?.id === retired.id);
            if (idx !== -1) {
              GameState.squad.bench[idx] = generatePlayer(
                40,
                retired.position,
                18
              );
            }
          }
        });

        // Show notifications
        retiredPlayers.forEach((p) => {
          if (retiredLegends.find((l) => l.id === p.id)) {
            alert(`${p.name} ${t("retiredLegend")}`);
          } else {
            alert(`${p.name} ${t("retired")}\n${t("newPlayer")}`);
          }
        });

        updateSquadOverall();
        autoSave();
      }

      // ==================== CARD TIER ====================
      function getCardTier(overall) {
        if (overall >= 100) return "icon";
        if (overall >= 86) return "elite";
        if (overall >= 61) return "gold";
        if (overall >= 41) return "silver";
        return "bronze";
      }

      function getRarityFromOverall(overall) {
        if (overall >= 95) return "icon";
        if (overall >= 88) return "legendary";
        if (overall >= 82) return "epic";
        if (overall >= 75) return "rare";
        if (overall >= 65) return "uncommon";
        return "common";
      }

      // ==================== INITIALIZE SQUAD ====================
      function initializeSquad() {
        const positions = [
          "GK",
          "LB",
          "CB",
          "CB",
          "RB",
          "CM",
          "CM",
          "CM",
          "LW",
          "ST",
          "RW",
        ];
        // Start with all 40 OVR players
        GameState.squad.players = positions.map((pos) =>
          generatePlayer(40, pos)
        );

        // Bench players - also 40 OVR
        const benchPositions = ["GK", "CB", "CM", "CM", "ST", "LW", "RW"];
        GameState.squad.bench = benchPositions.map((pos) =>
          generatePlayer(40, pos)
        );

        // Reset training points for new game
        GameState.trainingPoints = 0;

        updateSquadOverall();
      }

      // ==================== CALCULATE OVERALL ====================
      function updateSquadOverall() {
        const players = GameState.squad.players.filter((p) => p);

        const atkEl = document.getElementById("squadATK");
        const midEl = document.getElementById("squadMID");
        const defEl = document.getElementById("squadDEF");
        const ovrEl = document.getElementById("squadOverall");

        if (!ovrEl) return; // Elements not ready yet

        if (players.length === 0) {
          if (ovrEl) ovrEl.textContent = "0";
          if (atkEl) atkEl.textContent = "0";
          if (midEl) midEl.textContent = "0";
          if (defEl) defEl.textContent = "0";
          return;
        }

        // Position categories
        const attackers = ["ST", "CF", "LW", "RW"];
        const midfielders = ["CM", "CDM", "CAM", "LM", "RM"];
        const defenders = ["CB", "LB", "RB", "LWB", "RWB"];

        let totalATK = 0,
          atkCount = 0;
        let totalMID = 0,
          midCount = 0;
        let totalDEF = 0,
          defCount = 0;

        players.forEach((p) => {
          const stats = p.stats || {};
          const pos = p.position;

          if (pos === "GK") {
            // GK contributes to DEF
            const gkAvg =
              ((stats.Diving || p.overall) +
                (stats.Handling || p.overall) +
                (stats.Reflexes || p.overall) +
                (stats.Positioning || p.overall)) /
              4;
            totalDEF += gkAvg;
            defCount++;
          } else if (attackers.includes(pos)) {
            // Attackers: Pace, Shooting, Dribbling
            const atkAvg =
              ((stats.Pace || p.overall) +
                (stats.Shooting || p.overall) +
                (stats.Dribbling || p.overall)) /
              3;
            totalATK += atkAvg;
            atkCount++;
          } else if (midfielders.includes(pos)) {
            // Midfielders: Passing, Dribbling, Shooting, Physical
            const midAvg =
              ((stats.Passing || p.overall) +
                (stats.Dribbling || p.overall) +
                (stats.Shooting || p.overall) +
                (stats.Physical || p.overall)) /
              4;
            totalMID += midAvg;
            midCount++;
          } else if (defenders.includes(pos)) {
            // Defenders: Defending, Physical, Pace
            const defAvg =
              ((stats.Defending || p.overall) +
                (stats.Physical || p.overall) +
                (stats.Pace || p.overall)) /
              3;
            totalDEF += defAvg;
            defCount++;
          } else {
            // Unknown position - use overall
            totalMID += p.overall;
            midCount++;
          }
        });

        const avgATK = atkCount > 0 ? Math.round(totalATK / atkCount) : 0;
        const avgMID = midCount > 0 ? Math.round(totalMID / midCount) : 0;
        const avgDEF = defCount > 0 ? Math.round(totalDEF / defCount) : 0;

        // OVR = średnia z ATK, MID i DEF
        const validCounts =
          (atkCount > 0 ? 1 : 0) +
          (midCount > 0 ? 1 : 0) +
          (defCount > 0 ? 1 : 0);
        const avgOVR =
          validCounts > 0
            ? Math.round((avgATK + avgMID + avgDEF) / validCounts)
            : 0;

        if (atkEl) atkEl.textContent = avgATK;
        if (midEl) midEl.textContent = avgMID;
        if (defEl) defEl.textContent = avgDEF;
        if (ovrEl) ovrEl.textContent = avgOVR;
      }

      // ==================== RENDER PLAYER CARD ====================
      function renderPlayerCard(player, small = false, noFlip = false) {
        if (!player) return '<div class="player-card">Brak</div>';

        const tier = getCardTier(player.overall || 50);
        const statNames =
          player.position === "GK"
            ? StatCategories.goalkeeper
            : StatCategories.outfield;
        const positions = player.positions || [player.position || "CM"];
        const stats = player.stats || {};
        const age = player.age || 25;

        // Get translated position name
        const posFullName = getPositionFullName(player.position);
        const positionsTranslated = positions
          .map((p) => getPositionFullName(p))
          .join(", ");

        // Calculate average rating
        const avgRating = getAverageRating(player);
        const ratingDisplay = avgRating !== null ? avgRating.toFixed(1) : "-";
        const ratingColor =
          avgRating !== null ? getRatingColor(avgRating) : "#888";

        // Check if injured
        const injured = isPlayerInjured(player);
        const injuryHours = injured ? getInjuryTimeRemaining(player) : 0;

        const flipAttr = noFlip ? "" : 'onclick="flipCard(this)"';

        const html = `
                <div class="player-card tier-${tier} ${
          injured ? "injured" : ""
        }" ${flipAttr}>
                    <div class="player-card-inner">
                        <div class="player-card-front">
                            ${
                              injured
                                ? `<div class="injury-badge">🏥 ${t(
                                    "injured"
                                  )}</div>`
                                : ""
                            }
                            <div style="display: flex; justify-content: space-between; width: 100%;">
                                <div class="card-overall">${
                                  player.overall || 50
                                }</div>
                                <div class="card-position">${
                                  player.position || "CM"
                                }</div>
                            </div>
                            <div class="card-player-silhouette">⚽</div>
                            <div class="card-country">${
                              player.country || "🌍"
                            }</div>
                            <div class="card-stats-mini">
                                ${statNames
                                  .slice(0, 6)
                                  .map(
                                    (stat) => `
                                    <div class="stat-mini">
                                        <div class="stat-mini-value">${
                                          stats[stat] || player.overall || "-"
                                        }</div>
                                        <div>${stat
                                          .substring(0, 3)
                                          .toUpperCase()}</div>
                                    </div>
                                `
                                  )
                                  .join("")}
                            </div>
                        </div>
                        <div class="player-card-back">
                            <div class="card-name-back">${
                              player.name || "Nieznany"
                            }</div>
                            <div class="card-details-back">
                                ${player.country || "🌍"} | ${posFullName}
                            </div>
                            ${
                              injured
                                ? `
                                <div style="margin-top: 0.3rem; font-size: 0.7rem; color: #ff4444; font-weight: bold;">
                                    🏥 ${t("playerInjured")} (${injuryHours}h)
                                </div>
                            `
                                : ""
                            }
                            <div style="margin-top: 0.3rem; font-size: 0.7rem; color: var(--gold);">
                                ${t("age")}: ${age}
                            </div>
                            <div style="margin-top: 0.3rem; font-size: 0.7rem; color: var(--silver);">
                                ${t("positions")}: ${positionsTranslated}
                            </div>
                            <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.2);">
                                <div style="display: flex; justify-content: center; align-items: center; gap: 0.3rem;">
                                    <span style="font-size: 0.65rem; color: var(--silver);">⭐ ${t(
                                      "avgRating"
                                    )}:</span>
                                    <span style="font-size: 0.9rem; font-weight: bold; color: ${ratingColor};">${ratingDisplay}</span>
                                </div>
                                ${
                                  player.position === "GK"
                                    ? `
                                    <div style="font-size: 0.6rem; color: #888; margin-top: 0.2rem;">
                                        🧤 ${player.saves || 0} ${t(
                                        "saves"
                                      )} | 🚫 ${player.cleanSheets || 0} ${t(
                                        "cleanSheets"
                                      )}
                                    </div>
                                `
                                    : `
                                    <div style="font-size: 0.6rem; color: #888; margin-top: 0.2rem;">
                                        ⚽ ${player.goals || 0} ${t(
                                        "goals"
                                      )} | 🅰️ ${player.assists || 0} ${t(
                                        "assists"
                                      )}
                                    </div>
                                `
                                }
                            </div>
                        </div>
                    </div>
                </div>
            `;
        return html;
      }

      function getAverageRating(player) {
        if (!player.matchRatings || player.matchRatings.length === 0) {
          return null;
        }
        const sum = player.matchRatings.reduce((a, b) => a + b, 0);
        return sum / player.matchRatings.length;
      }

      function getRatingColor(rating) {
        if (rating >= 8) return "#4CAF50"; // Green - excellent
        if (rating >= 7) return "#8BC34A"; // Light green - good
        if (rating >= 6) return "#FFC107"; // Yellow - average
        if (rating >= 5) return "#FF9800"; // Orange - below average
        return "#f44336"; // Red - poor
      }

      function getPositionFullName(pos) {
        const positionNames = {
          pl: {
            GK: "Bramkarz",
            CB: "Środkowy Obrońca",
            LB: "Lewy Obrońca",
            RB: "Prawy Obrońca",
            LWB: "Lewy Wahadłowy",
            RWB: "Prawy Wahadłowy",
            CDM: "Defensywny Pomocnik",
            CM: "Środkowy Pomocnik",
            CAM: "Ofensywny Pomocnik",
            LM: "Lewy Pomocnik",
            RM: "Prawy Pomocnik",
            LW: "Lewy Skrzydłowy",
            RW: "Prawy Skrzydłowy",
            ST: "Napastnik",
            CF: "Środkowy Napastnik",
          },
          en: {
            GK: "Goalkeeper",
            CB: "Center Back",
            LB: "Left Back",
            RB: "Right Back",
            LWB: "Left Wing Back",
            RWB: "Right Wing Back",
            CDM: "Defensive Midfielder",
            CM: "Central Midfielder",
            CAM: "Attacking Midfielder",
            LM: "Left Midfielder",
            RM: "Right Midfielder",
            LW: "Left Winger",
            RW: "Right Winger",
            ST: "Striker",
            CF: "Center Forward",
          },
        };

        return (
          positionNames[currentLang]?.[pos] || positionNames["en"][pos] || pos
        );
      }

      function flipCard(element) {
        element.classList.toggle("flipped");
      }

      // ==================== FORMATIONS ====================
      const Formations = {
        "4-3-3": [
          { pos: "GK", x: 50, y: 92 },
          { pos: "LB", x: 15, y: 75 },
          { pos: "CB", x: 35, y: 80 },
          { pos: "CB", x: 65, y: 80 },
          { pos: "RB", x: 85, y: 75 },
          { pos: "CM", x: 25, y: 55 },
          { pos: "CM", x: 50, y: 50 },
          { pos: "CM", x: 75, y: 55 },
          { pos: "LW", x: 15, y: 25 },
          { pos: "ST", x: 50, y: 15 },
          { pos: "RW", x: 85, y: 25 },
        ],
        "4-4-2": [
          { pos: "GK", x: 50, y: 92 },
          { pos: "LB", x: 15, y: 75 },
          { pos: "CB", x: 35, y: 80 },
          { pos: "CB", x: 65, y: 80 },
          { pos: "RB", x: 85, y: 75 },
          { pos: "LM", x: 15, y: 50 },
          { pos: "CM", x: 35, y: 55 },
          { pos: "CM", x: 65, y: 55 },
          { pos: "RM", x: 85, y: 50 },
          { pos: "ST", x: 35, y: 20 },
          { pos: "ST", x: 65, y: 20 },
        ],
        "3-5-2": [
          { pos: "GK", x: 50, y: 92 },
          { pos: "CB", x: 25, y: 80 },
          { pos: "CB", x: 50, y: 82 },
          { pos: "CB", x: 75, y: 80 },
          { pos: "LM", x: 10, y: 55 },
          { pos: "CM", x: 30, y: 55 },
          { pos: "CDM", x: 50, y: 60 },
          { pos: "CM", x: 70, y: 55 },
          { pos: "RM", x: 90, y: 55 },
          { pos: "ST", x: 35, y: 20 },
          { pos: "ST", x: 65, y: 20 },
        ],
        "4-2-3-1": [
          { pos: "GK", x: 50, y: 92 },
          { pos: "LB", x: 15, y: 75 },
          { pos: "CB", x: 35, y: 80 },
          { pos: "CB", x: 65, y: 80 },
          { pos: "RB", x: 85, y: 75 },
          { pos: "CDM", x: 35, y: 60 },
          { pos: "CDM", x: 65, y: 60 },
          { pos: "LW", x: 20, y: 40 },
          { pos: "CAM", x: 50, y: 35 },
          { pos: "RW", x: 80, y: 40 },
          { pos: "ST", x: 50, y: 15 },
        ],
        "5-3-2": [
          { pos: "GK", x: 50, y: 92 },
          { pos: "LB", x: 10, y: 70 },
          { pos: "CB", x: 30, y: 80 },
          { pos: "CB", x: 50, y: 82 },
          { pos: "CB", x: 70, y: 80 },
          { pos: "RB", x: 90, y: 70 },
          { pos: "CM", x: 30, y: 50 },
          { pos: "CM", x: 50, y: 45 },
          { pos: "CM", x: 70, y: 50 },
          { pos: "ST", x: 35, y: 20 },
          { pos: "ST", x: 65, y: 20 },
        ],
      };

      // ==================== RENDER PITCH ====================
      function renderPitch() {
        const container = document.getElementById("pitchContainer");
        const formation = Formations[GameState.squad.formation];

        // Remove old slots
        container.querySelectorAll(".pitch-slot").forEach((el) => el.remove());

        // Add new slots
        formation.forEach((slot, index) => {
          const div = document.createElement("div");
          div.className = "pitch-slot";
          div.style.left = `${slot.x}%`;
          div.style.top = `${slot.y}%`;
          div.style.transform = "translate(-50%, -50%)";
          div.dataset.slotIndex = index;
          div.dataset.slotType = "squad";

          const player = GameState.squad.players[index];
          if (player) {
            div.classList.add("filled");
            div.draggable = true;
            div.dataset.playerId = player.id;
            const tier = getCardTier(player.overall);

            // Check if player is on wrong position
            const isWrongPosition = !player.positions.includes(slot.pos);
            const warningHTML = isWrongPosition
              ? '<div class="position-warning">!</div>'
              : "";

            div.innerHTML = `
                        <div class="player-mini" style="background: ${getTierColor(
                          tier
                        )}">
                            <div class="player-mini-overall">${
                              player.overall
                            }</div>
                            <div>${player.position}</div>
                        </div>
                        ${warningHTML}
                    `;

            // Drag events
            div.ondragstart = (e) => handleDragStart(e, "squad", index, player);
            div.ondragend = handleDragEnd;
          } else {
            div.textContent = slot.pos;
          }

          // Drop events (for all slots)
          div.ondragover = (e) => handleDragOver(e);
          div.ondragleave = handleDragLeave;
          div.ondrop = (e) => handleDrop(e, "squad", index);

          div.onclick = () => selectSlot(index, slot.pos);
          container.appendChild(div);
        });

        // Render bench
        renderBench();
      }

      // ==================== DRAG & DROP ====================
      let draggedPlayer = null;
      let draggedFrom = null;
      let draggedIndex = null;

      function handleDragStart(e, type, index, player) {
        draggedPlayer = player;
        draggedFrom = type;
        draggedIndex = index;
        e.target.classList.add("dragging");
        e.dataTransfer.effectAllowed = "move";
      }

      function handleDragEnd(e) {
        e.target.classList.remove("dragging");
        document
          .querySelectorAll(".drag-over")
          .forEach((el) => el.classList.remove("drag-over"));
      }

      function handleDragOver(e) {
        e.preventDefault();
        e.currentTarget.classList.add("drag-over");
      }

      function handleDragLeave(e) {
        e.currentTarget.classList.remove("drag-over");
      }

      function handleDrop(e, targetType, targetIndex) {
        e.preventDefault();
        e.currentTarget.classList.remove("drag-over");

        if (!draggedPlayer) return;

        // Get target player (if any)
        let targetPlayer = null;
        if (targetType === "squad") {
          targetPlayer = GameState.squad.players[targetIndex];
        } else {
          targetPlayer = GameState.squad.bench[targetIndex];
        }

        // Perform swap or move
        if (draggedFrom === "squad" && targetType === "squad") {
          // Squad to squad swap
          GameState.squad.players[draggedIndex] = targetPlayer;
          GameState.squad.players[targetIndex] = draggedPlayer;
        } else if (draggedFrom === "bench" && targetType === "bench") {
          // Bench to bench swap
          GameState.squad.bench[draggedIndex] = targetPlayer;
          GameState.squad.bench[targetIndex] = draggedPlayer;
        } else if (draggedFrom === "squad" && targetType === "bench") {
          // Squad to bench
          GameState.squad.players[draggedIndex] = targetPlayer;
          if (targetPlayer) {
            GameState.squad.bench[targetIndex] = draggedPlayer;
          } else {
            // Empty bench slot - just move
            GameState.squad.bench[targetIndex] = draggedPlayer;
          }
        } else if (draggedFrom === "bench" && targetType === "squad") {
          // Bench to squad
          GameState.squad.bench[draggedIndex] = targetPlayer;
          GameState.squad.players[targetIndex] = draggedPlayer;
        }

        // Reset drag state
        draggedPlayer = null;
        draggedFrom = null;
        draggedIndex = null;

        // Re-render and save
        renderPitch();
        updateSquadOverall();
        autoSave();
      }

      // ==================== RENDER BENCH ====================
      function renderBench() {
        const container = document.getElementById("benchPlayers");
        container.innerHTML = "";

        GameState.squad.bench.forEach((player, index) => {
          if (!player) return; // Skip null players

          const div = document.createElement("div");
          div.className = "bench-slot filled";
          div.dataset.slotIndex = index;
          div.dataset.slotType = "bench";
          div.draggable = true;
          div.dataset.playerId = player.id;
          const tier = getCardTier(player.overall);

          div.innerHTML = `
                    <div class="player-mini" style="background: ${getTierColor(
                      tier
                    )}">
                        <div class="player-mini-overall">${player.overall}</div>
                        <div>${player.position}</div>
                    </div>
                `;

          // Drag events
          div.ondragstart = (e) => handleDragStart(e, "bench", index, player);
          div.ondragend = handleDragEnd;
          div.ondragover = (e) => handleDragOver(e);
          div.ondragleave = handleDragLeave;
          div.ondrop = (e) => handleDrop(e, "bench", index);

          div.onclick = () => selectBenchPlayer(index);
          container.appendChild(div);
        });

        // Add empty slots for dropping
        const maxBench = 12;
        for (let i = GameState.squad.bench.length; i < maxBench; i++) {
          const emptySlot = document.createElement("div");
          emptySlot.className = "bench-slot";
          emptySlot.dataset.slotIndex = i;
          emptySlot.dataset.slotType = "bench";
          emptySlot.innerHTML = "+";
          emptySlot.style.fontSize = "1.5rem";
          emptySlot.style.color = "var(--gold)";

          // Drop events for empty slots
          emptySlot.ondragover = (e) => handleDragOver(e);
          emptySlot.ondragleave = handleDragLeave;
          emptySlot.ondrop = (e) => handleDropToEmptyBench(e, i);

          container.appendChild(emptySlot);
        }
      }

      function handleDropToEmptyBench(e, targetIndex) {
        e.preventDefault();
        e.currentTarget.classList.remove("drag-over");

        if (!draggedPlayer) return;

        if (draggedFrom === "squad") {
          // Move from squad to empty bench slot
          GameState.squad.players[draggedIndex] = null;
          // Add to bench at end
          GameState.squad.bench.push(draggedPlayer);
        } else if (draggedFrom === "bench") {
          // Reorder within bench - move to new position
          GameState.squad.bench.splice(draggedIndex, 1);
          GameState.squad.bench.splice(targetIndex, 0, draggedPlayer);
        }

        // Reset drag state
        draggedPlayer = null;
        draggedFrom = null;
        draggedIndex = null;

        // Re-render and save
        renderPitch();
        updateSquadOverall();
        autoSave();
      }

      // ==================== PLAYER SELECTION ====================
      let selectedSlotIndex = null;
      let selectedSlotPosition = null;
      let selectingFromBench = false;
      let selectedBenchIndex = null;

      function selectSlot(index, requiredPosition) {
        selectedSlotIndex = index;
        selectedSlotPosition = requiredPosition;
        selectingFromBench = false;

        document.getElementById(
          "slotInfo"
        ).textContent = `Pozycja: ${requiredPosition}`;
        renderPlayerSelectList("squad");
        document.getElementById("playerSelectModal").classList.add("active");
      }

      function selectBenchPlayer(index) {
        selectedBenchIndex = index;
        selectingFromBench = true;

        const player = GameState.squad.bench[index];
        document.getElementById(
          "slotInfo"
        ).textContent = `${player.name} (${player.position})`;
        renderPlayerSelectList("squad");
        document.getElementById("playerSelectModal").classList.add("active");
      }

      function renderPlayerSelectList(tab) {
        const container = document.getElementById("playerSelectList");
        container.innerHTML = "";

        // Update tabs
        document.querySelectorAll(".player-tab").forEach((t) => {
          t.classList.toggle("active", t.dataset.tab === tab);
        });

        const players =
          tab === "squad" ? GameState.squad.players : GameState.squad.bench;

        players.forEach((player, index) => {
          if (!player) return;

          const div = document.createElement("div");
          div.className = "player-select-item";

          // Check if this is the current player in the slot
          const isCurrent =
            !selectingFromBench &&
            tab === "squad" &&
            index === selectedSlotIndex;
          if (isCurrent) {
            div.classList.add("current");
          }

          // Check if wrong position for selected slot
          const isWrongPos =
            selectedSlotPosition &&
            !player.positions.includes(selectedSlotPosition);

          div.innerHTML = `
                    ${
                      isCurrent
                        ? '<div class="select-badge">AKTUALNY</div>'
                        : ""
                    }
                    ${renderPlayerCard(player, true)}
                    ${
                      isWrongPos && !selectingFromBench
                        ? '<div class="wrong-pos-badge">⚠️ ZŁA POZYCJA</div>'
                        : ""
                    }
                `;

          div.onclick = () => {
            if (selectingFromBench) {
              // Swap bench player with squad player
              swapBenchWithSquad(selectedBenchIndex, index, tab);
            } else {
              // Put this player in the selected slot
              putPlayerInSlot(index, tab);
            }
          };

          container.appendChild(div);
        });
      }

      function putPlayerInSlot(playerIndex, fromTab) {
        const formation = Formations[GameState.squad.formation];

        if (fromTab === "squad") {
          // Swap players within squad
          const temp = GameState.squad.players[selectedSlotIndex];
          GameState.squad.players[selectedSlotIndex] =
            GameState.squad.players[playerIndex];
          GameState.squad.players[playerIndex] = temp;
        } else {
          // Swap with bench
          const temp = GameState.squad.players[selectedSlotIndex];
          GameState.squad.players[selectedSlotIndex] =
            GameState.squad.bench[playerIndex];
          GameState.squad.bench[playerIndex] = temp;
        }

        closePlayerSelect();
        renderPitch();
        updateSquadOverall();
        autoSave(); // Save after squad change
      }

      function swapBenchWithSquad(benchIndex, squadIndex, tab) {
        if (tab === "squad") {
          // Swap bench with squad
          const temp = GameState.squad.bench[benchIndex];
          GameState.squad.bench[benchIndex] =
            GameState.squad.players[squadIndex];
          GameState.squad.players[squadIndex] = temp;
        } else {
          // Swap within bench
          const temp = GameState.squad.bench[benchIndex];
          GameState.squad.bench[benchIndex] = GameState.squad.bench[squadIndex];
          GameState.squad.bench[squadIndex] = temp;
        }

        closePlayerSelect();
        renderPitch();
        updateSquadOverall();
        autoSave(); // Save after squad change
      }

      function closePlayerSelect() {
        document.getElementById("playerSelectModal").classList.remove("active");
        selectedSlotIndex = null;
        selectedSlotPosition = null;
        selectingFromBench = false;
        selectedBenchIndex = null;
      }

      // Tab switching
      document.addEventListener("click", (e) => {
        if (e.target.classList.contains("player-tab")) {
          renderPlayerSelectList(e.target.dataset.tab);
        }
      });

      function getTierColor(tier) {
        const colors = {
          bronze: "linear-gradient(135deg, #cd7f32, #a0522d)",
          silver: "linear-gradient(135deg, #c0c0c0, #808080)",
          gold: "linear-gradient(135deg, #ffd700, #b8860b)",
          elite: "linear-gradient(135deg, #8e2de2, #4a00e0)",
          icon: "linear-gradient(135deg, #00d4ff, #004e92)",
        };
        return colors[tier] || colors.bronze;
      }

      // ==================== MARKET ====================
      function generateMarketCards() {
        GameState.market.cards = [];

        // Check if Nikolas is already on market
        let hasNikolas = false;

        for (let i = 0; i < 20; i++) {
          // Random overall with weighted distribution
          const rand = Math.random();
          let overall;
          if (rand < 0.35)
            overall =
              40 + Math.floor(Math.random() * 20); // 40-59 Bronze/Silver
          else if (rand < 0.65)
            overall = 60 + Math.floor(Math.random() * 25); // 60-84 Gold
          else if (rand < 0.85)
            overall = 85 + Math.floor(Math.random() * 10); // 85-94 Elite
          else overall = 95 + Math.floor(Math.random() * 5); // 95-99 Elite+

          const player = generatePlayer(overall);

          // NEW PRICING - Much more expensive!
          // Bronze (40-59): 50k - 350k
          // Silver (60-69): 200k - 1M
          // Gold (70-79): 500k - 3M
          // Elite (80-89): 2M - 15M
          // World Class (90-94): 15M - 50M
          // Icon (95-99): 50M - 200M
          let basePrice;
          if (overall < 60) {
            basePrice = overall * overall * 200; // 320k - 696k
          } else if (overall < 70) {
            basePrice = overall * overall * 400; // 1.4M - 1.9M
          } else if (overall < 80) {
            basePrice = overall * overall * 800; // 3.9M - 5M
          } else if (overall < 90) {
            basePrice = overall * overall * 2000; // 12.8M - 16.2M
          } else if (overall < 95) {
            basePrice = overall * overall * 5000; // 40.5M - 44M
          } else {
            basePrice = overall * overall * 20000; // 180M - 196M
          }

          const variation = Math.floor(Math.random() * basePrice * 0.3);
          player.price = basePrice + variation;

          // All cards expire when market refreshes (10 minutes)
          player.expiresAt = Date.now() + 10 * 60 * 1000;

          GameState.market.cards.push(player);
        }

        // Chance to spawn special Nikolas card (15% chance, max 1)
        if (!hasNikolas && Math.random() < 0.15) {
          const nikolasCard = generateNikolasCard();
          // Replace a random card with Nikolas
          const replaceIndex = Math.floor(Math.random() * 20);
          GameState.market.cards[replaceIndex] = nikolasCard;
        }

        GameState.market.lastRefresh = Date.now();
        renderMarket();
      }

      // Special goalkeeper Nikolas from Poland
      function generateNikolasCard() {
        const overall = 85 + Math.floor(Math.random() * 6); // 85-90

        // GK stats scaled to overall
        const baseGKStats = {
          Diving: overall + Math.floor(Math.random() * 5) - 2,
          Handling: overall + Math.floor(Math.random() * 5) - 2,
          Kicking: overall - 5 + Math.floor(Math.random() * 10),
          Reflexes: overall + Math.floor(Math.random() * 5) - 2,
          Speed: 40 + Math.floor(Math.random() * 20),
          Positioning: overall + Math.floor(Math.random() * 5) - 2,
        };

        // Clamp all stats to valid range
        Object.keys(baseGKStats).forEach((key) => {
          baseGKStats[key] = Math.max(1, Math.min(99, baseGKStats[key]));
        });

        // Price: Elite GK premium price (85-90 OVR = 10M-18M)
        const basePrice = overall * overall * 1500;
        const variation = Math.floor(Math.random() * basePrice * 0.2);

        return {
          id: "nikolas_" + Date.now(),
          name: "Nikolas",
          country: "Poland",
          position: "GK",
          positions: ["GK"],
          overall: overall,
          stats: baseGKStats,
          subStats: {},
          isIcon: false,
          isSpecial: true, // Mark as special card
          styleOfPlay: "Sweeper Keeper",
          age: 17 + Math.floor(Math.random() * 2), // 17-18
          gamesPlayed: 0,
          salary: Math.floor(overall * 80 + Math.random() * overall * 30),
          contractYears: 1 + Math.floor(Math.random() * 3),
          matchRatings: [],
          goals: 0,
          assists: 0,
          cleanSheets: 0,
          saves: 0,
          price: basePrice + variation,
          expiresAt: Date.now() + 10 * 60 * 1000, // 10 minutes like all cards
        };
      }

      function renderMarket() {
        const container = document.getElementById("marketCards");
        container.innerHTML = "";

        GameState.market.cards.forEach((player, index) => {
          const timeLeft = Math.max(0, player.expiresAt - Date.now());
          const minutes = Math.floor(timeLeft / (60 * 1000));
          const seconds = Math.floor((timeLeft % (60 * 1000)) / 1000);

          const wrapper = document.createElement("div");
          wrapper.className = "market-card-wrapper";
          // Add special class for Nikolas
          if (player.isSpecial) wrapper.classList.add("special-card");
          wrapper.innerHTML = `
                    ${renderPlayerCard(player)}
                    <div class="market-card-price">€${player.price.toLocaleString()}</div>
                    <div class="market-card-timer">${minutes}:${String(
            seconds
          ).padStart(2, "0")}</div>
                `;
          wrapper.onclick = () => openNegotiation(player);
          container.appendChild(wrapper);
        });

        document.getElementById("marketBalance").textContent =
          GameState.manager.balance.toLocaleString();

        // Update market refresh timer
        updateMarketTimer();
      }

      function updateMarketTimer() {
        const timerEl = document.getElementById("marketTimer");
        if (!timerEl || !GameState.market.lastRefresh) return;

        const elapsed = Date.now() - GameState.market.lastRefresh;
        const remaining = Math.max(
          0,
          GameState.market.refreshInterval - elapsed
        );

        const minutes = Math.floor(remaining / (60 * 1000));
        const seconds = Math.floor((remaining % (60 * 1000)) / 1000);

        timerEl.textContent = `${minutes}:${String(seconds).padStart(2, "0")}`;

        if (remaining <= 0) {
          generateMarketCards();
        }
      }

      // Update market timer every second
      setInterval(updateMarketTimer, 1000);

      // ==================== NEGOTIATION ====================
      let currentNegotiationPlayer = null;
      let negotiationRound = 0;
      let negotiationPhase = "price"; // 'price' or 'contract'
      let negotiationTension = 0; // 0-100, at 100 agent leaves
      let agreedPrice = 0;
      let swapPlayer = null;

      function getAgentMessages() {
        if (currentLang === "pl") {
          return {
            greetingsPrice: [
              "Dzień dobry. Reprezentuję {player}. Cena wywoławcza to €{price}. Jaką kwotę Państwo proponują?",
              "Witam. Agent {player} do usług. Rozmawiajmy o cenie - punkt wyjścia to €{price}.",
              "Dzień dobry. {player} jest dostępny za €{price}. Czekam na Państwa propozycję.",
            ],
            priceAccept: [
              "Cena zaakceptowana! Przejdźmy teraz do warunków kontraktu dla {player}.",
              "Doskonale, €{price} to uczciwa kwota. Teraz ustalmy szczegóły umowy.",
              "Zgoda! Mamy porozumienie w kwestii ceny. Czas na kontrakt.",
            ],
            priceCounter: [
              "To za mało. {player} jest wart co najmniej €{counter}. Proszę o lepszą ofertę.",
              "Mój klient oczekuje minimum €{counter}. Możemy się spotkać w połowie drogi?",
              "Rozumiem budżet, ale €{counter} to absolutne minimum dla {player}.",
            ],
            priceLow: [
              "Ta oferta jest obraźliwa. {player} nie będzie rozmawiał za takie pieniądze.",
              "Żartujecie? To nawet nie pokrywa kosztów agenta. Poważna oferta albo kończymy.",
              "Nie zamierzam tracić czasu. Wróćcie z realną propozycją.",
            ],
            contractAccept: [
              "Świetnie! {player} z przyjemnością podpisuje kontrakt. Witamy w klubie!",
              "Warunki zaakceptowane! {player} już nie może się doczekać gry w Państwa barwach.",
              "Mamy deal! {player} jest Waszym nowym zawodnikiem. Gratulacje!",
            ],
            contractCounter: [
              "{player} oczekuje pensji bliższej €{salary}/tyg. Bonus €{bonus} też by pomógł.",
              "Dobry początek, ale pensja €{salary}/tyg byłaby bardziej odpowiednia dla {player}.",
              "Musimy porozmawiać o pensjach. €{salary}/tyg to minimum dla kogoś tej klasy.",
            ],
            leaves: [
              "Dosyć! Negocjacje zakończone. {player} nie jest zainteresowany.",
              "Straciłem cierpliwość. {player} będzie szukał innego klubu.",
              "To była strata czasu. Do widzenia.",
            ],
            notEnoughMoney: "Nie macie wystarczających środków na tę ofertę.",
            tooLow:
              "To zdecydowanie za mało. {player} oczekuje minimum €{salary}/tyg.",
          };
        } else {
          return {
            greetingsPrice: [
              "Hello. I represent {player}. Starting price is €{price}. What is your offer?",
              "Greetings. I'm {player}'s agent. Let's discuss the price - starting at €{price}.",
              "Good day. {player} is available for €{price}. I await your proposal.",
            ],
            priceAccept: [
              "Price accepted! Let's move on to contract terms for {player}.",
              "Excellent, €{price} is a fair amount. Now let's discuss the details.",
              "Agreed! We have a deal on the price. Time for the contract.",
            ],
            priceCounter: [
              "That's too low. {player} is worth at least €{counter}. Please make a better offer.",
              "My client expects minimum €{counter}. Can we meet in the middle?",
              "I understand budget constraints, but €{counter} is the absolute minimum for {player}.",
            ],
            priceLow: [
              "This offer is insulting. {player} won't negotiate for this money.",
              "Are you joking? This doesn't even cover agent fees. Serious offer or we're done.",
              "I won't waste my time. Come back with a real proposal.",
            ],
            contractAccept: [
              "Great! {player} is happy to sign the contract. Welcome to the club!",
              "Terms accepted! {player} can't wait to play for your team.",
              "We have a deal! {player} is your new player. Congratulations!",
            ],
            contractCounter: [
              "{player} expects salary closer to €{salary}/week. A bonus of €{bonus} would help too.",
              "Good start, but €{salary}/week would be more appropriate for {player}.",
              "We need to talk about salaries. €{salary}/week is the minimum for someone of this class.",
            ],
            leaves: [
              "Enough! Negotiations are over. {player} is not interested.",
              "I've lost patience. {player} will look for another club.",
              "This was a waste of time. Goodbye.",
            ],
            notEnoughMoney: "You don't have enough funds for this offer.",
            tooLow:
              "That's way too low. {player} expects minimum €{salary}/week.",
          };
        }
      }

      function getRandomMessage(messages, replacements = {}) {
        const arr = Array.isArray(messages) ? messages : [messages];
        let msg = arr[Math.floor(Math.random() * arr.length)];
        for (const [key, value] of Object.entries(replacements)) {
          msg = msg.replace(new RegExp(`{${key}}`, "g"), value);
        }
        return msg;
      }

      function openNegotiation(player) {
        currentNegotiationPlayer = player;
        negotiationRound = 0;
        negotiationPhase = "price";
        negotiationTension = 0;
        agreedPrice = 0;
        swapPlayer = null;

        document.getElementById("negotiationPlayerName").textContent =
          player.name;
        document.getElementById(
          "negotiationPlayerDetails"
        ).textContent = `${player.position} | ${player.country} | OVR ${player.overall}`;
        document.getElementById(
          "negotiationPrice"
        ).textContent = `€${player.price.toLocaleString()}`;

        // Render card
        document.getElementById("negotiationCard").innerHTML = renderPlayerCard(
          player,
          true
        );

        // Set default price offer (80% of market price)
        document.getElementById("offerPrice").value = Math.floor(
          player.price * 0.8
        );

        // Reset contract fields
        const expectedSalary = Math.floor(player.overall * 100);
        document.getElementById("offerSalary").value = Math.floor(
          expectedSalary * 0.7
        );
        document.getElementById("offerBonus").value = "";
        document.getElementById("offerClause").value = "";
        document.getElementById("offerLength").value = 3;

        // Reset swap
        document.getElementById("includeSwap").checked = false;
        document.getElementById("swapPlayerSelect").style.display = "none";
        populateSwapDropdown();

        // Show price phase, hide contract phase
        document.getElementById("pricePhase").style.display = "block";
        document.getElementById("contractPhase").style.display = "none";

        // Reset tension
        updateTensionBar();

        // Clear chat
        const chat = document.getElementById("negotiationChat");
        chat.innerHTML = "";

        // Add greeting
        addChatMessage(
          "agent",
          getRandomMessage(getAgentMessages().greetingsPrice, {
            player: player.name,
            price: player.price.toLocaleString(),
          })
        );

        document.getElementById("negotiationModal").classList.add("active");
      }

      function closeNegotiation() {
        document.getElementById("negotiationModal").classList.remove("active");
        currentNegotiationPlayer = null;
        swapPlayer = null;
      }

      function updateTensionBar() {
        const fill = document.getElementById("tensionFill");
        const warning = document.getElementById("tensionWarning");

        fill.style.width = `${negotiationTension}%`;

        if (negotiationTension >= 70) {
          warning.style.display = "block";
        } else {
          warning.style.display = "none";
        }
      }

      function populateSwapDropdown() {
        const dropdown = document.getElementById("swapPlayerDropdown");
        dropdown.innerHTML = '<option value="">-- Wybierz gracza --</option>';

        [...GameState.squad.players, ...GameState.squad.bench].forEach(
          (p, i) => {
            if (p && p.overall >= 40) {
              const value = Math.floor(p.overall * p.overall * 8);
              dropdown.innerHTML += `<option value="${p.id}">${p.name} (${
                p.position
              }, OVR ${
                p.overall
              }) - wartość: €${value.toLocaleString()}</option>`;
            }
          }
        );
      }

      function toggleSwapPlayer() {
        const checked = document.getElementById("includeSwap").checked;
        document.getElementById("swapPlayerSelect").style.display = checked
          ? "block"
          : "none";

        if (!checked) {
          swapPlayer = null;
          document.getElementById("swapPlayerValue").textContent = "";
        }
      }

      function getSwapPlayerValue() {
        const dropdown = document.getElementById("swapPlayerDropdown");
        const playerId = dropdown.value;

        if (!playerId) {
          swapPlayer = null;
          document.getElementById("swapPlayerValue").textContent = "";
          return 0;
        }

        swapPlayer = [
          ...GameState.squad.players,
          ...GameState.squad.bench,
        ].find((p) => p && p.id == playerId);
        if (swapPlayer) {
          const value = Math.floor(swapPlayer.overall * swapPlayer.overall * 8);
          document.getElementById(
            "swapPlayerValue"
          ).textContent = `Wartość wymiany: €${value.toLocaleString()}`;
          return value;
        }
        return 0;
      }

      // Add event listener for swap dropdown
      document
        .getElementById("swapPlayerDropdown")
        ?.addEventListener("change", getSwapPlayerValue);

      function addChatMessage(type, message) {
        const chat = document.getElementById("negotiationChat");
        const div = document.createElement("div");
        div.className = `chat-message ${type}`;

        const sender = document.createElement("div");
        sender.className = "sender";
        sender.textContent = type === "agent" ? "🤵 Agent" : "👤 " + t("you");

        const text = document.createElement("div");
        text.textContent = message;

        div.appendChild(sender);
        div.appendChild(text);
        chat.appendChild(div);
        chat.scrollTop = chat.scrollHeight;
      }

      function sendPriceOffer() {
        if (!currentNegotiationPlayer) return;

        const offeredPrice =
          parseInt(document.getElementById("offerPrice").value) || 0;
        const swapValue = document.getElementById("includeSwap").checked
          ? getSwapPlayerValue()
          : 0;
        const totalOffer = offeredPrice + swapValue;

        negotiationRound++;

        // Player message
        const offerWord = currentLang === "pl" ? "Oferuję" : "I offer";
        const valueWord = currentLang === "pl" ? "wartość" : "value";
        const totalWord = currentLang === "pl" ? "łącznie" : "total";

        let offerText = `${offerWord} €${offeredPrice.toLocaleString()}`;
        if (swapPlayer) {
          offerText += ` + ${swapPlayer.name} (OVR ${
            swapPlayer.overall
          }, ${valueWord} €${swapValue.toLocaleString()})`;
        }
        offerText += ` = ${totalWord} €${totalOffer.toLocaleString()}`;
        addChatMessage("player", offerText);

        // Check if can afford
        if (offeredPrice > GameState.manager.balance) {
          setTimeout(() => {
            addChatMessage("agent", getAgentMessages().notEnoughMoney);
            negotiationTension += 15;
            updateTensionBar();
          }, 800);
          return;
        }

        // AI response
        setTimeout(() => {
          const marketPrice = currentNegotiationPlayer.price;
          const ratio = totalOffer / marketPrice;

          if (ratio >= 1.0) {
            // Full price or more - instant accept with enthusiasm!
            agreedPrice = offeredPrice;
            negotiationTension = 0;
            updateTensionBar();

            const enthusiasticMsg =
              currentLang === "pl"
                ? `Doskonała oferta! €${totalOffer.toLocaleString()} to więcej niż oczekiwaliśmy. Przechodzimy do kontraktu!`
                : `Excellent offer! €${totalOffer.toLocaleString()} is more than we expected. Let's discuss the contract!`;
            addChatMessage("agent", enthusiasticMsg);

            // Move to contract phase
            setTimeout(() => {
              negotiationPhase = "contract";
              document.getElementById("pricePhase").style.display = "none";
              document.getElementById("contractPhase").style.display = "block";
            }, 1000);
          } else if (ratio >= 0.9) {
            // Accept price (90-99%)
            agreedPrice = offeredPrice;
            negotiationTension = Math.max(0, negotiationTension - 20);
            updateTensionBar();

            addChatMessage(
              "agent",
              getRandomMessage(getAgentMessages().priceAccept, {
                player: currentNegotiationPlayer.name,
                price: totalOffer.toLocaleString(),
              })
            );

            // Move to contract phase
            setTimeout(() => {
              negotiationPhase = "contract";
              document.getElementById("pricePhase").style.display = "none";
              document.getElementById("contractPhase").style.display = "block";
            }, 1000);
          } else if (ratio >= 0.7) {
            // Counter offer
            const counterPrice = Math.floor(marketPrice * 0.9);
            negotiationTension += 10;
            updateTensionBar();

            addChatMessage(
              "agent",
              getRandomMessage(getAgentMessages().priceCounter, {
                player: currentNegotiationPlayer.name,
                counter: counterPrice.toLocaleString(),
              })
            );
          } else if (ratio >= 0.4) {
            // Low offer
            negotiationTension += 25;
            updateTensionBar();

            addChatMessage(
              "agent",
              getRandomMessage(getAgentMessages().priceLow, {
                player: currentNegotiationPlayer.name,
              })
            );
          } else {
            // Insulting - agent leaves
            negotiationTension = 100;
            updateTensionBar();

            addChatMessage(
              "agent",
              getRandomMessage(getAgentMessages().leaves, {
                player: currentNegotiationPlayer.name,
              })
            );

            setTimeout(() => closeNegotiation(), 2000);
          }

          // Check if tension too high
          if (negotiationTension >= 100) {
            addChatMessage(
              "agent",
              getRandomMessage(getAgentMessages().leaves, {
                player: currentNegotiationPlayer.name,
              })
            );
            setTimeout(() => closeNegotiation(), 2000);
          }
        }, 1000);
      }

      function sendContractOffer() {
        if (!currentNegotiationPlayer) return;

        const salary =
          parseInt(document.getElementById("offerSalary").value) || 0;
        const length =
          parseInt(document.getElementById("offerLength").value) || 1;
        const bonus =
          parseInt(document.getElementById("offerBonus").value) || 0;
        const clause =
          parseInt(document.getElementById("offerClause").value) || 0;

        const totalCost = agreedPrice + bonus;

        if (totalCost > GameState.manager.balance) {
          const salaryWord = currentLang === "pl" ? "Pensja" : "Salary";
          const yearsWord = currentLang === "pl" ? "lat" : "years";
          const bonusWord = currentLang === "pl" ? "bonus" : "bonus";
          addChatMessage(
            "player",
            `${salaryWord} €${salary.toLocaleString()}/${
              currentLang === "pl" ? "tyg" : "week"
            }, ${length} ${yearsWord}` +
              (bonus ? `, ${bonusWord} €${bonus.toLocaleString()}` : "")
          );
          setTimeout(() => {
            addChatMessage("agent", getAgentMessages().notEnoughMoney);
            negotiationTension += 10;
            updateTensionBar();
          }, 800);
          return;
        }

        negotiationRound++;

        // Player message
        const salaryWord = currentLang === "pl" ? "Pensja" : "Salary";
        const contractWord = currentLang === "pl" ? "kontrakt" : "contract";
        const yearsWord = currentLang === "pl" ? "lat" : "years";
        const bonusWord = currentLang === "pl" ? "bonus" : "bonus";
        const clauseWord = currentLang === "pl" ? "klauzula" : "clause";
        const weekWord = currentLang === "pl" ? "tyg" : "week";

        let offerText = `${salaryWord} €${salary.toLocaleString()}/${weekWord}, ${contractWord} ${length} ${yearsWord}`;
        if (bonus > 0) offerText += `, ${bonusWord} €${bonus.toLocaleString()}`;
        if (clause > 0)
          offerText += `, ${clauseWord} €${clause.toLocaleString()}`;
        addChatMessage("player", offerText);

        // AI response
        setTimeout(() => {
          const expectedSalary = currentNegotiationPlayer.overall * 100;
          const expectedBonus = agreedPrice * 0.1;

          const salaryRatio = salary / expectedSalary;
          const bonusRatio = bonus >= expectedBonus ? 1 : bonus / expectedBonus;
          const lengthBonus = length >= 3 ? 0.1 : 0;

          const satisfaction =
            salaryRatio * 0.6 + bonusRatio * 0.3 + lengthBonus;

          if (satisfaction >= 0.75) {
            // Accept
            addChatMessage(
              "agent",
              getRandomMessage(getAgentMessages().contractAccept, {
                player: currentNegotiationPlayer.name,
              })
            );

            setTimeout(() => {
              // Complete transfer
              GameState.manager.balance -= totalCost;

              // If swap player, remove from squad
              if (swapPlayer) {
                let idx = GameState.squad.players.findIndex(
                  (p) => p?.id === swapPlayer.id
                );
                if (idx !== -1) {
                  GameState.squad.players[idx] = null;
                } else {
                  idx = GameState.squad.bench.findIndex(
                    (p) => p?.id === swapPlayer.id
                  );
                  if (idx !== -1) {
                    GameState.squad.bench.splice(idx, 1);
                  }
                }
              }

              // Add new player to bench with contract info
              const newPlayer = {
                ...currentNegotiationPlayer,
                salary:
                  parseInt(document.getElementById("offerSalary").value) || 0,
                contractYears:
                  parseInt(document.getElementById("offerLength").value) || 1,
              };
              GameState.squad.bench.push(newPlayer);

              // Remove from market
              GameState.market.cards = GameState.market.cards.filter(
                (c) => c.id !== currentNegotiationPlayer.id
              );

              updateAccountDisplay();
              updateSquadOverall();
              autoSave();

              alert(`🎉 ${currentNegotiationPlayer.name} ${t("playerJoined")}`);
              closeNegotiation();
              renderMarket();
            }, 1500);
          } else if (satisfaction >= 0.5) {
            // Counter
            const counterSalary = Math.floor(expectedSalary * 0.85);
            const counterBonus = Math.floor(expectedBonus);
            negotiationTension += 15;
            updateTensionBar();

            addChatMessage(
              "agent",
              getRandomMessage(getAgentMessages().contractCounter, {
                player: currentNegotiationPlayer.name,
                salary: counterSalary.toLocaleString(),
                bonus: counterBonus.toLocaleString(),
              })
            );
          } else {
            // Too low
            negotiationTension += 30;
            updateTensionBar();

            addChatMessage(
              "agent",
              getRandomMessage(getAgentMessages().tooLow, {
                player: currentNegotiationPlayer.name,
                salary: Math.floor(expectedSalary * 0.75).toLocaleString(),
              })
            );
          }

          // Check tension
          if (negotiationTension >= 100) {
            setTimeout(() => {
              addChatMessage(
                "agent",
                getRandomMessage(getAgentMessages().leaves, {
                  player: currentNegotiationPlayer.name,
                })
              );
              setTimeout(() => closeNegotiation(), 2000);
            }, 500);
          }
        }, 1000);
      }

      // ==================== ONLINE SYSTEM ====================
      let onlineState = {
        peer: null,
        connections: [],
        isHost: false,
        roomId: null,
      };

      function createOnlineRoom() {
        onlineState.isHost = true;
        onlineState.roomId =
          "FM-" + Math.random().toString(36).substr(2, 6).toUpperCase();

        document.getElementById("onlineChoiceSection").style.display = "none";
        document.getElementById("hostLobbySection").style.display = "block";

        const currentUrl = window.location.origin + window.location.pathname;
        const shareLink = currentUrl + "?room=" + onlineState.roomId;
        document.getElementById("roomLink").textContent = shareLink;

        initPeerConnection();
      }

      function initPeerConnection() {
        if (typeof Peer === "undefined") {
          document.getElementById("hostStatus").textContent =
            "Błąd: PeerJS nie załadowany. Odśwież stronę.";
          document.getElementById("hostStatus").classList.add("error");
          return;
        }

        onlineState.peer = new Peer(onlineState.roomId.toLowerCase());

        onlineState.peer.on("open", (id) => {
          document.getElementById("hostStatus").textContent =
            "Pokój gotowy! Czekam na przeciwnika...";
          document.getElementById("hostStatus").classList.add("connected");
        });

        onlineState.peer.on("connection", (conn) => {
          onlineState.connections.push(conn);

          conn.on("open", () => {
            document.getElementById("hostStatus").textContent =
              "Przeciwnik dołączył!";
            document.getElementById("startOnlineBtn").disabled = false;

            conn.send({
              type: "welcome",
              hostSquad: calculateSquadOverall(),
            });
          });

          conn.on("data", handleOnlineMessage);
        });

        onlineState.peer.on("error", (err) => {
          document.getElementById("hostStatus").textContent =
            "Błąd połączenia: " + err.type;
          document.getElementById("hostStatus").classList.add("error");
        });
      }

      function joinOnlineRoom() {
        const input = document.getElementById("joinRoomInput").value.trim();
        let code = input;

        if (input.includes("?room=")) {
          const match = input.match(/room=([^&]+)/);
          if (match) code = match[1];
        }

        if (!code) {
          alert(t("enterCode"));
          return;
        }

        code = code.toUpperCase();
        if (!code.startsWith("FM-")) code = "FM-" + code;

        onlineState.isHost = false;
        onlineState.roomId = code;

        document.getElementById("onlineChoiceSection").style.display = "none";
        document.getElementById("guestLobbySection").style.display = "block";

        if (typeof Peer === "undefined") {
          document.getElementById("guestStatus").textContent =
            "Błąd: PeerJS nie załadowany. Odśwież stronę.";
          document.getElementById("guestStatus").classList.add("error");
          return;
        }

        onlineState.peer = new Peer();

        onlineState.peer.on("open", () => {
          const conn = onlineState.peer.connect(code.toLowerCase());
          onlineState.connections.push(conn);

          conn.on("open", () => {
            document.getElementById("guestStatus").textContent =
              "Połączono! Oczekiwanie na rozpoczęcie meczu...";
            document.getElementById("guestStatus").classList.add("connected");

            conn.send({
              type: "guestInfo",
              guestSquad: calculateSquadOverall(),
            });
          });

          conn.on("data", handleOnlineMessage);
        });
      }

      function handleOnlineMessage(data) {
        switch (data.type) {
          case "welcome":
            break;
          case "guestInfo":
            break;
          case "startMatch":
            startMatch("online");
            break;
        }
      }

      function startOnlineGame() {
        onlineState.connections.forEach((conn) => {
          conn.send({ type: "startMatch" });
        });
        startMatch("online");
      }

      function copyRoomLink() {
        const link = document.getElementById("roomLink").textContent;
        navigator.clipboard.writeText(link).then(() => {
          alert(t("linkCopied"));
        });
      }

      function leaveLobby() {
        if (onlineState.peer) {
          onlineState.peer.destroy();
        }
        onlineState = {
          peer: null,
          connections: [],
          isHost: false,
          roomId: null,
        };

        document.getElementById("onlineChoiceSection").style.display = "block";
        document.getElementById("hostLobbySection").style.display = "none";
        document.getElementById("guestLobbySection").style.display = "none";

        showScreen("playMenu");
      }

      function calculateSquadOverall() {
        if (GameState.squad.players.length === 0) return 0;
        return Math.round(
          GameState.squad.players.reduce((sum, p) => sum + p.overall, 0) /
            GameState.squad.players.length
        );
      }

      // ==================== MATCH ====================
      let matchInterval = null;
      let matchAnimationFrame = null;
      // ==================== PENALTY SHOOTOUT ====================
      let penaltyState = {
        round: 1,
        maxRounds: 5,
        playerScore: 0,
        opponentScore: 0,
        playerShots: [], // 'scored', 'missed', 'saved'
        opponentShots: [],
        phase: "player_shoot", // 'player_shoot', 'player_save', 'opponent_shoot', 'opponent_save', 'result'
        shooters: [],
        opponentShooters: [],
        currentShooterIndex: 0,
        selectedDirection: null,
      };

      function startPenalties(difficulty = "medium") {
        GameState.match.difficulty = difficulty;
        GameState.match.bannedSlots = []; // Reset banned slots

        // Check for protests before hard matches
        if (difficulty === "hard") {
          healInjuries(); // First heal any expired injuries
          const issues = checkPreMatchProtests();

          if (issues.length > 0) {
            // Handle each issue one by one
            handlePreMatchIssues(issues, 0, () => {
              actuallyStartPenalties(difficulty);
            });
            return;
          }
        }

        actuallyStartPenalties(difficulty);
      }

      function handlePreMatchIssues(issues, index, callback) {
        if (index >= issues.length) {
          callback();
          return;
        }

        const issue = issues[index];
        showProtestModal(issue);

        // Continue to next issue after a delay
        setTimeout(() => {
          handlePreMatchIssues(issues, index + 1, callback);
        }, 500);
      }

      function actuallyStartPenalties(difficulty) {
        // Reset state
        penaltyState = {
          round: 1,
          maxRounds: 5,
          playerScore: 0,
          opponentScore: 0,
          playerShots: [],
          opponentShots: [],
          phase: "player_shoot",
          shooters: getPlayerShooters(),
          opponentShooters: getOpponentShooters(),
          currentShooterIndex: 0,
          selectedDirection: null,
          shootTimer: null,
          timeLeft: 15,
          lastShooter: null,
          currentShooter: null,
        };

        showScreen("penaltyScreen");

        // Reset dots visually
        document
          .querySelectorAll("#playerDots .dot, #opponentDots .dot")
          .forEach((dot) => {
            dot.className = "dot";
          });

        // Reset buttons to normal
        const buttons = document.getElementById("penaltyButtons");
        buttons.innerHTML = `
                <button class="penalty-btn" onclick="selectPenaltyDirection('left')">⬅️ ${
                  currentLang === "pl" ? "LEWO" : "LEFT"
                }</button>
                <button class="penalty-btn" onclick="selectPenaltyDirection('center')">⬆️ ${
                  currentLang === "pl" ? "ŚRODEK" : "CENTER"
                }</button>
                <button class="penalty-btn" onclick="selectPenaltyDirection('right')">➡️ ${
                  currentLang === "pl" ? "PRAWO" : "RIGHT"
                }</button>
            `;
        buttons.style.display = "flex";

        // Show surrender button
        const surrenderBtn = document.getElementById("surrenderBtn");
        surrenderBtn.style.display = "block";
        surrenderBtn.onclick = surrenderPenalties;

        initCrowdSound();
        updatePenaltyUI();
        setupPenaltyPhase();
      }

      function getPlayerShooters() {
        // Get all outfield players sorted by attack stats
        const outfield = GameState.squad.players.filter(
          (p) => p && p.position !== "GK"
        );

        // Sort by total attack stats
        return outfield.sort((a, b) => {
          const attackA = calculateAttackScore(a);
          const attackB = calculateAttackScore(b);
          return attackB - attackA;
        });
      }

      function calculateAttackScore(player) {
        // Attack stats: Pace, Shooting, Passing, Dribbling (not Defending, Physical)
        const stats = player.stats || {};
        const pace = stats.Pace || player.overall;
        const shooting = stats.Shooting || player.overall;
        const passing = stats.Passing || player.overall;
        const dribbling = stats.Dribbling || player.overall;

        // Average of attack stats
        return (pace + shooting + passing + dribbling) / 4;
      }

      function selectNextShooter() {
        // Get all eligible shooters (outfield players)
        const allShooters = getPlayerShooters();
        if (allShooters.length === 0) return null;

        // Get last shooter to avoid repetition
        const lastShooter = penaltyState.lastShooter;

        // Calculate weights based on TOTAL attack stats
        let totalWeight = 0;
        const weights = allShooters.map((player) => {
          // Skip if same as last shooter
          if (lastShooter && player.id === lastShooter.id) {
            return 0;
          }

          // Weight based on ALL attack stats (Pace, Shooting, Passing, Dribbling)
          const attackScore = calculateAttackScore(player);
          const weight = Math.pow(attackScore, 2); // Square to emphasize high attackers
          totalWeight += weight;
          return weight;
        });

        // If all weights are 0 (only one player), just pick first available
        if (totalWeight === 0) {
          return allShooters[0];
        }

        // Random weighted selection
        let random = Math.random() * totalWeight;
        for (let i = 0; i < allShooters.length; i++) {
          random -= weights[i];
          if (random <= 0) {
            return allShooters[i];
          }
        }

        // Fallback
        return allShooters[0];
      }

      function getOpponentShooters(botOVR = null) {
        // Generate 5 opponent shooters based on arena botOVR or difficulty
        let baseOVR;

        if (botOVR !== null) {
          // Arena mode - use provided botOVR
          baseOVR = botOVR;
        } else {
          // Old difficulty mode fallback
          const difficultyBonus = { easy: -10, medium: 0, hard: 15 };
          const bonus = difficultyBonus[GameState.match.difficulty] || 0;
          baseOVR = 70 + bonus;
        }

        const shooters = [];
        for (let i = 0; i < 5; i++) {
          const overall = Math.min(
            99,
            Math.max(40, baseOVR + Math.floor(Math.random() * 10 - 5))
          );
          shooters.push({
            name: generateOpponentName(),
            position: ["ST", "CF", "CAM", "CM", "RW"][i],
            overall: overall,
            stats: { Shooting: overall + Math.floor(Math.random() * 10 - 5) },
          });
        }
        return shooters;
      }

      function generateOpponentName() {
        const names = [
          "Martinez",
          "Silva",
          "Muller",
          "Rossi",
          "Dubois",
          "Petrov",
          "Novak",
          "Jensen",
          "Berg",
          "Costa",
        ];
        return names[Math.floor(Math.random() * names.length)];
      }

      function updatePenaltyUI() {
        document.getElementById("penaltyScorePlayer").textContent =
          penaltyState.playerScore;
        document.getElementById("penaltyScoreOpponent").textContent =
          penaltyState.opponentScore;
        document.getElementById("penaltyRound").textContent = `${t("round")} ${
          penaltyState.round
        }/${penaltyState.maxRounds}`;

        // Update dots
        const playerDots = document.querySelectorAll("#playerDots .dot");
        const opponentDots = document.querySelectorAll("#opponentDots .dot");

        penaltyState.playerShots.forEach((shot, i) => {
          if (playerDots[i]) {
            playerDots[i].className =
              "dot " + (shot === "scored" ? "scored" : "missed");
          }
        });

        penaltyState.opponentShots.forEach((shot, i) => {
          if (opponentDots[i]) {
            opponentDots[i].className =
              "dot " + (shot === "scored" ? "scored" : "missed");
          }
        });
      }

      function setupPenaltyPhase() {
        const actionEl = document.getElementById("penaltyAction");
        const shooterInfo = document.getElementById("shooterInfo");
        const shooterName = document.getElementById("shooterName");
        const shooterStats = document.getElementById("shooterStats");
        const buttons = document.getElementById("penaltyButtons");
        const result = document.getElementById("penaltyResult");
        const gk = document.getElementById("penaltyGK");
        const ball = document.getElementById("penaltyBall");
        const timerBar = document.getElementById("turnTimerBar");
        const timerText = document.getElementById("turnTimerText");

        // Reset visuals
        result.textContent = "";
        result.className = "penalty-result";
        gk.className = "goalkeeper-penalty";
        ball.className = "ball-penalty";
        document
          .querySelectorAll(".goal-zone")
          .forEach((z) => (z.className = "goal-zone " + z.dataset.zone));
        buttons.style.display = "flex";

        // Clear old timer
        if (penaltyState.shootTimer) clearInterval(penaltyState.shootTimer);
        penaltyState.timeLeft = 15;

        // UPDATE BIG ACTION INDICATOR
        const indicator = document.getElementById("penaltyActionIndicator");

        if (penaltyState.phase === "player_shoot") {
          // Select shooter based on stats (weighted random, no repeat)
          const shooter = selectNextShooter();
          penaltyState.currentShooter = shooter;

          indicator.className = "penalty-action-indicator shooting";
          indicator.textContent =
            currentLang === "pl" ? "⚽ STRZELASZ!" : "⚽ SHOOT!";

          actionEl.textContent = t("chooseShot") + " - 15s";
          shooterName.textContent =
            (currentLang === "pl" ? "Strzela: " : "Shoots: ") +
            (shooter?.name || "Strzelec");
          shooterStats.textContent = `ATK: ${Math.round(
            calculateAttackScore(shooter)
          )}`;
          shooterInfo.style.display = "block";

          // Start 15s timer
          penaltyState.shootTimer = setInterval(() => {
            penaltyState.timeLeft -= 0.1;
            if (timerBar)
              timerBar.style.width = `${(penaltyState.timeLeft / 15) * 100}%`;
            if (timerText)
              timerText.textContent = `${
                currentLang === "pl" ? "STRZELAJ!" : "SHOOT!"
              } - ${Math.ceil(penaltyState.timeLeft)}s`;

            if (penaltyState.timeLeft <= 0) {
              clearInterval(penaltyState.shootTimer);
              // Czas minął - automatyczne pudło!
              autoMissShot();
            }
          }, 100);

          // Click on zones to select
          document.querySelectorAll(".goal-zone").forEach((zone) => {
            zone.onclick = () => selectPenaltyDirection(zone.dataset.zone);
          });
        } else if (penaltyState.phase === "player_save") {
          const shooter =
            penaltyState.opponentShooters[
              penaltyState.currentShooterIndex %
                penaltyState.opponentShooters.length
            ];

          indicator.className = "penalty-action-indicator saving";
          indicator.textContent =
            currentLang === "pl" ? "🧤 BRONISZ!" : "🧤 SAVE!";

          // Get your goalkeeper info
          const yourGK = GameState.squad.players.find(
            (p) => p && p.position === "GK"
          );
          const gkName =
            yourGK?.name || (currentLang === "pl" ? "Bramkarz" : "Goalkeeper");
          const gkDiving = yourGK?.stats?.Diving || yourGK?.overall || 50;

          actionEl.textContent = t("chooseDefense") + " - 15s";
          shooterName.textContent =
            (currentLang === "pl" ? "Broni: " : "Saves: ") + gkName;
          shooterStats.textContent = `DIV: ${gkDiving} | ${
            currentLang === "pl" ? "Strzela" : "Shoots"
          }: ${shooter?.name || "Przeciwnik"}`;
          shooterInfo.style.display = "block";

          // Start 15s timer
          penaltyState.shootTimer = setInterval(() => {
            penaltyState.timeLeft -= 0.1;
            if (timerBar)
              timerBar.style.width = `${(penaltyState.timeLeft / 15) * 100}%`;
            if (timerText)
              timerText.textContent = `${
                currentLang === "pl" ? "BROŃ!" : "SAVE!"
              } - ${Math.ceil(penaltyState.timeLeft)}s`;

            if (penaltyState.timeLeft <= 0) {
              clearInterval(penaltyState.shootTimer);
              // Czas minął - losowy kierunek
              const directions = ["left", "center", "right"];
              selectPenaltyDirection(directions[Math.floor(Math.random() * 3)]);
            }
          }, 100);

          document.querySelectorAll(".goal-zone").forEach((zone) => {
            zone.onclick = () => selectPenaltyDirection(zone.dataset.zone);
          });
        }
      }

      function autoMissShot() {
        // Czas minął przy strzelaniu - automatyczne pudło
        const ball = document.getElementById("penaltyBall");
        const result = document.getElementById("penaltyResult");
        const gk = document.getElementById("penaltyGK");

        document.getElementById("penaltyButtons").style.display = "none";

        // Animacja pudła
        ball.classList.add("shoot-miss");

        setTimeout(() => {
          result.textContent = t("timeMiss");
          result.className = "penalty-result miss";
          penaltyState.playerShots.push("missed");
          playSaveSound();
          updatePenaltyUI();

          // Pokaż kartę strzelca
          const shooter =
            penaltyState.shooters[
              penaltyState.currentShooterIndex % penaltyState.shooters.length
            ];
          showPenaltyCard(shooter, () => {
            penaltyState.phase = "player_save";
            setupPenaltyPhase();
          });
        }, 250);
      }

      function showPenaltyCard(player, callback) {
        // Stwórz kontener na kartę
        const cardContainer = document.createElement("div");
        cardContainer.className = "penalty-card-reveal";
        cardContainer.innerHTML = renderPlayerCard(player);
        document.body.appendChild(cardContainer);

        // Usuń po animacji i wywołaj callback
        setTimeout(() => {
          cardContainer.remove();
          if (callback) callback();
        }, 1500);
      }

      function playGoalSound() {
        // Inicjuj audio jeśli nie ma
        if (!crowdAudio) {
          try {
            const AudioContext =
              window.AudioContext || window.webkitAudioContext;
            const audioCtx = new AudioContext();

            const bufferSize = 2 * audioCtx.sampleRate;
            const noiseBuffer = audioCtx.createBuffer(
              1,
              bufferSize,
              audioCtx.sampleRate
            );
            const output = noiseBuffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
              output[i] = Math.random() * 2 - 1;
            }

            const whiteNoise = audioCtx.createBufferSource();
            whiteNoise.buffer = noiseBuffer;
            whiteNoise.loop = true;

            const filter = audioCtx.createBiquadFilter();
            filter.type = "lowpass";
            filter.frequency.value = 500;

            const gain = audioCtx.createGain();
            gain.gain.value = 0.3;

            whiteNoise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            whiteNoise.start();
            crowdAudio = { ctx: audioCtx, gain: gain, source: whiteNoise };
          } catch (e) {}
        }

        if (crowdAudio) {
          if (crowdAudio.ctx.state === "suspended") {
            crowdAudio.ctx.resume();
          }
          const ctx = crowdAudio.ctx;
          const gain = crowdAudio.gain;
          const now = ctx.currentTime;

          // MEGA głośny krzyk
          gain.gain.cancelScheduledValues(now);
          gain.gain.setValueAtTime(1.0, now);
          gain.gain.linearRampToValueAtTime(8.0, now + 0.3);
          gain.gain.linearRampToValueAtTime(12.0, now + 0.6);
          gain.gain.linearRampToValueAtTime(8.0, now + 1.5);
          gain.gain.exponentialRampToValueAtTime(0.3, now + 4);
        }
      }

      function playSaveSound() {
        if (!crowdAudio) {
          try {
            const AudioContext =
              window.AudioContext || window.webkitAudioContext;
            const audioCtx = new AudioContext();

            const bufferSize = 2 * audioCtx.sampleRate;
            const noiseBuffer = audioCtx.createBuffer(
              1,
              bufferSize,
              audioCtx.sampleRate
            );
            const output = noiseBuffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
              output[i] = Math.random() * 2 - 1;
            }

            const whiteNoise = audioCtx.createBufferSource();
            whiteNoise.buffer = noiseBuffer;
            whiteNoise.loop = true;

            const filter = audioCtx.createBiquadFilter();
            filter.type = "lowpass";
            filter.frequency.value = 500;

            const gain = audioCtx.createGain();
            gain.gain.value = 0.3;

            whiteNoise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            whiteNoise.start();
            crowdAudio = { ctx: audioCtx, gain: gain, source: whiteNoise };
          } catch (e) {}
        }

        if (crowdAudio) {
          if (crowdAudio.ctx.state === "suspended") {
            crowdAudio.ctx.resume();
          }
          const gain = crowdAudio.gain;
          gain.gain.setValueAtTime(0.5, crowdAudio.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(
            0.3,
            crowdAudio.ctx.currentTime + 1
          );
        }
      }

      function selectPenaltyDirection(direction) {
        if (penaltyState.phase === "result") return;

        // Stop timer
        if (penaltyState.shootTimer) clearInterval(penaltyState.shootTimer);

        penaltyState.selectedDirection = direction;

        // Highlight selected zone
        document
          .querySelectorAll(".goal-zone")
          .forEach((z) => z.classList.remove("selected"));
        document
          .querySelector(`.goal-zone.${direction}`)
          ?.classList.add("selected");

        // Disable buttons
        document.getElementById("penaltyButtons").style.display = "none";

        // Execute after short delay
        setTimeout(() => executePenalty(), 500);
      }

      function executePenalty() {
        const gk = document.getElementById("penaltyGK");
        const ball = document.getElementById("penaltyBall");
        const result = document.getElementById("penaltyResult");

        if (penaltyState.phase === "player_shoot") {
          // Player is shooting - use the currentShooter selected in setupPenaltyPhase
          const shooter = penaltyState.currentShooter;
          const shooting = shooter?.stats?.Shooting || shooter?.overall || 70;

          // Save as lastShooter for next selection
          penaltyState.lastShooter = shooter;

          // Opponent GK picks direction
          const directions = ["left", "center", "right"];
          const gkDirection = directions[Math.floor(Math.random() * 3)];

          // Calculate miss chance (lower shooting = higher miss chance)
          const missChance = Math.max(0.02, (100 - shooting) / 500);
          const didMiss = Math.random() < missChance;

          // Animate
          ball.classList.add("shoot-" + penaltyState.selectedDirection);
          gk.classList.add("dive-" + gkDirection);

          // Pudło - od razu szybki strzał
          if (didMiss) {
            setTimeout(() => {
              ball.classList.remove("shoot-" + penaltyState.selectedDirection);
              ball.classList.add("shoot-miss");
              result.textContent = t("youMissed");
              result.className = "penalty-result miss";
              penaltyState.playerShots.push("missed");
              playSaveSound();
              updatePenaltyUI();

              // Pudło - nie pokazuj karty, przejdź dalej
              setTimeout(() => {
                penaltyState.phase = "player_save";
                setupPenaltyPhase();
              }, 1500);
            }, 250);
          } else {
            setTimeout(() => {
              let scored = false;

              // Get opponent GK stats (based on match difficulty/opponent OVR)
              const opponentGKstat = penaltyState.opponentOVR || 65;

              if (penaltyState.selectedDirection === gkDirection) {
                // Same direction - środek = 100% obrona
                let saveChance;
                if (
                  penaltyState.selectedDirection === "center" &&
                  gkDirection === "center"
                ) {
                  saveChance = 1.0;
                } else {
                  // Base 40% + GK bonus (up to +25%) - Shooter penalty (up to -20%)
                  const gkBonus = (opponentGKstat - 50) / 200;
                  const shooterPenalty = (shooting - 50) / 250;
                  saveChance = Math.max(
                    0.15,
                    Math.min(0.85, 0.4 + gkBonus - shooterPenalty)
                  );
                }

                if (Math.random() < saveChance) {
                  result.textContent = t("opponentSaved");
                  result.className = "penalty-result save";
                  penaltyState.playerShots.push("saved");
                  document
                    .querySelector(`.goal-zone.${gkDirection}`)
                    ?.classList.add("highlight-red");
                  playSaveSound();
                } else {
                  scored = true;
                }
              } else {
                scored = true;
              }

              if (scored) {
                result.textContent = t("youScored");
                result.className = "penalty-result goal";
                penaltyState.playerScore++;
                penaltyState.playerShots.push("scored");
                document
                  .querySelector(`.goal-zone.${penaltyState.selectedDirection}`)
                  ?.classList.add("highlight-green");
                playGoalSound();
              }

              updatePenaltyUI();

              // Pokaż kartę strzelca TYLKO gdy strzelił gola
              if (scored) {
                showPenaltyCard(shooter, () => {
                  penaltyState.phase = "player_save";
                  setupPenaltyPhase();
                });
              } else {
                // Bramkarz obronił - nie pokazuj karty
                setTimeout(() => {
                  penaltyState.phase = "player_save";
                  setupPenaltyPhase();
                }, 1500);
              }
            }, 500);
          }
        } else if (penaltyState.phase === "player_save") {
          // Opponent is shooting, player is saving
          const shooter =
            penaltyState.opponentShooters[
              penaltyState.currentShooterIndex %
                penaltyState.opponentShooters.length
            ];
          const shooting = shooter?.stats?.Shooting || shooter?.overall || 70;

          // Opponent picks direction
          const directions = ["left", "center", "right"];
          const shootDirection = directions[Math.floor(Math.random() * 3)];

          // Player GK stats
          const playerGK = GameState.squad.players.find(
            (p) => p?.position === "GK"
          );
          const gkOverall = playerGK?.overall || 60;
          const defenseBonus = getTeamDefenseBonus();

          // Calculate miss chance for opponent
          const missChance = Math.max(0.02, (100 - shooting) / 400);
          const didMiss = Math.random() < missChance;

          // Animate
          ball.classList.add("shoot-" + shootDirection);
          gk.classList.add("dive-" + penaltyState.selectedDirection);

          // Pudło - od razu szybki strzał
          if (didMiss) {
            setTimeout(() => {
              ball.classList.remove("shoot-" + shootDirection);
              ball.classList.add("shoot-miss");
              result.textContent = t("opponentMissed");
              result.className = "penalty-result goal";
              penaltyState.opponentShots.push("missed");
              playSaveSound();
              updatePenaltyUI();

              // Pokaż kartę strzelca przeciwnika
              showPenaltyCard(shooter, () => {
                if (checkPenaltyEnd()) {
                  endPenalties();
                } else {
                  penaltyState.round++;
                  penaltyState.currentShooterIndex++;
                  penaltyState.phase = "player_shoot";
                  setupPenaltyPhase();
                }
              });
            }, 250);
          } else {
            setTimeout(() => {
              let scored = false;
              let saved = false;

              if (shootDirection === penaltyState.selectedDirection) {
                // Same direction - środek = 100% obrona
                let saveChance;
                if (
                  shootDirection === "center" &&
                  penaltyState.selectedDirection === "center"
                ) {
                  saveChance = 1.0;
                } else {
                  // Get actual GK stats
                  const gkStat = playerGK
                    ? ((playerGK.stats?.Diving || playerGK.overall) +
                        (playerGK.stats?.Reflexes || playerGK.overall) +
                        (playerGK.stats?.Positioning || playerGK.overall)) /
                      3
                    : 60;

                  // Base 40% + GK bonus (up to +25%) - Shooter penalty (up to -20%)
                  const gkBonus = (gkStat - 50) / 200;
                  const shooterPenalty = (shooting - 50) / 250;
                  saveChance = Math.max(
                    0.15,
                    Math.min(
                      0.85,
                      0.4 + gkBonus - shooterPenalty + defenseBonus / 100
                    )
                  );
                }

                if (Math.random() < saveChance) {
                  result.textContent = t("youSaved");
                  result.className = "penalty-result goal";
                  penaltyState.opponentShots.push("saved");
                  document
                    .querySelector(
                      `.goal-zone.${penaltyState.selectedDirection}`
                    )
                    ?.classList.add("highlight-green");
                  playSaveSound();
                  saved = true;
                } else {
                  scored = true;
                }
              } else {
                scored = true;
              }

              if (scored) {
                result.textContent = t("opponentScored");
                result.className = "penalty-result miss";
                penaltyState.opponentScore++;
                penaltyState.opponentShots.push("scored");
                document
                  .querySelector(`.goal-zone.${shootDirection}`)
                  ?.classList.add("highlight-red");
                playGoalSound();
              }

              updatePenaltyUI();

              // Pokaż kartę - strzelca lub bramkarza jeśli obronił
              const cardToShow = saved ? playerGK : shooter;
              showPenaltyCard(cardToShow, () => {
                if (checkPenaltyEnd()) {
                  endPenalties();
                } else {
                  penaltyState.round++;
                  penaltyState.currentShooterIndex++;
                  penaltyState.phase = "player_shoot";
                  setupPenaltyPhase();
                }
              });
            }, 500);
          }
        }
      }

      function getTeamDefenseBonus() {
        const defenders = GameState.squad.players.filter(
          (p) => p && ["CB", "LB", "RB", "CDM"].includes(p.position)
        );
        if (defenders.length === 0) return 0;
        const avgDef =
          defenders.reduce(
            (sum, p) => sum + (p.stats?.Defending || p.overall),
            0
          ) / defenders.length;
        return (avgDef - 50) / 5; // -10 to +10 bonus
      }

      function checkPenaltyEnd() {
        const playerShots = penaltyState.playerShots.length;
        const opponentShots = penaltyState.opponentShots.length;
        const remainingPlayer = penaltyState.maxRounds - playerShots;
        const remainingOpponent = penaltyState.maxRounds - opponentShots;

        // Normal end after 5 rounds each
        if (playerShots >= 5 && opponentShots >= 5) {
          if (penaltyState.playerScore !== penaltyState.opponentScore) {
            return true;
          }
          // Sudden death - extend
          penaltyState.maxRounds++;
          return false;
        }

        // Early end if mathematically impossible to catch up
        if (
          penaltyState.playerScore >
          penaltyState.opponentScore + remainingOpponent
        )
          return true;
        if (
          penaltyState.opponentScore >
          penaltyState.playerScore + remainingPlayer
        )
          return true;

        return false;
      }

      function endPenalties() {
        const result = document.getElementById("penaltyResult");
        const action = document.getElementById("penaltyAction");
        const buttons = document.getElementById("penaltyButtons");

        stopCrowdSound();
        clearInterval(penaltyState.shootTimer);

        // Hide surrender button
        document.getElementById("surrenderBtn").style.display = "none";

        let bonus = 0;
        let tpEarned = 0;
        const won = penaltyState.playerScore > penaltyState.opponentScore;

        // Arena system rewards/penalties
        if (
          GameState.match.difficulty === "arena" &&
          GameState.match.currentArena
        ) {
          const arena = GameState.match.currentArena;
          if (won) {
            bonus = arena.winReward;
            tpEarned = arena.tpReward;
            result.textContent = t("youWin");
            result.className = "penalty-result goal";
          } else {
            bonus = -arena.loseReward; // Lose money!
            tpEarned = Math.floor(arena.tpReward / 4); // 25% TP even on loss
            result.textContent = t("youLose");
            result.className = "penalty-result miss";
          }

          // Apply bonus (can't go below 0)
          GameState.manager.balance = Math.max(
            0,
            GameState.manager.balance + bonus
          );

          // Add training points
          GameState.trainingPoints = (GameState.trainingPoints || 0) + tpEarned;

          // Calculate match ratings for arena matches
          calculateMatchRatings(
            won,
            penaltyState.playerScore,
            penaltyState.opponentScore
          );
          checkForInjuries();
          checkWrongPositionPenalties();
        } else {
          // Fallback for old difficulty system (shouldn't happen anymore)
          if (won) {
            result.textContent = t("youWin");
            result.className = "penalty-result goal";
            bonus = 3000;
          } else {
            result.textContent = t("youLose");
            result.className = "penalty-result miss";
            bonus = 1000;
          }
          GameState.manager.balance += bonus;
        }

        updateAccountDisplay();

        action.textContent = `${t("finalScore")}: ${
          penaltyState.playerScore
        } - ${penaltyState.opponentScore}`;

        // Show end buttons
        buttons.innerHTML = `
                <button class="penalty-btn" onclick="exitPenalties()">${
                  currentLang === "pl" ? "🏠 MENU GŁÓWNE" : "🏠 MAIN MENU"
                }</button>
            `;
        buttons.style.display = "flex";

        document.getElementById("shooterInfo").style.display = "none";

        setTimeout(() => {
          const tpText =
            tpEarned > 0 ? `\n🎯 +${tpEarned} ${t("trainingPoints")}` : "";
          if (bonus >= 0) {
            alert(
              `${t("congrats")}\n\n${t(
                "reward"
              )}: +€${bonus.toLocaleString()}${tpText}`
            );
          } else {
            alert(
              `${t("lost")}\n\n${
                currentLang === "pl" ? "Strata" : "Lost"
              }: €${Math.abs(bonus).toLocaleString()}${tpText}`
            );
          }
        }, 300);

        autoSave();
      }

      // ==================== INJURY & PROTEST SYSTEM ====================

      function isPlayerInjured(player) {
        if (!player || !player.injuredUntil) return false;
        return Date.now() < player.injuredUntil;
      }

      function getInjuryTimeRemaining(player) {
        if (!player || !player.injuredUntil) return 0;
        const remaining = player.injuredUntil - Date.now();
        return Math.max(0, Math.ceil(remaining / (1000 * 60 * 60))); // hours
      }

      function checkForInjuries() {
        // 20% chance of injury after hard/online match
        if (Math.random() > 0.2) return;

        const allPlayers = GameState.squad.players.filter(
          (p) => p && !isPlayerInjured(p)
        );
        if (allPlayers.length === 0) return;

        // Random player gets injured
        const injuredPlayer =
          allPlayers[Math.floor(Math.random() * allPlayers.length)];

        // Injury lasts 24 hours
        injuredPlayer.injuredUntil = Date.now() + 24 * 60 * 60 * 1000;

        setTimeout(() => {
          alert(t("injuryAlert").replace("{player}", injuredPlayer.name));
        }, 500);

        autoSave();
      }

      function checkWrongPositionPenalties() {
        // Check if any player played in wrong position
        const squadPlayers = GameState.squad.players.filter((p) => p);

        squadPlayers.forEach((player, index) => {
          const requiredPosition = getRequiredPositionForSlot(index);

          // Check if player can play this position
          const canPlayPosition = canPlayerPlayPosition(
            player,
            requiredPosition
          );

          if (!canPlayPosition) {
            player.wrongPositionMatches =
              (player.wrongPositionMatches || 0) + 1;

            // After 2+ consecutive matches in wrong position, lose OVR
            if (player.wrongPositionMatches >= 2) {
              const ovrLoss = Math.min(3, player.wrongPositionMatches - 1);
              player.overall = Math.max(50, player.overall - ovrLoss);

              setTimeout(() => {
                alert(
                  t("overallDropped")
                    .replace("{player}", player.name)
                    .replace("{points}", ovrLoss)
                );
              }, 1000);
            }
          } else {
            player.wrongPositionMatches = 0;
          }
        });

        autoSave();
      }

      // Check if player can play a specific position (including similar positions)
      function canPlayerPlayPosition(player, requiredPosition) {
        const playerPositions = player.positions || [player.position];

        // Direct match
        if (playerPositions.includes(requiredPosition)) return true;
        if (player.position === requiredPosition) return true;
        if (player.originalPosition === requiredPosition) return true;

        // Similar positions groups - player can play similar positions without penalty
        const positionGroups = {
          // Defenders
          CB: ["CB", "LB", "RB", "LWB", "RWB"],
          LB: ["LB", "LWB", "CB", "RB"],
          RB: ["RB", "RWB", "CB", "LB"],
          LWB: ["LWB", "LB", "LM"],
          RWB: ["RWB", "RB", "RM"],
          // Midfielders
          CDM: ["CDM", "CM", "CB"],
          CM: ["CM", "CDM", "CAM", "LM", "RM"],
          CAM: ["CAM", "CM", "CF", "LW", "RW"],
          LM: ["LM", "LW", "CM", "LWB"],
          RM: ["RM", "RW", "CM", "RWB"],
          // Attackers
          LW: ["LW", "LM", "ST", "CF", "RW"],
          RW: ["RW", "RM", "ST", "CF", "LW"],
          CF: ["CF", "ST", "CAM", "LW", "RW"],
          ST: ["ST", "CF", "LW", "RW"],
          // Goalkeeper - only GK
          GK: ["GK"],
        };

        const similarPositions = positionGroups[requiredPosition] || [
          requiredPosition,
        ];

        // Check if any of player's positions is in the similar group
        for (const pos of playerPositions) {
          if (similarPositions.includes(pos)) return true;
        }

        return false;
      }

      function getRequiredPositionForSlot(slotIndex) {
        const formation = GameState.squad.formation || "4-3-3";
        const positions = {
          "4-3-3": [
            "GK",
            "LB",
            "CB",
            "CB",
            "RB",
            "CM",
            "CM",
            "CM",
            "LW",
            "ST",
            "RW",
          ],
          "4-4-2": [
            "GK",
            "LB",
            "CB",
            "CB",
            "RB",
            "LM",
            "CM",
            "CM",
            "RM",
            "ST",
            "ST",
          ],
          "3-5-2": [
            "GK",
            "CB",
            "CB",
            "CB",
            "CDM",
            "LM",
            "CM",
            "RM",
            "CAM",
            "ST",
            "ST",
          ],
          "4-2-3-1": [
            "GK",
            "LB",
            "CB",
            "CB",
            "RB",
            "CDM",
            "CDM",
            "LW",
            "CAM",
            "RW",
            "ST",
          ],
          "5-3-2": [
            "GK",
            "LB",
            "CB",
            "CB",
            "CB",
            "RB",
            "CM",
            "CM",
            "CM",
            "ST",
            "ST",
          ],
          "4-1-4-1": [
            "GK",
            "LB",
            "CB",
            "CB",
            "RB",
            "CDM",
            "LM",
            "CM",
            "CM",
            "RM",
            "ST",
          ],
        };
        return (positions[formation] || positions["4-3-3"])[slotIndex] || "CM";
      }

      let protestState = {
        player: null,
        type: null, // 'injury' or 'wrongPosition'
        fineAmount: 0,
        slotIndex: -1,
      };

      function checkPreMatchProtests() {
        // Check all squad players before match
        const issues = [];

        GameState.squad.players.forEach((player, index) => {
          if (!player) return;

          // Check injury
          if (isPlayerInjured(player)) {
            issues.push({
              player: player,
              type: "injury",
              slotIndex: index,
              message: t("injuryWarning").replace("{player}", player.name),
            });
          }

          // Check wrong position (using the smart position checking)
          const requiredPosition = getRequiredPositionForSlot(index);
          const canPlay = canPlayerPlayPosition(player, requiredPosition);

          if (!canPlay) {
            issues.push({
              player: player,
              type: "wrongPosition",
              slotIndex: index,
              message: t("wrongPositionWarning")
                .replace("{player}", player.name)
                .replace("{current}", requiredPosition)
                .replace(
                  "{original}",
                  player.originalPosition || player.position
                ),
            });
          }
        });

        return issues;
      }

      function showProtestModal(issue) {
        protestState = {
          player: issue.player,
          type: issue.type,
          slotIndex: issue.slotIndex,
          fineAmount: Math.floor(issue.player.salary * 10), // 10 weeks salary as fine
        };

        const protestText =
          issue.type === "injury"
            ? t("injuryProtest").replace("{player}", issue.player.name)
            : t("wrongPositionProtest").replace("{player}", issue.player.name);

        const result = confirm(
          `${protestText}\n\n` +
            `${t("protestOptions")}\n\n` +
            `${t("ignoreProtest")} - ${
              currentLang === "pl"
                ? "Gracz może odmówić i zażądać grzywny"
                : "Player may refuse and demand fine"
            }\n` +
            `${t("acceptProtest")} - ${
              currentLang === "pl"
                ? "Zdejmij gracza ze składu"
                : "Remove player from squad"
            }\n\n` +
            `${
              currentLang === "pl"
                ? "OK = Ignoruj, Anuluj = Zdejmij gracza"
                : "OK = Ignore, Cancel = Remove player"
            }`
        );

        if (result) {
          // Ignore protest - player may refuse
          handleIgnoredProtest();
        } else {
          // Accept - remove player
          handleAcceptedProtest();
        }
      }

      function handleIgnoredProtest() {
        // 50% chance player refuses and demands fine
        if (Math.random() < 0.5) {
          const fineMsg = t("playerRefuses")
            .replace("{player}", protestState.player.name)
            .replace("{amount}", protestState.fineAmount.toLocaleString());

          const payFine = confirm(
            `${fineMsg}\n\n` +
              `${t(
                "payFine"
              )}: €${protestState.fineAmount.toLocaleString()}\n\n` +
              `${
                currentLang === "pl"
                  ? "OK = Zapłać, Anuluj = Odmów"
                  : "OK = Pay, Cancel = Refuse"
              }`
          );

          if (payFine && GameState.manager.balance >= protestState.fineAmount) {
            GameState.manager.balance -= protestState.fineAmount;
            updateAccountDisplay();
            // Player still refuses to play
            banPlayerFromMatch(protestState.slotIndex);
          } else {
            // Player banned, no replacement allowed
            banPlayerFromMatch(protestState.slotIndex);
          }
        }
        // Else player reluctantly plays
      }

      function handleAcceptedProtest() {
        // Remove player from squad (move to bench)
        const player = GameState.squad.players[protestState.slotIndex];
        GameState.squad.players[protestState.slotIndex] = null;

        // Try to add to bench
        const emptyBenchSlot = GameState.squad.bench.findIndex((p) => !p);
        if (emptyBenchSlot !== -1) {
          GameState.squad.bench[emptyBenchSlot] = player;
        }

        autoSave();
      }

      function banPlayerFromMatch(slotIndex) {
        // Mark slot as banned for this match
        if (!GameState.match.bannedSlots) {
          GameState.match.bannedSlots = [];
        }
        GameState.match.bannedSlots.push(slotIndex);

        alert(t("playerBanned").replace("{player}", protestState.player.name));
      }

      function healInjuries() {
        // Check and heal injuries (call this periodically or on game load)
        const allPlayers = [
          ...(GameState.squad.players || []),
          ...(GameState.squad.bench || []),
        ];

        allPlayers.forEach((player) => {
          if (!player) return;

          if (player.injuredUntil && Date.now() >= player.injuredUntil) {
            player.injuredUntil = null;
            // Could show notification here
          }
        });
      }

      function calculateMatchRatings(won, playerScore, opponentScore) {
        // Get all players in squad
        const allPlayers = GameState.squad.players.filter((p) => p);
        if (allPlayers.length === 0) return;

        // Base rating depends on result
        let baseRating = won ? 7.0 : 5.5;

        // Adjust for goal difference
        const goalDiff = playerScore - opponentScore;
        baseRating += goalDiff * 0.3; // +0.3 per goal difference

        // Clamp base
        baseRating = Math.max(4, Math.min(9, baseRating));

        // Calculate individual ratings
        allPlayers.forEach((player) => {
          if (!player) return;

          // Initialize arrays if missing
          if (!player.matchRatings) player.matchRatings = [];

          let rating = baseRating;

          // Random variation (-0.5 to +1.0)
          rating += Math.random() * 1.5 - 0.5;

          // Bonus for overall (better players tend to play better)
          rating += (player.overall - 70) * 0.02;

          // Check if player scored in this match
          const scoredGoals =
            penaltyState.playerShots?.filter(
              (s) =>
                s.scored &&
                penaltyState.shooters?.[s.shooterIndex]?.id === player.id
            ).length || 0;

          if (scoredGoals > 0) {
            player.goals = (player.goals || 0) + scoredGoals;
            rating += scoredGoals * 0.5; // +0.5 per goal
          }

          // Goalkeeper bonuses
          if (player.position === "GK") {
            const savedShots =
              penaltyState.opponentShots?.filter((s) => !s.scored).length || 0;
            if (savedShots > 0) {
              player.saves = (player.saves || 0) + savedShots;
              rating += savedShots * 0.4; // +0.4 per save
            }
            if (opponentScore === 0) {
              player.cleanSheets = (player.cleanSheets || 0) + 1;
              rating += 1.0; // +1.0 for clean sheet
            }
          }

          // Clamp final rating to 0-10
          rating = Math.max(0, Math.min(10, rating));

          // Round to 1 decimal
          rating = Math.round(rating * 10) / 10;

          // Add to ratings history (keep last 20 matches)
          player.matchRatings.push(rating);
          if (player.matchRatings.length > 20) {
            player.matchRatings.shift();
          }

          // Increment games played
          player.gamesPlayed = (player.gamesPlayed || 0) + 1;
        });
      }

      function playAgain() {
        if (GameState.match.difficulty === "arena") {
          playArenaMatch();
        } else {
          startPenalties(GameState.match.difficulty);
        }
      }

      function surrenderPenalties() {
        if (confirm(t("surrenderConfirm"))) {
          // Opponent wins automatically
          penaltyState.opponentScore = penaltyState.playerScore + 1;
          endPenalties();
        }
      }

      function exitPenalties() {
        stopCrowdSound();
        clearInterval(penaltyState.shootTimer);

        // Full reset of penalty state
        penaltyState = {
          round: 1,
          maxRounds: 5,
          playerScore: 0,
          opponentScore: 0,
          playerShots: [],
          opponentShots: [],
          phase: "player_shoot",
          shooters: [],
          opponentShooters: [],
          currentShooterIndex: 0,
          selectedDirection: null,
          opponentOVR: 50,
          lastShooter: null,
          currentShooter: null,
          timeLeft: 15,
        };

        // Reset UI elements
        const result = document.getElementById("penaltyResult");
        const action = document.getElementById("penaltyAction");
        const buttons = document.getElementById("penaltyButtons");

        if (result) {
          result.textContent = "";
          result.className = "penalty-result";
        }
        if (action) action.textContent = "";

        // Restore direction buttons
        if (buttons) {
          buttons.innerHTML = `
                    <button class="penalty-btn" onclick="selectPenaltyDirection('left')">⬅️ ${
                      currentLang === "pl" ? "LEWO" : "LEFT"
                    }</button>
                    <button class="penalty-btn" onclick="selectPenaltyDirection('center')">⬆️ ${
                      currentLang === "pl" ? "ŚRODEK" : "CENTER"
                    }</button>
                    <button class="penalty-btn" onclick="selectPenaltyDirection('right')">➡️ ${
                      currentLang === "pl" ? "PRAWO" : "RIGHT"
                    }</button>
                `;
          buttons.style.display = "flex";
        }

        document.getElementById("penaltyScorePlayer").textContent = "0";
        document.getElementById("penaltyScoreOpponent").textContent = "0";

        // Reset GK and ball positions
        const gk = document.getElementById("penaltyGK");
        const ball = document.getElementById("penaltyBall");
        if (gk) gk.className = "goalkeeper-penalty";
        if (ball) ball.className = "ball-penalty";

        // Reset goal zones
        document
          .querySelectorAll(".goal-zone")
          .forEach((z) => (z.className = "goal-zone " + z.dataset.zone));

        // Reset dots
        document
          .querySelectorAll("#playerDots .dot, #opponentDots .dot")
          .forEach((dot) => {
            dot.className = "dot";
          });

        showScreen("playMenu");
      }

      // ==================== ONLINE PENALTIES ====================
      let penaltyPeer = null;
      let penaltyConn = null;
      let isOnlinePenalty = false;
      let isPenaltyHost = false;
      let onlinePenaltyState = {
        myChoice: null,
        opponentChoice: null,
        phase: "waiting", // 'waiting', 'choosing', 'result'
      };

      function createPenaltyRoom() {
        if (typeof Peer === "undefined") {
          alert(t("connectionError"));
          return;
        }

        // FULL RESET for new online match
        fullResetOnlineMatch();

        document.getElementById("onlinePenaltyChoice").style.display = "none";
        document.getElementById("hostPenaltySection").style.display = "block";

        isPenaltyHost = true;

        // Create peer with custom config
        penaltyPeer = new Peer({
          config: {
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              { urls: "stun:stun1.l.google.com:19302" },
              { urls: "stun:stun2.l.google.com:19302" },
            ],
          },
          debug: 0,
        });

        penaltyPeer.on("open", (id) => {
          const currentUrl = window.location.origin + window.location.pathname;
          const shareLink = currentUrl + "?room=" + id;
          document.getElementById("penaltyRoomCode").textContent = shareLink;
          document.getElementById("penaltyHostStatus").textContent =
            t("roomReady");
        });

        penaltyPeer.on("connection", (conn) => {
          penaltyConn = conn;
          document.getElementById("penaltyHostStatus").textContent =
            t("opponentJoined");
          document.getElementById("startOnlinePenaltyBtn").disabled = false;

          conn.on("data", handlePenaltyData);
          conn.on("close", () => {
            alert(t("opponentDisconnected"));
            leavePenaltyLobby();
          });
        });

        penaltyPeer.on("error", (err) => {
          console.error("PeerJS error:", err);
          document.getElementById("penaltyHostStatus").textContent =
            t("connectionError");
        });
      }

      function fullResetOnlineMatch() {
        // Reset ALL online state for fresh new match
        isOnlinePenalty = false;
        isPenaltyHost = false;
        opponentName = "";

        // Close old connections
        if (penaltyConn) {
          try {
            penaltyConn.close();
          } catch (e) {}
          penaltyConn = null;
        }
        if (penaltyPeer) {
          try {
            penaltyPeer.destroy();
          } catch (e) {}
          penaltyPeer = null;
        }

        // Reset penalty state
        penaltyState = {
          round: 1,
          maxRounds: 5,
          playerScore: 0,
          opponentScore: 0,
          playerShots: [],
          opponentShots: [],
          phase: "player_shoot",
          shooters: getPlayerShooters(),
          opponentShooters: [],
          currentShooterIndex: 0,
          selectedDirection: null,
          shootTimer: null,
          timeLeft: 15,
          lastShooter: null,
          currentShooter: null,
        };

        // Reset online penalty state
        onlinePenaltyState = {
          myChoice: null,
          opponentChoice: null,
          resolved: false,
        };

        // Reset squad reveal state
        squadRevealState = {
          currentIndex: 0,
          allPlayers: [],
          positions: [],
          isReady: false,
          opponentReady: false,
          opponentSquad: null,
          opponentName: "",
        };
      }

      function joinPenaltyRoom() {
        if (typeof Peer === "undefined") {
          alert(t("connectionError"));
          return;
        }

        let code = document.getElementById("joinPenaltyInput").value.trim();
        if (!code) {
          alert(t("pasteCodeAlert"));
          return;
        }

        // FULL RESET for new online match
        fullResetOnlineMatch();

        // Extract code from full URL if pasted
        if (code.includes("?room=")) {
          const match = code.match(/room=([^&]+)/);
          if (match) code = match[1];
        } else if (code.includes("?penalty=")) {
          const match = code.match(/penalty=([^&]+)/);
          if (match) code = match[1];
        }

        document.getElementById("onlinePenaltyChoice").style.display = "none";
        document.getElementById("guestPenaltySection").style.display = "block";

        isPenaltyHost = false;

        // Create peer with custom config
        penaltyPeer = new Peer({
          config: {
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              { urls: "stun:stun1.l.google.com:19302" },
              { urls: "stun:stun2.l.google.com:19302" },
            ],
          },
          debug: 0,
        });

        penaltyPeer.on("open", () => {
          document.getElementById("penaltyGuestStatus").textContent =
            t("connecting");
          penaltyConn = penaltyPeer.connect(code);

          penaltyConn.on("open", () => {
            document.getElementById("penaltyGuestStatus").textContent =
              t("connected");
          });

          penaltyConn.on("data", handlePenaltyData);

          penaltyConn.on("close", () => {
            alert(t("hostDisconnected"));
            leavePenaltyLobby();
          });

          penaltyConn.on("error", (err) => {
            console.error("Connection error:", err);
            document.getElementById("penaltyGuestStatus").textContent =
              t("cannotConnect");
          });
        });

        penaltyPeer.on("error", (err) => {
          console.error("PeerJS error:", err);
          document.getElementById("penaltyGuestStatus").textContent =
            t("connectionError") + " " + t("checkCode");
        });
      }

      function copyPenaltyCode() {
        const link = document.getElementById("penaltyRoomCode").textContent;
        navigator.clipboard.writeText(link);
        alert(t("linkCopied"));
      }

      function leavePenaltyLobby() {
        if (penaltyConn) penaltyConn.close();
        if (penaltyPeer) penaltyPeer.destroy();
        penaltyConn = null;
        penaltyPeer = null;
        isOnlinePenalty = false;

        document.getElementById("onlinePenaltyChoice").style.display = "block";
        document.getElementById("hostPenaltySection").style.display = "none";
        document.getElementById("guestPenaltySection").style.display = "none";

        showScreen("playMenu");
      }

      // Opponent name
      let opponentName = "";

      function startOnlinePenalty() {
        isOnlinePenalty = true;

        // Send start signal with squad, name and arena to guest
        penaltyConn.send({
          type: "start_penalty",
          squad: getSquadForReveal(),
          name: GameState.manager.name || "Manager",
          arena: GameState.arena.current,
        });

        // Show waiting overlay - will start reveal when guest sends their squad
        const overlay = document.getElementById("squadRevealOverlay");
        overlay.style.display = "flex";
        document.getElementById("squadRevealFull").style.display = "none";
        document.getElementById("squadRevealCardContainer").style.display =
          "none";
        document.getElementById("squadRevealPosition").style.display = "none";
        document.getElementById("squadRevealProgress").style.display = "none";
        document.getElementById("squadRevealTitle").textContent =
          currentLang === "pl"
            ? "Oczekiwanie na skład przeciwnika..."
            : "Waiting for opponent squad...";
      }

      // Get squad organized by position for reveal
      function getSquadForReveal() {
        const squad = {
          gk: [],
          def: [],
          mid: [],
          att: [],
        };

        GameState.squad.players.forEach((p) => {
          if (!p) return;
          const pos = p.position;
          if (pos === "GK") squad.gk.push(p);
          else if (["CB", "LB", "RB", "LWB", "RWB"].includes(pos))
            squad.def.push(p);
          else if (["CDM", "CM", "CAM", "LM", "RM"].includes(pos))
            squad.mid.push(p);
          else squad.att.push(p);
        });

        return squad;
      }

      // Squad reveal animation state
      let squadRevealState = {
        currentIndex: 0,
        allPlayers: [],
        positions: [],
        isReady: false,
        opponentReady: false,
        opponentSquad: null,
        opponentName: "",
      };

      function startSquadReveal(isHost) {
        const overlay = document.getElementById("squadRevealOverlay");
        overlay.style.display = "flex";

        // Hide full squad, show card reveal
        document.getElementById("squadRevealFull").style.display = "none";
        document.getElementById("squadRevealCardContainer").style.display =
          "block";
        document.getElementById("squadRevealPosition").style.display = "block";
        document.getElementById("squadRevealProgress").style.display = "flex";

        // Use OPPONENT's squad
        const squad = squadRevealState.opponentSquad || {
          gk: [],
          def: [],
          mid: [],
          att: [],
        };

        // Full reset of reveal state (but keep opponent data)
        const oppSquad = squadRevealState.opponentSquad;
        const oppName = squadRevealState.opponentName;
        squadRevealState.currentIndex = 0;
        squadRevealState.allPlayers = [];
        squadRevealState.positions = [];
        squadRevealState.isReady = false;
        squadRevealState.opponentReady = false;
        squadRevealState.opponentSquad = oppSquad;
        squadRevealState.opponentName = oppName;

        // Add players with position labels
        if (squad.gk && squad.gk.length > 0) {
          squad.gk.forEach((p) => {
            squadRevealState.allPlayers.push(p);
            squadRevealState.positions.push("goalkeeper");
          });
        }
        if (squad.def && squad.def.length > 0) {
          squad.def.forEach((p, i) => {
            squadRevealState.allPlayers.push(p);
            squadRevealState.positions.push(i === 0 ? "defenders" : "");
          });
        }
        if (squad.mid && squad.mid.length > 0) {
          squad.mid.forEach((p, i) => {
            squadRevealState.allPlayers.push(p);
            squadRevealState.positions.push(i === 0 ? "midfielders" : "");
          });
        }
        if (squad.att && squad.att.length > 0) {
          squad.att.forEach((p, i) => {
            squadRevealState.allPlayers.push(p);
            squadRevealState.positions.push(i === 0 ? "attackers" : "");
          });
        }

        // If no players, show waiting message
        if (squadRevealState.allPlayers.length === 0) {
          document.getElementById("squadRevealTitle").textContent =
            currentLang === "pl"
              ? "Oczekiwanie na skład przeciwnika..."
              : "Waiting for opponent squad...";
          document.getElementById("squadRevealCardContainer").style.display =
            "none";
          document.getElementById("squadRevealPosition").style.display = "none";
          document.getElementById("squadRevealProgress").style.display = "none";
          return;
        }

        // Generate progress dots
        const dotsContainer = document.getElementById("squadRevealProgress");
        dotsContainer.innerHTML = squadRevealState.allPlayers
          .map(
            (_, i) => `<div class="squad-reveal-dot" id="revealDot${i}"></div>`
          )
          .join("");

        // Update title - showing OPPONENT's squad
        const displayName =
          squadRevealState.opponentName ||
          (currentLang === "pl" ? "Przeciwnik" : "Opponent");
        document.getElementById("squadRevealTitle").textContent =
          currentLang === "pl"
            ? `Skład: ${displayName}`
            : `Squad: ${displayName}`;

        // Start reveal
        revealNextCard();
      }

      function revealNextCard() {
        const { currentIndex, allPlayers, positions } = squadRevealState;

        if (currentIndex >= allPlayers.length) {
          // All cards revealed, show full squad
          showFullSquadReveal();
          return;
        }

        const player = allPlayers[currentIndex];
        const posLabel = positions[currentIndex];

        // Update position label if new category
        if (posLabel) {
          document.getElementById("squadRevealPosition").textContent =
            t(posLabel);
        }

        // Show card with animation
        const container = document.getElementById("squadRevealCardContainer");
        container.innerHTML = `<div class="squad-reveal-card">${renderPlayerCard(
          player,
          false
        )}</div>`;

        // Update progress dots
        for (let i = 0; i <= currentIndex; i++) {
          const dot = document.getElementById(`revealDot${i}`);
          if (dot) {
            dot.classList.remove("active");
            dot.classList.add("done");
          }
        }
        if (currentIndex < allPlayers.length) {
          const currentDot = document.getElementById(
            `revealDot${currentIndex}`
          );
          if (currentDot) currentDot.classList.add("active");
        }

        squadRevealState.currentIndex++;

        // Next card after delay
        setTimeout(revealNextCard, 1200);
      }

      function showFullSquadReveal() {
        // Hide single card, show full squad
        document.getElementById("squadRevealCardContainer").style.display =
          "none";
        document.getElementById("squadRevealPosition").style.display = "none";
        document.getElementById("squadRevealProgress").style.display = "none";
        document.getElementById("squadRevealFull").style.display = "flex";

        // Set names - showing OPPONENT's squad
        const oppName =
          squadRevealState.opponentName || opponentName || t("opponent");
        document.getElementById("squadRevealMyName").textContent =
          currentLang === "pl" ? `Skład: ${oppName}` : `Squad: ${oppName}`;
        document.getElementById("squadRevealOpponentName").textContent = "";

        // Build formation display using OPPONENT's squad
        const squad = squadRevealState.opponentSquad || {
          gk: [],
          def: [],
          mid: [],
          att: [],
        };
        const formationContainer = document.getElementById(
          "squadRevealFormation"
        );

        let html = "";

        // Attackers (top)
        if (squad.att && squad.att.length > 0) {
          html += `<div class="squad-reveal-row">${squad.att
            .map((p) => renderMiniCard(p))
            .join("")}</div>`;
        }

        // Midfielders
        if (squad.mid && squad.mid.length > 0) {
          html += `<div class="squad-reveal-row">${squad.mid
            .map((p) => renderMiniCard(p))
            .join("")}</div>`;
        }

        // Defenders
        if (squad.def && squad.def.length > 0) {
          html += `<div class="squad-reveal-row">${squad.def
            .map((p) => renderMiniCard(p))
            .join("")}</div>`;
        }

        // Goalkeeper (bottom)
        if (squad.gk && squad.gk.length > 0) {
          html += `<div class="squad-reveal-row">${squad.gk
            .map((p) => renderMiniCard(p))
            .join("")}</div>`;
        }

        // If no players at all, show placeholder
        if (html === "") {
          html = `<div style="color: var(--silver); padding: 2rem;">${
            currentLang === "pl" ? "Brak danych o składzie" : "No squad data"
          }</div>`;
        }

        formationContainer.innerHTML = html;

        // ALWAYS show ready button
        const readyBtn = document.getElementById("squadRevealReadyBtn");
        readyBtn.style.display = "block";
        readyBtn.textContent = t("ready");
        readyBtn.disabled = false;

        document.getElementById("squadRevealWaiting").style.display = "none";
      }

      // Mini card for squad reveal (simpler than full card)
      function renderMiniCard(player) {
        if (!player) return "";
        const rarity = getRarityFromOverall(player.overall);
        return `
                <div class="mini-reveal-card ${rarity}">
                    <div class="mini-card-ovr">${player.overall}</div>
                    <div class="mini-card-pos">${player.position}</div>
                    <div class="mini-card-name">${
                      player.name || "Unknown"
                    }</div>
                </div>
            `;
      }

      function confirmSquadReady() {
        squadRevealState.isReady = true;

        // Send ready signal
        penaltyConn.send({ type: "squad_ready" });

        // Hide button, show waiting
        document.getElementById("squadRevealReadyBtn").style.display = "none";
        document.getElementById("squadRevealWaiting").style.display = "block";
        document.getElementById("squadRevealWaiting").textContent =
          t("waitingForOpponent");

        // Check if both ready
        checkBothReady();
      }

      function checkBothReady() {
        if (squadRevealState.isReady && squadRevealState.opponentReady) {
          document.getElementById("squadRevealWaiting").textContent =
            t("bothReady");

          // Start penalties after short delay
          setTimeout(() => {
            document.getElementById("squadRevealOverlay").style.display =
              "none";
            actuallyStartOnlinePenalty();
          }, 1500);
        }
      }

      function actuallyStartOnlinePenalty() {
        // Initialize online penalty state - FULL RESET
        penaltyState = {
          round: 1,
          maxRounds: 5,
          playerScore: 0,
          opponentScore: 0,
          playerShots: [],
          opponentShots: [],
          phase: isPenaltyHost ? "player_shoot" : "player_save",
          shooters: getPlayerShooters(),
          opponentShooters: [],
          currentShooterIndex: 0,
          selectedDirection: null,
          lastShooter: null,
          currentShooter: null,
        };

        // Reset online state too
        onlinePenaltyState = {
          myChoice: null,
          opponentChoice: null,
          resolved: false,
        };

        showScreen("penaltyScreen");

        // Reset dots visually
        document
          .querySelectorAll("#playerDots .dot, #opponentDots .dot")
          .forEach((dot) => {
            dot.className = "dot";
          });

        // Set player names
        const myName = GameState.manager.name || t("you");
        const oppName = opponentName || t("opponent");
        document.getElementById("penaltyPlayerLabel").textContent = myName;
        document.getElementById("penaltyOpponentLabel").textContent = oppName;

        // Show surrender button
        document.getElementById("surrenderBtn").style.display = "block";
        document.getElementById("surrenderBtn").onclick =
          surrenderOnlinePenalties;

        initCrowdSound();
        updatePenaltyUI();
        setupOnlinePenaltyPhase();
      }

      function handlePenaltyData(data) {
        if (data.type === "start_penalty") {
          // Check if arenas match
          if (data.arena !== GameState.arena.current) {
            const hostArena = ARENAS.find((a) => a.id === data.arena);
            const myArena = ARENAS.find(
              (a) => a.id === GameState.arena.current
            );
            const hostArenaName = hostArena
              ? getArenaName(hostArena)
              : data.arena;
            const myArenaName = myArena
              ? getArenaName(myArena)
              : GameState.arena.current;

            alert(
              currentLang === "pl"
                ? `Nie możesz grać! Przeciwnik ma włączoną inną arenę.\n\nTwoja arena: ${myArenaName}\nArena przeciwnika: ${hostArenaName}`
                : `Cannot play! Opponent has different arena selected.\n\nYour arena: ${myArenaName}\nOpponent arena: ${hostArenaName}`
            );

            penaltyConn.send({ type: "arena_mismatch" });
            leavePenaltyLobby();
            return;
          }

          // Store the arena for rewards
          onlinePenaltyState.arena = data.arena;

          isOnlinePenalty = true;

          // Store opponent squad and name (host's squad)
          if (data.squad) {
            squadRevealState.opponentSquad = data.squad;
            // Also save for GK stats lookup
            onlinePenaltyState.opponentSquad = data.squad;
          }
          if (data.name) {
            opponentName = data.name;
            squadRevealState.opponentName = data.name;
          }

          // Send my name AND my squad AND arena confirmation back to host
          penaltyConn.send({
            type: "player_info",
            name: GameState.manager.name || "Manager",
            squad: getSquadForReveal(),
            arena: GameState.arena.current,
          });

          // Start squad reveal for guest - show OPPONENT's squad (host)
          startSquadReveal(false);
        }

        if (data.type === "arena_mismatch") {
          alert(
            currentLang === "pl"
              ? "Przeciwnik ma włączoną inną arenę. Nie możecie grać razem."
              : "Opponent has different arena selected. You cannot play together."
          );
          leavePenaltyLobby();
          return;
        }

        if (data.type === "player_info") {
          // Host receives guest name AND squad
          opponentName = data.name || "Manager";
          squadRevealState.opponentName = data.name || "Manager";

          // Store arena for rewards
          onlinePenaltyState.arena = GameState.arena.current;

          if (data.squad) {
            squadRevealState.opponentSquad = data.squad;
            // Also save for GK stats lookup
            onlinePenaltyState.opponentSquad = data.squad;
            // NOW host can start reveal with opponent's squad
            startSquadReveal(true);
          }
        }

        if (data.type === "squad_ready") {
          squadRevealState.opponentReady = true;
          checkBothReady();
        }

        if (data.type === "penalty_choice") {
          // Opponent made their choice
          onlinePenaltyState.opponentChoice = data.direction;

          // Check if both ready to show animation
          checkBothPlayersReady();
        }

        if (data.type === "rematch_request") {
          if (confirm(t("wantRematch"))) {
            penaltyConn.send({ type: "rematch_accept" });
            // Full reset and restart for new match
            startRematch();
          } else {
            penaltyConn.send({ type: "rematch_decline" });
          }
        }

        if (data.type === "rematch_accept") {
          // Full reset and restart for new match
          startRematch();
        }

        if (data.type === "rematch_decline") {
          alert(t("rematchDeclined"));
        }

        if (data.type === "surrender") {
          // Opponent surrendered - I win
          penaltyState.playerScore = 5;
          penaltyState.opponentScore = 0;
          endOnlinePenaltyGame();
        }
      }

      function resetOnlinePenaltyState() {
        // FULL reset for new match - prevent memory leaks

        // Clear any timers
        if (penaltyState.shootTimer) {
          clearInterval(penaltyState.shootTimer);
        }

        // Reset penalty state completely
        penaltyState = {
          round: 1,
          maxRounds: 5,
          playerScore: 0,
          opponentScore: 0,
          playerShots: [],
          opponentShots: [],
          phase: isPenaltyHost ? "player_shoot" : "player_save",
          shooters: getPlayerShooters(),
          opponentShooters: onlinePenaltyState.opponentShooters || [],
          currentShooterIndex: 0,
          selectedDirection: null,
          lastShooter: null,
          currentShooter: null,
          shootTimer: null,
          opponentOVR: onlinePenaltyState.opponentOVR || 70,
        };

        // Reset online state
        onlinePenaltyState.myChoice = null;
        onlinePenaltyState.opponentChoice = null;
        onlinePenaltyState.resolved = false;

        // Reset squad reveal state for potential future reveals
        squadRevealState.isReady = false;
        squadRevealState.opponentReady = false;

        // Reset visual elements
        const gk = document.getElementById("penaltyGK");
        const ball = document.getElementById("penaltyBall");
        const result = document.getElementById("penaltyResult");

        if (gk) gk.className = "goalkeeper-penalty";
        if (ball) ball.className = "ball-penalty";
        if (result) {
          result.textContent = "";
          result.className = "penalty-result";
        }

        // Reset dots
        document
          .querySelectorAll("#playerDots .dot, #opponentDots .dot")
          .forEach((dot) => {
            dot.className = "dot";
          });

        // Reset goal zones
        document.querySelectorAll(".goal-zone").forEach((z) => {
          z.classList.remove("highlight-green", "highlight-red", "selected");
        });

        // Show surrender button again
        const surrenderBtn = document.getElementById("surrenderBtn");
        if (surrenderBtn) surrenderBtn.style.display = "block";

        updatePenaltyUI();
      }

      function startRematch() {
        // Full reset for clean new match
        resetOnlinePenaltyState();

        // Update player names display
        const myName = GameState.manager.name || t("you");
        const oppName = opponentName || t("opponent");
        document.getElementById("playerName").textContent = myName;
        document.getElementById("opponentNameDisplay").textContent = oppName;

        // Make sure we're on penalty screen
        showScreen("penaltyScreen");

        // Start the new match
        setupOnlinePenaltyPhase();
      }

      function setupOnlinePenaltyPhase() {
        onlinePenaltyState.myChoice = null;
        onlinePenaltyState.opponentChoice = null;
        onlinePenaltyState.resolved = false;

        const actionEl = document.getElementById("penaltyAction");
        const shooterInfo = document.getElementById("shooterInfo");
        const shooterName = document.getElementById("shooterName");
        const shooterStats = document.getElementById("shooterStats");
        const buttons = document.getElementById("penaltyButtons");
        const result = document.getElementById("penaltyResult");
        const gk = document.getElementById("penaltyGK");
        const ball = document.getElementById("penaltyBall");

        // Reset visuals
        result.textContent = "";
        result.className = "penalty-result";
        gk.className = "goalkeeper-penalty";
        ball.className = "ball-penalty";
        document.querySelectorAll(".goal-zone").forEach((z) => {
          z.className = "goal-zone " + z.dataset.zone;
          z.classList.remove("selected");
        });

        // GENERATE BUTTONS for online mode
        buttons.innerHTML = `
                <button class="penalty-btn" onclick="selectOnlinePenaltyDirection('left')">⬅️ ${
                  currentLang === "pl" ? "LEWO" : "LEFT"
                }</button>
                <button class="penalty-btn" onclick="selectOnlinePenaltyDirection('center')">⬆️ ${
                  currentLang === "pl" ? "ŚRODEK" : "CENTER"
                }</button>
                <button class="penalty-btn" onclick="selectOnlinePenaltyDirection('right')">➡️ ${
                  currentLang === "pl" ? "PRAWO" : "RIGHT"
                }</button>
            `;
        buttons.style.display = "flex";

        // UPDATE BIG ACTION INDICATOR
        const indicator = document.getElementById("penaltyActionIndicator");

        if (penaltyState.phase === "player_shoot") {
          // Select shooter based on attack stats
          const shooter = selectNextShooter();
          penaltyState.currentShooter = shooter;

          indicator.className = "penalty-action-indicator shooting";
          indicator.textContent =
            currentLang === "pl" ? "⚽ STRZELASZ!" : "⚽ SHOOT!";

          actionEl.textContent = t("chooseShot");
          shooterName.textContent =
            (currentLang === "pl" ? "Strzela: " : "Shoots: ") +
            (shooter?.name || "Strzelec");
          shooterStats.textContent = `ATK: ${Math.round(
            calculateAttackScore(shooter)
          )}`;
        } else {
          indicator.className = "penalty-action-indicator saving";
          indicator.textContent =
            currentLang === "pl" ? "🧤 BRONISZ!" : "🧤 SAVE!";

          actionEl.textContent = t("chooseDefense");
          shooterName.textContent = t("opponentShoots");
          shooterStats.textContent = "";
        }

        shooterInfo.style.display = "block";

        // Also allow clicking on goal zones
        document.querySelectorAll(".goal-zone").forEach((zone) => {
          zone.onclick = () => selectOnlinePenaltyDirection(zone.dataset.zone);
        });
      }

      function selectOnlinePenaltyDirection(direction) {
        if (onlinePenaltyState.myChoice) return;

        onlinePenaltyState.myChoice = direction;

        // Highlight my choice
        document
          .querySelectorAll(".goal-zone")
          .forEach((z) => z.classList.remove("selected"));
        document
          .querySelector(`.goal-zone.${direction}`)
          ?.classList.add("selected");

        // Hide buttons, show waiting
        document.getElementById("penaltyButtons").style.display = "none";
        document.getElementById("penaltyAction").textContent =
          t("waitingOpponent");

        // Send my choice to opponent
        penaltyConn.send({ type: "penalty_choice", direction: direction });

        // Check if both ready
        checkBothPlayersReady();
      }

      function checkBothPlayersReady() {
        // Both players must have chosen
        if (
          !onlinePenaltyState.myChoice ||
          !onlinePenaltyState.opponentChoice
        ) {
          return; // Still waiting
        }

        // Both chose! Now show animation
        showOnlinePenaltyAnimation();
      }

      function showOnlinePenaltyAnimation() {
        const gk = document.getElementById("penaltyGK");
        const ball = document.getElementById("penaltyBall");
        const result = document.getElementById("penaltyResult");

        // Determine who shot and who saved based on phase
        let shootDir, saveDir;

        if (penaltyState.phase === "player_shoot") {
          // I'm shooting, opponent is saving
          shootDir = onlinePenaltyState.myChoice;
          saveDir = onlinePenaltyState.opponentChoice;
        } else {
          // I'm saving, opponent is shooting
          shootDir = onlinePenaltyState.opponentChoice;
          saveDir = onlinePenaltyState.myChoice;
        }

        // Animate ball and goalkeeper
        ball.classList.add("shoot-" + shootDir);
        gk.classList.add("dive-" + saveDir);

        // Calculate result after animation starts
        setTimeout(() => {
          // Use FULLY deterministic result based ONLY on directions and round
          // This ensures BOTH players get the SAME result
          const roundSeed =
            penaltyState.round + penaltyState.currentShooterIndex;
          const phaseBonus = penaltyState.phase === "player_shoot" ? 100 : 200;

          // Create seed from directions + round + phase (same for both players!)
          const seedString = shootDir + saveDir + roundSeed + phaseBonus;
          const seed = seedString
            .split("")
            .reduce((a, c) => a + c.charCodeAt(0), 0);

          // Deterministic "random" numbers
          const pseudoRandom1 = ((seed * 9301 + 49297) % 233280) / 233280;
          const pseudoRandom2 = (((seed + 7) * 9301 + 49297) % 233280) / 233280;

          // Simple deterministic rules:
          // - Miss chance: 5% always
          // - If same direction: 50% save chance
          // - Different direction: always goal

          const didMiss = pseudoRandom1 < 0.05;
          const wasSaved =
            !didMiss && shootDir === saveDir && pseudoRandom2 < 0.5;
          const scored = !didMiss && !wasSaved;

          const iWasShooter = penaltyState.phase === "player_shoot";

          // Get players for card display
          let shooter, gkPlayer;
          if (iWasShooter) {
            shooter =
              penaltyState.currentShooter ||
              penaltyState.shooters[
                penaltyState.currentShooterIndex %
                  Math.max(1, penaltyState.shooters.length)
              ];
            gkPlayer = GameState.squad.players.find(
              (p) => p?.position === "GK"
            );
          } else {
            shooter = { name: opponentName || "Opponent", overall: 70 };
            gkPlayer = GameState.squad.players.find(
              (p) => p?.position === "GK"
            );
          }

          // Show result
          let resultText = "";
          let resultClass = "";

          if (didMiss) {
            ball.classList.remove("shoot-" + shootDir);
            ball.classList.add("shoot-miss");
            resultText = iWasShooter ? t("youMissed") : t("opponentMissed");
            resultClass = iWasShooter ? "miss" : "goal";
          } else if (wasSaved) {
            resultText = iWasShooter ? t("opponentSaved") : t("youSaved");
            resultClass = iWasShooter ? "save" : "goal";
          } else {
            if (iWasShooter) {
              resultText = t("youScored");
              resultClass = "goal";
            } else {
              resultText = t("opponentScored");
              resultClass = "miss";
            }
          }

          result.textContent = resultText;
          result.className = "penalty-result " + resultClass;

          // Update scores
          if (scored) {
            if (iWasShooter) {
              penaltyState.playerScore++;
              penaltyState.playerShots.push("scored");
            } else {
              penaltyState.opponentScore++;
              penaltyState.opponentShots.push("scored");
            }
            playGoalSound();
          } else {
            if (iWasShooter) {
              penaltyState.playerShots.push("missed");
            } else {
              penaltyState.opponentShots.push("missed");
            }
            playSaveSound();
          }

          updatePenaltyUI();

          // Show card for the shooter or goalkeeper who saved
          const cardToShow = scored ? shooter : wasSaved ? gkPlayer : null;

          if (cardToShow) {
            showPenaltyCard(cardToShow, () => {
              proceedToNextOnlineRound();
            });
          } else {
            setTimeout(() => {
              proceedToNextOnlineRound();
            }, 1500);
          }
        }, 600);
      }

      function proceedToNextOnlineRound() {
        // Count shots
        const playerShots = penaltyState.playerShots.length;
        const opponentShots = penaltyState.opponentShots.length;

        // Check if both sides have taken same number of shots
        const bothShotsSame = playerShots === opponentShots;

        // After 5 rounds each (10 total shots)
        if (bothShotsSame && playerShots >= 5) {
          // Check for winner
          if (penaltyState.playerScore !== penaltyState.opponentScore) {
            endOnlinePenaltyGame();
            return;
          }
          // Tie after 5 rounds - continue to sudden death
          penaltyState.maxRounds = playerShots + 1;
        }

        // Sudden death - after each pair of shots, check winner
        if (bothShotsSame && playerShots > 5) {
          if (penaltyState.playerScore !== penaltyState.opponentScore) {
            endOnlinePenaltyGame();
            return;
          }
          // Still tied - continue sudden death
          penaltyState.maxRounds = playerShots + 1;
        }

        // Next phase
        if (penaltyState.phase === "player_save") {
          penaltyState.round++;
          penaltyState.currentShooterIndex++;
        }

        penaltyState.phase =
          penaltyState.phase === "player_shoot"
            ? "player_save"
            : "player_shoot";

        // Reset and setup next round
        setupOnlinePenaltyPhase();
      }

      function endOnlinePenaltyGame() {
        stopCrowdSound();

        document.getElementById("surrenderBtn").style.display = "none";

        const result = document.getElementById("penaltyResult");
        const action = document.getElementById("penaltyAction");
        const buttons = document.getElementById("penaltyButtons");

        const won = penaltyState.playerScore > penaltyState.opponentScore;

        // Get arena rewards (same as offline)
        const arenaId = onlinePenaltyState.arena || GameState.arena.current;
        const arena = ARENAS.find((a) => a.id === arenaId) || ARENAS[0];

        let bonus, tpEarned;
        if (won) {
          bonus = arena.winReward;
          tpEarned = arena.tpReward;
          result.textContent = t("youWin");
          result.className = "penalty-result goal";
        } else {
          bonus = -arena.loseReward;
          tpEarned = Math.floor(arena.tpReward / 4); // 25% TP on loss
          result.textContent = t("youLose");
          result.className = "penalty-result miss";
        }

        // Calculate match ratings for online match
        calculateMatchRatings(
          won,
          penaltyState.playerScore,
          penaltyState.opponentScore
        );

        // Check for injuries after online match (20% chance)
        checkForInjuries();
        checkWrongPositionPenalties();

        // Apply rewards
        GameState.manager.balance += bonus;
        GameState.trainingPoints += tpEarned;
        updateAccountDisplay();
        autoSave();

        action.textContent = `${t("finalScore")}: ${
          penaltyState.playerScore
        } - ${penaltyState.opponentScore}`;

        // Show exit button only
        buttons.innerHTML = `
                <button class="penalty-btn" onclick="exitOnlinePenalty()">🚪 ${t(
                  "exitGame"
                )}</button>
            `;
        buttons.style.display = "flex";

        // Show reward alert
        setTimeout(() => {
          const tpText = tpEarned > 0 ? `\n🎯 +${tpEarned} TP` : "";
          if (bonus >= 0) {
            alert(
              `${t("congrats")}\n\n${t(
                "reward"
              )}: +€${bonus.toLocaleString()}${tpText}`
            );
          } else {
            alert(
              `${t("lost")}\n\n${
                currentLang === "pl" ? "Strata" : "Lost"
              }: €${Math.abs(bonus).toLocaleString()}${tpText}`
            );
          }
        }, 500);
      }

      function exitOnlinePenalty() {
        if (penaltyConn) penaltyConn.close();
        if (penaltyPeer) penaltyPeer.destroy();
        penaltyConn = null;
        penaltyPeer = null;
        isOnlinePenalty = false;
        isPenaltyHost = false;

        // Full reset of penalty state
        penaltyState = {
          round: 1,
          maxRounds: 5,
          playerScore: 0,
          opponentScore: 0,
          playerShots: [],
          opponentShots: [],
          phase: "player_shoot",
          shooters: [],
          opponentShooters: [],
          currentShooterIndex: 0,
          selectedDirection: null,
          opponentOVR: 50,
          lastShooter: null,
          currentShooter: null,
          timeLeft: 15,
        };

        // Reset online state
        onlinePenaltyState = {
          myChoice: null,
          opponentChoice: null,
          phase: "waiting",
        };

        // Reset UI elements
        const result = document.getElementById("penaltyResult");
        const action = document.getElementById("penaltyAction");
        const buttons = document.getElementById("penaltyButtons");

        if (result) {
          result.textContent = "";
          result.className = "penalty-result";
        }
        if (action) action.textContent = "";

        // Restore direction buttons
        if (buttons) {
          buttons.innerHTML = `
                    <button class="penalty-btn" onclick="selectPenaltyDirection('left')">⬅️ ${
                      currentLang === "pl" ? "LEWO" : "LEFT"
                    }</button>
                    <button class="penalty-btn" onclick="selectPenaltyDirection('center')">⬆️ ${
                      currentLang === "pl" ? "ŚRODEK" : "CENTER"
                    }</button>
                    <button class="penalty-btn" onclick="selectPenaltyDirection('right')">➡️ ${
                      currentLang === "pl" ? "PRAWO" : "RIGHT"
                    }</button>
                `;
          buttons.style.display = "flex";
        }

        document.getElementById("penaltyScorePlayer").textContent = "0";
        document.getElementById("penaltyScoreOpponent").textContent = "0";

        // Reset GK and ball positions
        const gk = document.getElementById("penaltyGK");
        const ball = document.getElementById("penaltyBall");
        if (gk) gk.className = "goalkeeper-penalty";
        if (ball) ball.className = "ball-penalty";

        // Reset goal zones
        document
          .querySelectorAll(".goal-zone")
          .forEach((z) => (z.className = "goal-zone " + z.dataset.zone));

        // Reset dots
        document
          .querySelectorAll("#playerDots .dot, #opponentDots .dot")
          .forEach((dot) => {
            dot.className = "dot";
          });

        // Reset lobby UI
        document.getElementById("onlinePenaltyChoice").style.display = "block";
        document.getElementById("hostPenaltySection").style.display = "none";
        document.getElementById("guestPenaltySection").style.display = "none";
        document.getElementById("joinPenaltyInput").value = "";

        showScreen("mainMenu");
      }

      function surrenderOnlinePenalties() {
        if (confirm(t("surrenderConfirm"))) {
          if (penaltyConn && penaltyConn.open) {
            penaltyConn.send({ type: "surrender" });
          }
          // I lose
          penaltyState.playerScore = 0;
          penaltyState.opponentScore = 5;
          endOnlinePenaltyGame();
        }
      }

      function exitOnlinePenalties() {
        stopCrowdSound();
        if (penaltyConn) penaltyConn.close();
        if (penaltyPeer) penaltyPeer.destroy();
        penaltyConn = null;
        penaltyPeer = null;
        isOnlinePenalty = false;
        showScreen("playMenu");
      }

      // ==================== TURN-BASED MATCH SYSTEM ====================
      let matchState = {
        paused: false,
        phase: "player", // 'player', 'executing', 'opponent'
        turnTime: 10,
        turnTimer: null,
        ballHolder: null,
        ballHolderTeam: "player",
        ballPos: { x: 50, y: 70 },
        playerPositions: [],
        opponentPositions: [],
        playerCards: {},
        crowdAudio: null,
        lastScorer: null,
        // Camera
        cameraAngle: 0, // rotation angle
        isDraggingCamera: false,
        lastMouseX: 0,
        // Click detection
        clickCount: 0,
        clickTimer: null,
        isDragging: false,
        dragStart: null,
      };

      // Stadium crowd sounds
      // Global crowd audio (for penalties and matches)
      let crowdAudio = null;

      function initCrowdSound() {
        if (crowdAudio) return; // Already initialized

        try {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          const audioCtx = new AudioContext();

          // Resume if suspended (browser policy)
          if (audioCtx.state === "suspended") {
            audioCtx.resume();
          }

          const bufferSize = 2 * audioCtx.sampleRate;
          const noiseBuffer = audioCtx.createBuffer(
            1,
            bufferSize,
            audioCtx.sampleRate
          );
          const output = noiseBuffer.getChannelData(0);

          for (let i = 0; i < bufferSize; i++) {
            output[i] = Math.random() * 2 - 1;
          }

          const whiteNoise = audioCtx.createBufferSource();
          whiteNoise.buffer = noiseBuffer;
          whiteNoise.loop = true;

          const filter = audioCtx.createBiquadFilter();
          filter.type = "lowpass";
          filter.frequency.value = 400;

          const gain = audioCtx.createGain();
          gain.gain.value = 0.2; // Głośniejsze tło

          whiteNoise.connect(filter);
          filter.connect(gain);
          gain.connect(audioCtx.destination);

          whiteNoise.start();
          crowdAudio = { ctx: audioCtx, gain: gain, source: whiteNoise };
          matchState.crowdAudio = crowdAudio;
        } catch (e) {
          console.log("Audio error:", e);
        }
      }

      function stopCrowdSound() {
        if (crowdAudio) {
          try {
            crowdAudio.source.stop();
          } catch (e) {}
          crowdAudio = null;
          matchState.crowdAudio = null;
        }
      }

      function startBotGame(difficulty) {
        GameState.match.difficulty = difficulty;
        startMatch("bot");
      }

      function startMatch(mode) {
        GameState.match.mode = mode;
        GameState.match.score = [0, 0];
        GameState.match.time = 0;
        matchState.paused = false;
        matchState.phase = "player";
        matchState.ballHolder = 9; // ST starts
        matchState.ballHolderTeam = "player";
        matchState.playerCards = {};
        matchState.lastScorer = null;
        matchState.cameraAngle = 0;
        matchState.playerCards = {};
        matchState.playerActions = [];
        matchState.opponentActions = [];
        matchState.lastScorer = null;

        document.getElementById("team1Score").textContent = "0";
        document.getElementById("team2Score").textContent = "0";
        document.getElementById("matchTime").textContent = "00:00";

        const cardsDisplay = document.getElementById("cardsDisplay");
        if (cardsDisplay) cardsDisplay.innerHTML = "";

        showScreen("matchScreen");
        initMatchView3D();
        initCrowdSound();
        startMatchTimer();
        startTurn();
      }

      function initMatchView3D() {
        createMatchPlayers3D();
        createBall3D();
        updateBallHolder3D();
        setupMatchControls3D();
        updateCamera();
      }

      function setupMatchControls3D() {
        const screen = document.getElementById("matchScreen3d");
        if (!screen) return;

        // Right click for camera rotation
        screen.addEventListener("contextmenu", (e) => e.preventDefault());

        screen.addEventListener("mousedown", (e) => {
          if (e.button === 2) {
            // Right click
            matchState.isDraggingCamera = true;
            matchState.lastMouseX = e.clientX;
          } else if (
            e.button === 0 &&
            matchState.phase === "player" &&
            matchState.ballHolderTeam === "player"
          ) {
            // Left click - start potential drag for pass
            matchState.dragStart = { x: e.clientX, y: e.clientY };
            matchState.isDragging = false;
          }
        });

        screen.addEventListener("mousemove", (e) => {
          if (matchState.isDraggingCamera) {
            const deltaX = e.clientX - matchState.lastMouseX;
            matchState.cameraAngle += deltaX * 0.3;
            matchState.lastMouseX = e.clientX;
            updateCamera();
          }

          if (matchState.dragStart) {
            const dx = e.clientX - matchState.dragStart.x;
            const dy = e.clientY - matchState.dragStart.y;
            if (Math.sqrt(dx * dx + dy * dy) > 20) {
              matchState.isDragging = true;
              showPassLine(e.clientX, e.clientY);
            }
          }
        });

        screen.addEventListener("mouseup", (e) => {
          if (e.button === 2) {
            matchState.isDraggingCamera = false;
          } else if (e.button === 0) {
            if (matchState.isDragging && matchState.dragStart) {
              // Execute pass
              executePass3D(e.clientX, e.clientY);
              hidePassLine();
            } else if (
              matchState.phase === "player" &&
              matchState.ballHolderTeam === "player"
            ) {
              // Click - check for double
              handleClick(e);
            }
            matchState.dragStart = null;
            matchState.isDragging = false;
          }
        });
      }

      function handleClick(e) {
        matchState.clickCount++;

        if (matchState.clickCount === 1) {
          matchState.clickTimer = setTimeout(() => {
            // Single click = dribble
            executeDribble3D(false);
            matchState.clickCount = 0;
          }, 250);
        } else if (matchState.clickCount === 2) {
          clearTimeout(matchState.clickTimer);
          // Double click = sprint
          executeDribble3D(true);
          matchState.clickCount = 0;
        }
      }

      function updateCamera() {
        const pitch = document.getElementById("matchPitch3d");
        if (!pitch) return;

        // Camera follows ball holder
        let targetX = 50,
          targetY = 50;
        if (matchState.ballHolder !== null) {
          const positions =
            matchState.ballHolderTeam === "player"
              ? matchState.playerPositions
              : matchState.opponentPositions;
          const pos = positions[matchState.ballHolder];
          if (pos) {
            targetX = pos.x;
            targetY = pos.y;
          }
        }

        // Apply camera transform - behind player looking towards opponent goal
        const translateX = -(targetX - 50) * 2;
        const translateY = -(targetY - 30) * 2;

        pitch.style.transform = `
                rotateX(70deg) 
                rotateZ(${matchState.cameraAngle}deg)
                translateX(${translateX}%)
                translateY(${translateY}%)
            `;
      }

      function showPassLine(mouseX, mouseY) {
        const svg = document.getElementById("passLineSvg");
        const line = document.getElementById("passLine");
        if (!svg || !line) return;

        svg.style.display = "block";

        const rect = svg.getBoundingClientRect();
        const startX = rect.width / 2;
        const startY = rect.height * 0.7;

        line.setAttribute("x1", startX);
        line.setAttribute("y1", startY);
        line.setAttribute("x2", mouseX - rect.left);
        line.setAttribute("y2", mouseY - rect.top);
      }

      function hidePassLine() {
        const svg = document.getElementById("passLineSvg");
        if (svg) svg.style.display = "none";
      }

      function createMatchPlayers3D() {
        const pitch = document.getElementById("matchPitch3d");
        if (!pitch) return;

        // Remove old players
        pitch
          .querySelectorAll(".player-3d, .ball-3d")
          .forEach((p) => p.remove());

        const formation = Formations[GameState.squad.formation];

        // Player team - positioned at bottom half (y: 50-95)
        matchState.playerPositions = formation.map((slot, index) => ({
          x: slot.x,
          y: 50 + slot.y * 0.45, // Scale to bottom half
          baseX: slot.x,
          baseY: 50 + slot.y * 0.45,
          player: GameState.squad.players[index],
          index: index,
        }));

        matchState.playerPositions.forEach((pos, index) => {
          const el = createPlayer3DElement(pos.player, index, false);
          el.style.left = `${pos.x}%`;
          el.style.top = `${pos.y}%`;
          pitch.appendChild(el);
        });

        // Opponent team - positioned at top half (y: 5-50)
        matchState.opponentPositions = formation.map((slot, index) => ({
          x: 100 - slot.x,
          y: 50 - slot.y * 0.45, // Scale to top half, mirrored
          baseX: 100 - slot.x,
          baseY: 50 - slot.y * 0.45,
          player: generateBotPlayer(index),
          index: index,
        }));

        matchState.opponentPositions.forEach((pos, index) => {
          const el = createPlayer3DElement(pos.player, index, true);
          el.style.left = `${pos.x}%`;
          el.style.top = `${pos.y}%`;
          pitch.appendChild(el);
        });
      }

      function createPlayer3DElement(playerData, index, isOpponent) {
        const div = document.createElement("div");
        div.className = `player-3d ${isOpponent ? "opponent" : ""}`;
        div.dataset.index = index;
        div.dataset.team = isOpponent ? "opponent" : "player";

        const name = playerData?.name || "Gracz";
        const pos = playerData?.position || "CM";

        div.innerHTML = `
                <div class="player-3d-body">
                    <div class="head"></div>
                    <div class="body">
                        <span class="number">${
                          pos === "GK" ? "GK" : index + 1
                        }</span>
                    </div>
                    <div class="legs">
                        <div class="leg"></div>
                        <div class="leg"></div>
                    </div>
                </div>
                <div class="name-tag">${name.substring(0, 8)}</div>
            `;

        return div;
      }

      function createBall3D() {
        const pitch = document.getElementById("matchPitch3d");
        if (!pitch) return;

        const ball = document.createElement("div");
        ball.className = "ball-3d";
        ball.id = "matchBall3d";
        pitch.appendChild(ball);

        updateBallPosition3D();
      }

      function updateBallPosition3D() {
        const ball = document.getElementById("matchBall3d");
        if (!ball) return;

        let pos;
        if (matchState.ballHolder !== null) {
          const positions =
            matchState.ballHolderTeam === "player"
              ? matchState.playerPositions
              : matchState.opponentPositions;
          pos = positions[matchState.ballHolder];
        }

        if (pos) {
          ball.style.left = `${pos.x}%`;
          ball.style.top = `${pos.y + 3}%`;
          matchState.ballPos = { x: pos.x, y: pos.y };
        }
      }

      function updateBallHolder3D() {
        // Remove has-ball from all
        document
          .querySelectorAll(".player-3d")
          .forEach((p) => p.classList.remove("has-ball"));

        if (matchState.ballHolder !== null) {
          const selector =
            matchState.ballHolderTeam === "player"
              ? ".player-3d:not(.opponent)"
              : ".player-3d.opponent";
          const players = document.querySelectorAll(selector);
          if (players[matchState.ballHolder]) {
            players[matchState.ballHolder].classList.add("has-ball");
          }
        }

        updateBallPosition3D();
        updateHolderPanel();
      }

      function updateHolderPanel() {
        const nameEl = document.getElementById("holderName");
        const posEl = document.getElementById("holderPos");
        const statsEl = document.getElementById("holderStats");

        if (!nameEl || !posEl || !statsEl) return;

        if (
          matchState.ballHolder === null ||
          matchState.ballHolderTeam !== "player"
        ) {
          nameEl.textContent =
            matchState.ballHolderTeam === "opponent" ? "PRZECIWNIK" : "-";
          posEl.textContent = "";
          statsEl.innerHTML = "";
          return;
        }

        const pos = matchState.playerPositions[matchState.ballHolder];
        if (pos?.player) {
          nameEl.textContent = pos.player.name;
          posEl.textContent = pos.player.position;
          const stats = pos.player.stats || {};
          statsEl.innerHTML = `
                    <span>PAC: ${stats.Pace || pos.player.overall}</span>
                    <span>SHO: ${stats.Shooting || pos.player.overall}</span>
                    <span>PAS: ${stats.Passing || pos.player.overall}</span>
                `;
        }
      }

      // ==================== TURN SYSTEM ====================
      function startTurn() {
        matchState.turnTime = 10;

        const timerText = document.getElementById("turnTimerText");
        const timerBar = document.getElementById("turnTimerBar");
        const indicator = document.getElementById("turnIndicator");

        if (matchState.ballHolderTeam === "player") {
          matchState.phase = "player";
          if (timerText) timerText.textContent = "TWOJA TURA - 10s";
          if (indicator) {
            indicator.textContent = "TWOJA TURA";
            indicator.classList.remove("opponent");
          }
        } else {
          matchState.phase = "opponent";
          if (timerText) timerText.textContent = "TURA PRZECIWNIKA";
          if (indicator) {
            indicator.textContent = "TURA PRZECIWNIKA";
            indicator.classList.add("opponent");
          }
          // AI executes after short delay
          setTimeout(() => executeOpponentTurn(), 1000 + Math.random() * 2000);
        }

        updateCamera();
        updateHolderPanel();

        // Start countdown
        if (matchState.turnTimer) clearInterval(matchState.turnTimer);

        matchState.turnTimer = setInterval(() => {
          matchState.turnTime -= 0.1;

          if (timerBar) {
            timerBar.style.width = `${(matchState.turnTime / 10) * 100}%`;
          }

          if (timerText && matchState.ballHolderTeam === "player") {
            timerText.textContent = `TWOJA TURA - ${Math.ceil(
              matchState.turnTime
            )}s`;
          }

          if (matchState.turnTime <= 0) {
            clearInterval(matchState.turnTimer);
            // Time's up - auto dribble if player's turn
            if (matchState.phase === "player") {
              executeDribble3D(false);
            }
          }
        }, 100);
      }

      function executeDribble3D(isSprint) {
        if (matchState.phase !== "player") return;
        clearInterval(matchState.turnTimer);
        matchState.phase = "executing";

        const pos = matchState.playerPositions[matchState.ballHolder];
        if (!pos) {
          endTurn();
          return;
        }

        const player = pos.player;
        const pace = player?.stats?.Pace || player?.overall || 50;
        const dribbling = player?.stats?.Dribbling || player?.overall || 50;

        // Move forward (y decreases = towards opponent goal)
        const moveAmount = isSprint ? 15 : 8;
        const newY = Math.max(5, pos.y - moveAmount);

        // Sprint has higher chance of losing ball
        const loseChance = isSprint
          ? (100 - dribbling) / 200
          : (100 - dribbling) / 400;

        // Animate
        pos.y = newY;
        const playerEl = document.querySelectorAll(".player-3d:not(.opponent)")[
          matchState.ballHolder
        ];
        if (playerEl) {
          playerEl.style.top = `${newY}%`;
        }

        updateCamera();
        updateBallPosition3D();

        setTimeout(() => {
          // Check if near goal - can shoot
          if (newY < 25) {
            executeShoot3D();
            return;
          }

          // Check for tackle
          if (Math.random() < loseChance || checkTackle3D()) {
            return; // Ball lost, checkTackle handles turn change
          }

          endTurn();
        }, 500);
      }

      function executePass3D(mouseX, mouseY) {
        if (matchState.phase !== "player") return;
        clearInterval(matchState.turnTimer);
        matchState.phase = "executing";

        const fromPos = matchState.playerPositions[matchState.ballHolder];
        if (!fromPos) {
          endTurn();
          return;
        }

        // Find nearest player to mouse direction
        const screen = document.getElementById("matchScreen3d");
        const rect = screen.getBoundingClientRect();
        const relX = ((mouseX - rect.left) / rect.width) * 100;
        const relY = ((mouseY - rect.top) / rect.height) * 100;

        let nearestPlayer = null;
        let nearestDist = Infinity;

        matchState.playerPositions.forEach((pos, i) => {
          if (i === matchState.ballHolder) return;
          const dist = Math.sqrt(
            Math.pow(pos.x - relX, 2) + Math.pow(pos.y - relY, 2)
          );
          if (dist < nearestDist) {
            nearestDist = dist;
            nearestPlayer = i;
          }
        });

        if (nearestPlayer === null) {
          endTurn();
          return;
        }

        const toPos = matchState.playerPositions[nearestPlayer];
        const passer = fromPos.player;
        const passing = passer?.stats?.Passing || passer?.overall || 50;

        // Calculate success chance
        const distance = Math.sqrt(
          Math.pow(toPos.x - fromPos.x, 2) + Math.pow(toPos.y - fromPos.y, 2)
        );
        const successChance = Math.min(0.95, passing / 100 - distance / 300);

        // Animate ball
        const ball = document.getElementById("matchBall3d");
        if (ball) {
          ball.style.left = `${toPos.x}%`;
          ball.style.top = `${toPos.y}%`;
        }

        setTimeout(() => {
          if (Math.random() < successChance) {
            // Pass successful
            matchState.ballHolder = nearestPlayer;
            updateBallHolder3D();
          } else {
            // Intercepted
            let nearestOpp = 0;
            let nearestOppDist = Infinity;
            matchState.opponentPositions.forEach((p, i) => {
              const dist = Math.sqrt(
                Math.pow(p.x - toPos.x, 2) + Math.pow(p.y - toPos.y, 2)
              );
              if (dist < nearestOppDist) {
                nearestOppDist = dist;
                nearestOpp = i;
              }
            });
            matchState.ballHolder = nearestOpp;
            matchState.ballHolderTeam = "opponent";
            updateBallHolder3D();
          }
          endTurn();
        }, 500);
      }

      function executeShoot3D() {
        matchState.phase = "executing";

        const pos = matchState.playerPositions[matchState.ballHolder];
        if (!pos) {
          endTurn();
          return;
        }

        const shooter = pos.player;
        const shooting = shooter?.stats?.Shooting || shooter?.overall || 50;

        // Animate ball to goal
        const ball = document.getElementById("matchBall3d");
        if (ball) {
          ball.classList.add("shooting");
          ball.style.left = "50%";
          ball.style.top = "2%";
        }

        // Goal chance based on shooting and distance
        const distance = pos.y;
        const goalChance = (shooting / 100) * (1 - distance / 100);

        setTimeout(() => {
          if (ball) {
            ball.classList.remove("shooting");
          }

          if (Math.random() < goalChance) {
            // GOAL!
            scoreGoal(true);
          } else {
            // Saved - opponent GK gets ball
            matchState.ballHolder = 0;
            matchState.ballHolderTeam = "opponent";
            updateBallHolder3D();
            endTurn();
          }
        }, 800);
      }

      function executeOpponentTurn() {
        if (matchState.phase !== "opponent") return;
        clearInterval(matchState.turnTimer);
        matchState.phase = "executing";

        const pos = matchState.opponentPositions[matchState.ballHolder];
        if (!pos) {
          endTurn();
          return;
        }

        // AI decision
        const canShoot = pos.y > 75; // Near player's goal

        if (canShoot && Math.random() < 0.5) {
          // Shoot
          const shooting =
            pos.player?.stats?.Shooting || pos.player?.overall || 50;
          const goalChance = shooting / 150;

          setTimeout(() => {
            if (Math.random() < goalChance) {
              scoreGoal(false);
            } else {
              // Saved
              matchState.ballHolder = 0; // Your GK
              matchState.ballHolderTeam = "player";
              updateBallHolder3D();
              endTurn();
            }
          }, 800);
        } else if (Math.random() < 0.4) {
          // Pass
          const teammates = matchState.opponentPositions.filter(
            (p, i) => i !== matchState.ballHolder
          );
          const target =
            teammates[Math.floor(Math.random() * teammates.length)];
          const targetIndex = matchState.opponentPositions.indexOf(target);

          matchState.ballHolder = targetIndex;
          updateBallHolder3D();
          setTimeout(() => endTurn(), 500);
        } else {
          // Dribble forward
          const newY = Math.min(95, pos.y + 10);
          pos.y = newY;

          const oppEl = document.querySelectorAll(".player-3d.opponent")[
            matchState.ballHolder
          ];
          if (oppEl) {
            oppEl.style.top = `${newY}%`;
          }

          updateBallPosition3D();

          setTimeout(() => {
            if (checkTackle3D()) return;
            endTurn();
          }, 500);
        }
      }
      function scoreGoal(isPlayer) {
        if (isPlayer) {
          GameState.match.score[0]++;
          document.getElementById("team1Score").textContent =
            GameState.match.score[0];
        } else {
          GameState.match.score[1]++;
          document.getElementById("team2Score").textContent =
            GameState.match.score[1];
        }

        matchState.lastScorer = isPlayer ? "player" : "opponent";

        // Show celebration
        const celebration = document.getElementById("goalCelebration");
        if (celebration) {
          celebration.classList.add("active");
          playGoalSound();

          setTimeout(() => {
            celebration.classList.remove("active");
            resetAfterGoal3D();
          }, 2500);
        } else {
          resetAfterGoal3D();
        }
      }

      function resetAfterGoal3D() {
        // Opponent starts from center after goal
        matchState.ballHolder = 9; // Forward/ST
        matchState.ballHolderTeam =
          matchState.lastScorer === "player" ? "opponent" : "player";

        // Reset positions
        createMatchPlayers3D();
        createBall3D();
        updateBallHolder3D();

        startTurn();
      }

      function checkTackle3D() {
        const holderPositions =
          matchState.ballHolderTeam === "player"
            ? matchState.playerPositions
            : matchState.opponentPositions;
        const opposingPositions =
          matchState.ballHolderTeam === "player"
            ? matchState.opponentPositions
            : matchState.playerPositions;

        const holderPos = holderPositions[matchState.ballHolder];
        if (!holderPos) return false;

        for (let i = 0; i < opposingPositions.length; i++) {
          const oppPos = opposingPositions[i];
          const dist = Math.sqrt(
            Math.pow(oppPos.x - holderPos.x, 2) +
              Math.pow(oppPos.y - holderPos.y, 2)
          );

          if (dist < 8) {
            const defender = oppPos.player;
            const defending =
              defender?.stats?.Defending || defender?.overall || 50;
            const tackleChance = defending / 150;
            const foulChance = (100 - defending) / 300;

            if (Math.random() < foulChance) {
              // Foul!
              commitFoul3D(i);
              return true;
            } else if (Math.random() < tackleChance) {
              // Clean tackle
              matchState.ballHolder = i;
              matchState.ballHolderTeam =
                matchState.ballHolderTeam === "player" ? "opponent" : "player";
              updateBallHolder3D();
              return true;
            }
          }
        }
        return false;
      }

      function commitFoul3D(playerIndex) {
        const foulMsg = document.getElementById("foulMessage");
        if (foulMsg) {
          foulMsg.classList.add("active");
          setTimeout(() => foulMsg.classList.remove("active"), 1500);
        }

        // Possible card
        if (Math.random() < 0.25) {
          const isRed = Math.random() < 0.1;
          showCard(isRed ? "red" : "yellow", playerIndex);
        }

        // Free kick - keep ball with fouled team
        setTimeout(() => endTurn(), 1500);
      }

      function endTurn() {
        // Switch possession or continue
        matchState.phase = "action";
        matchState.playerActions = [];
        matchState.opponentActions = [];

        // Move other players slightly towards their base positions
        movePlayersToBase();

        setTimeout(() => startTurn(), 500);
      }

      function movePlayersToBase() {
        const formation = Formations[GameState.squad.formation];

        // Player team
        const playerEls = document.querySelectorAll(
          ".player-3d:not(.opponent)"
        );
        matchState.playerPositions.forEach((pos, i) => {
          if (
            i === matchState.ballHolder &&
            matchState.ballHolderTeam === "player"
          )
            return;

          // Move towards base
          pos.x += (pos.baseX - pos.x) * 0.3;
          pos.y += (pos.baseY - pos.y) * 0.3;

          if (playerEls[i]) {
            playerEls[i].style.left = `${pos.x}%`;
            playerEls[i].style.top = `${pos.y}%`;
          }
        });

        // Opponent team
        const oppEls = document.querySelectorAll(".player-3d.opponent");
        matchState.opponentPositions.forEach((pos, i) => {
          if (
            i === matchState.ballHolder &&
            matchState.ballHolderTeam === "opponent"
          )
            return;

          pos.x += (pos.baseX - pos.x) * 0.3;
          pos.y += (pos.baseY - pos.y) * 0.3;

          if (oppEls[i]) {
            oppEls[i].style.left = `${pos.x}%`;
            oppEls[i].style.top = `${pos.y}%`;
          }
        });
      }

      function showCard(color, playerIndex) {
        const cardDisplay = document.getElementById("cardDisplay");
        if (cardDisplay) {
          cardDisplay.className = `card-display ${color}`;
          setTimeout(() => {
            cardDisplay.className = "card-display";
          }, 1500);
        }
      }

      function pauseMatch() {
        matchState.paused = !matchState.paused;
        if (matchState.paused) {
          clearInterval(matchState.turnTimer);
        } else {
          startTurn();
        }
      }

      function exitMatch() {
        if (confirm(t("exitMatchConfirm"))) {
          clearInterval(matchState.turnTimer);
          if (matchTimerInterval) clearInterval(matchTimerInterval);
          stopCrowdSound();
          showScreen("mainMenu");
        }
      }

      let matchTimerInterval = null;
      function startMatchTimer() {
        if (matchTimerInterval) clearInterval(matchTimerInterval);

        matchTimerInterval = setInterval(() => {
          if (matchState.paused) return;

          GameState.match.time++;
          const mins = Math.floor(GameState.match.time / 60);
          const secs = GameState.match.time % 60;

          const timeEl = document.getElementById("matchTime");
          if (timeEl) {
            timeEl.textContent = `${mins.toString().padStart(2, "0")}:${secs
              .toString()
              .padStart(2, "0")}`;
          }

          // Match ends after 90 seconds (representing 90 minutes)
          if (GameState.match.time >= 90) {
            endMatch();
          }
        }, 1000);
      }

      function endMatch() {
        clearInterval(matchTimerInterval);
        clearInterval(matchState.turnTimer);
        stopCrowdSound();

        const playerScore = GameState.match.score[0];
        const oppScore = GameState.match.score[1];

        // Update stats
        GameState.stats.matchesPlayed++;
        GameState.stats.goalsScored += playerScore;
        GameState.stats.goalsConceded += oppScore;

        let result = "";
        let earnings = 0;

        if (playerScore > oppScore) {
          result = t("victory");
          earnings =
            5000 +
            (GameState.match.difficulty === "hard"
              ? 5000
              : GameState.match.difficulty === "medium"
              ? 2500
              : 1000);
          GameState.stats.matchesWon++;
        } else if (playerScore < oppScore) {
          result = t("defeat");
          earnings = 500;
          GameState.stats.matchesLost++;
        } else {
          result = t("draw");
          earnings = 2000;
          GameState.stats.matchesDraw++;
        }

        GameState.manager.balance += earnings;
        updateAccountDisplay();
        autoSave(); // Save after match

        alert(
          `${result}\n\n${t("result")}: ${playerScore} : ${oppScore}\n${t(
            "earnings"
          )}: €${earnings.toLocaleString()}\n\n📊 ${t("stats")}:\n${t(
            "matches"
          )}: ${GameState.stats.matchesPlayed} | ${t("wins")}: ${
            GameState.stats.matchesWon
          } ${t("draws")}: ${GameState.stats.matchesDraw} ${t("losses")}: ${
            GameState.stats.matchesLost
          }`
        );
        showScreen("mainMenu");
      }

      function generateBotPlayer(index) {
        let baseOverall = 40;
        switch (GameState.match.difficulty) {
          case "easy":
            baseOverall = 30;
            break;
          case "medium":
            baseOverall = 50;
            break;
          case "hard":
            baseOverall = 75;
            break;
        }

        const positions = [
          "GK",
          "CB",
          "CB",
          "LB",
          "RB",
          "CM",
          "CM",
          "CM",
          "LW",
          "ST",
          "RW",
        ];
        return generatePlayer(
          baseOverall + Math.floor(Math.random() * 20) - 10,
          positions[index]
        );
      }

      // ==================== UPGRADE SYSTEM ====================
      let currentUpgradePlayer = null;
      let currentUpgradeStat = null;
      let currentUpgradePosition = null;
      let upgradeTab = "squad";

      const PositionCategories = {
        GK: "goalkeeper",
        CB: "defender",
        LB: "defender",
        RB: "defender",
        LWB: "defender",
        RWB: "defender",
        CDM: "midfielder",
        CM: "midfielder",
        CAM: "midfielder",
        LM: "midfielder",
        RM: "midfielder",
        LW: "attacker",
        RW: "attacker",
        CF: "attacker",
        ST: "attacker",
      };

      function getPositionChangeCostTP(fromPos, toPos) {
        const fromCat = PositionCategories[fromPos];
        const toCat = PositionCategories[toPos];

        if (fromPos === toPos) return 0;
        if (fromCat === "goalkeeper" || toCat === "goalkeeper") return 100; // GK change very expensive
        if (fromCat === toCat) return 10; // Same category (e.g. ST -> CF)

        // Adjacent categories
        const adjacent = {
          defender: ["midfielder"],
          midfielder: ["defender", "attacker"],
          attacker: ["midfielder"],
        };

        if (adjacent[fromCat]?.includes(toCat)) return 30; // Adjacent (e.g. CM -> LW)
        return 50; // Opposite (defender <-> attacker)
      }

      function switchUpgradeTab(tab) {
        upgradeTab = tab;
        document.querySelectorAll(".upgrade-tab").forEach((t) => {
          t.classList.toggle("active", t.dataset.tab === tab);
        });
        renderUpgradePlayers();
      }

      function renderUpgradePlayers() {
        const grid = document.getElementById("upgradePlayersGrid");
        if (!grid) return;

        const players =
          upgradeTab === "squad"
            ? GameState.squad.players
            : GameState.squad.bench;
        const emptyText =
          currentLang === "pl"
            ? `Brak zawodników ${
                upgradeTab === "squad" ? "w składzie" : "na ławce"
              }`
            : `No players ${upgradeTab === "squad" ? "in squad" : "on bench"}`;

        if (!players || players.filter((p) => p).length === 0) {
          grid.innerHTML = `<div style="grid-column: 1/-1; text-align: center; color: var(--silver); padding: 2rem;">
                    ${emptyText}
                </div>`;
          return;
        }

        grid.innerHTML = players
          .map((player, index) => {
            if (!player) return "";
            return `
                    <div class="upgrade-player-card" onclick="openUpgradeModal('${upgradeTab}', ${index})">
                        ${renderPlayerCard(player, false)}
                    </div>
                `;
          })
          .join("");

        // Update balance display
        const balanceEl = document.getElementById("upgradeBalance");
        if (balanceEl)
          balanceEl.textContent = `€${GameState.manager.balance.toLocaleString()}`;
      }

      function openUpgradeModal(source, index) {
        const players =
          source === "squad" ? GameState.squad.players : GameState.squad.bench;
        const player = players[index];
        if (!player) return;

        currentUpgradePlayer = { source, index, player };
        currentUpgradeStat = null;
        currentUpgradePosition = null;

        // Update modal
        const nameEl = document.getElementById("upgradePlayerName");
        const detailsEl = document.getElementById("upgradePlayerDetails");
        const previewEl = document.getElementById("upgradeCardPreview");

        if (nameEl) nameEl.textContent = player.name;
        if (detailsEl)
          detailsEl.textContent = `${player.position} | ${player.country} | OVR ${player.overall}`;
        if (previewEl) previewEl.innerHTML = renderPlayerCard(player, true);

        // Render stats
        renderUpgradeStats(player);

        // Render positions
        renderUpgradePositions(player);

        // Update cost
        updateUpgradeCost();

        // Show modal
        const modal = document.getElementById("upgradeModal");
        if (modal) modal.classList.add("active");
      }

      function renderUpgradePositions(player) {
        const container = document.getElementById("upgradePositionsList");
        const costInfo = document.getElementById("positionCostInfo");
        if (!container) return;

        const allPositions = [
          "GK",
          "CB",
          "LB",
          "RB",
          "CDM",
          "CM",
          "CAM",
          "LM",
          "RM",
          "LW",
          "RW",
          "CF",
          "ST",
        ];
        const playerPositions = player.positions || [player.position];

        container.innerHTML = allPositions
          .map((pos) => {
            const isCurrent = playerPositions.includes(pos);
            const cost = getPositionChangeCostTP(player.position, pos);

            return `
                    <button class="position-btn ${isCurrent ? "current" : ""}"
                            data-pos="${pos}"
                            data-cost="${cost}"
                            ${isCurrent ? "disabled" : ""}
                            onclick="selectUpgradePosition('${pos}', ${cost})">
                        ${pos}
                        ${
                          isCurrent
                            ? `<small>(✓)</small>`
                            : `<small>${cost} TP</small>`
                        }
                    </button>
                `;
          })
          .join("");

        if (costInfo) {
          const sameText =
            currentLang === "pl" ? "Ta sama kategoria" : "Same category";
          const nearText = currentLang === "pl" ? "Sąsiednia" : "Adjacent";
          const farText = currentLang === "pl" ? "Odległa" : "Distant";
          const gkText = currentLang === "pl" ? "Bramkarz" : "Goalkeeper";

          costInfo.innerHTML = `
                    <span style="color: var(--neon-green);">● ${sameText}: 10 TP</span> |
                    <span style="color: var(--gold);">● ${nearText}: 30 TP</span> |
                    <span style="color: #ff6b6b;">● ${farText}: 50 TP</span> |
                    <span style="color: #ff4444;">● ${gkText}: 100 TP</span>
                `;
        }
      }

      function selectUpgradePosition(pos, cost) {
        currentUpgradePosition = pos;
        currentUpgradeStat = null; // Deselect stat

        // Hide slider
        const sliderSection = document.getElementById("upgradeSliderSection");
        if (sliderSection) sliderSection.style.display = "none";

        // Update UI
        document.querySelectorAll(".position-btn").forEach((btn) => {
          btn.classList.toggle("selected", btn.dataset.pos === pos);
        });
        document.querySelectorAll(".upgrade-stat-btn").forEach((btn) => {
          btn.classList.remove("selected");
        });

        // Update button state with actual cost
        const btn = document.getElementById("confirmUpgradeBtn");
        const canAfford = (GameState.trainingPoints || 0) >= cost;
        if (btn) {
          btn.disabled = !canAfford;
          btn.style.opacity = canAfford ? "1" : "0.5";
          btn.textContent = `✅ ${t("confirmUpgrade")} (${cost} TP)`;
        }
      }

      function renderUpgradeStats(player) {
        const container = document.getElementById("upgradeStatsList");
        if (!container) return;

        const stats =
          player.position === "GK"
            ? [
                "Diving",
                "Handling",
                "Kicking",
                "Reflexes",
                "Positioning",
                "Speed",
              ]
            : [
                "Pace",
                "Shooting",
                "Passing",
                "Dribbling",
                "Defending",
                "Physical",
              ];

        const statNames =
          currentLang === "pl"
            ? {
                Pace: "Szybkość",
                Shooting: "Strzały",
                Passing: "Podania",
                Dribbling: "Drybling",
                Defending: "Obrona",
                Physical: "Siła",
                Diving: "Rzuty",
                Handling: "Chwyt",
                Kicking: "Wykopy",
                Reflexes: "Refleks",
                Positioning: "Ustawienie",
                Speed: "Szybkość",
              }
            : {
                Pace: "Pace",
                Shooting: "Shooting",
                Passing: "Passing",
                Dribbling: "Dribbling",
                Defending: "Defending",
                Physical: "Physical",
                Diving: "Diving",
                Handling: "Handling",
                Kicking: "Kicking",
                Reflexes: "Reflexes",
                Positioning: "Positioning",
                Speed: "Speed",
              };

        container.innerHTML = stats
          .map((stat) => {
            const value = player.stats?.[stat] || player.overall;
            const isMaxed = value >= 99;
            const newValue = Math.min(99, value + 1);

            return `
                    <div class="upgrade-stat-btn ${isMaxed ? "maxed" : ""}" 
                         data-stat="${stat}"
                         onclick="${
                           isMaxed ? "" : `selectUpgradeStat('${stat}')`
                         }">
                        <div class="stat-info">
                            <span class="upgrade-stat-name">${
                              statNames[stat]
                            }</span>
                            ${
                              isMaxed
                                ? `<span class="upgrade-stat-max">${t(
                                    "maxLevel"
                                  )}</span>`
                                : ""
                            }
                        </div>
                        <div class="stat-values">
                            <span class="upgrade-stat-value">${value}</span>
                            ${
                              !isMaxed
                                ? `<span class="stat-arrow">→</span><span class="stat-new-value">${newValue}</span>`
                                : ""
                            }
                        </div>
                    </div>
                `;
          })
          .join("");
      }

      function selectUpgradeStat(stat) {
        currentUpgradeStat = stat;
        currentUpgradePosition = null; // Deselect position

        // Update UI
        document.querySelectorAll(".upgrade-stat-btn").forEach((btn) => {
          btn.classList.toggle("selected", btn.dataset.stat === stat);
        });
        document.querySelectorAll(".position-btn").forEach((btn) => {
          btn.classList.remove("selected");
        });

        // Show slider
        const sliderSection = document.getElementById("upgradeSliderSection");
        if (sliderSection) {
          sliderSection.style.display = "block";

          const player = currentUpgradePlayer.player;
          const currentValue = player.stats?.[stat] || player.overall;
          const maxAdd = Math.min(99 - currentValue, 20); // Max 20 points at once

          const slider = document.getElementById("upgradeSlider");
          if (slider) {
            slider.max = Math.max(1, maxAdd);
            slider.value = 1;
          }

          document.getElementById("sliderMaxLabel").textContent = maxAdd;

          const statNames =
            currentLang === "pl"
              ? {
                  Pace: "Szybkość",
                  Shooting: "Strzały",
                  Passing: "Podania",
                  Dribbling: "Drybling",
                  Defending: "Obrona",
                  Physical: "Siła",
                  Diving: "Rzuty",
                  Handling: "Chwyt",
                  Kicking: "Wykopy",
                  Reflexes: "Refleks",
                  Positioning: "Ustawienie",
                  Speed: "Szybkość",
                }
              : {};

          document.getElementById("upgradeStatName").textContent =
            statNames[stat] || stat;
          document.getElementById("upgradeOldValue").textContent = currentValue;

          updateSliderValue();
        }
      }

      function updateSliderValue() {
        const slider = document.getElementById("upgradeSlider");
        const points = parseInt(slider?.value) || 1;

        document.getElementById("sliderValue").textContent = points;

        if (currentUpgradePlayer && currentUpgradeStat) {
          const player = currentUpgradePlayer.player;
          const currentValue =
            player.stats?.[currentUpgradeStat] || player.overall;
          const newValue = Math.min(99, currentValue + points);

          document.getElementById("upgradeNewValue").textContent = newValue;

          // Calculate TP cost - 3 TP per point
          const cost = points * 3;
          document.getElementById("sliderCost").textContent = cost + " TP";

          // Update button state
          const btn = document.getElementById("confirmUpgradeBtn");
          const canAfford = (GameState.trainingPoints || 0) >= cost;
          if (btn) {
            btn.disabled = !canAfford;
            btn.style.opacity = canAfford ? "1" : "0.5";
          }
        }
      }

      function calculateUpgradeCost(player, stat) {
        if (!player || !stat) return 0;

        const currentValue = player.stats?.[stat] || player.overall;

        // Cost increases exponentially with stat value
        // Base cost: 500€, doubles every 10 points
        const baseCost = 500;
        const multiplier = Math.pow(2, Math.floor(currentValue / 10));

        return Math.floor(baseCost * multiplier);
      }

      function updateUpgradeCost() {
        const costEl = document.getElementById("upgradeCost");
        const effectEl = document.getElementById("upgradeEffect");
        const btn = document.getElementById("confirmUpgradeBtn");

        if (!currentUpgradePlayer) {
          if (costEl) costEl.textContent = "€0";
          if (effectEl) effectEl.textContent = t("selectOption");
          if (btn) btn.disabled = true;
          return;
        }

        let cost = 0;
        let effectText = t("selectOption");

        const statNames =
          currentLang === "pl"
            ? {
                Pace: "Szybkość",
                Shooting: "Strzały",
                Passing: "Podania",
                Dribbling: "Drybling",
                Defending: "Obrona",
                Physical: "Siła",
                Diving: "Rzuty",
                Handling: "Chwyt",
                Kicking: "Wykopy",
                Reflexes: "Refleks",
                Positioning: "Ustawienie",
                Speed: "Szybkość",
              }
            : {};

        if (currentUpgradeStat) {
          cost = calculateUpgradeCost(
            currentUpgradePlayer.player,
            currentUpgradeStat
          );
          const currentValue =
            currentUpgradePlayer.player.stats?.[currentUpgradeStat] ||
            currentUpgradePlayer.player.overall;
          const statName = statNames[currentUpgradeStat] || currentUpgradeStat;
          effectText = `${statName}: ${currentValue} → ${currentValue + 1}`;
        } else if (currentUpgradePosition) {
          cost = getPositionChangeCost(
            currentUpgradePlayer.player.position,
            currentUpgradePosition
          );
          const posLabel = currentLang === "pl" ? "Pozycja" : "Position";
          effectText = `${posLabel}: +${currentUpgradePosition}`;
        }

        if (costEl) costEl.textContent = `€${cost.toLocaleString()}`;
        if (effectEl) effectEl.textContent = effectText;

        const canAfford = GameState.manager.balance >= cost;
        const hasSelection = currentUpgradeStat || currentUpgradePosition;

        if (btn) {
          btn.disabled = !canAfford || !hasSelection;
          btn.style.opacity = !canAfford || !hasSelection ? "0.5" : "1";
        }
      }

      function confirmUpgrade() {
        if (!currentUpgradePlayer) return;
        if (!currentUpgradeStat && !currentUpgradePosition) return;

        // Get the actual player reference
        const players =
          currentUpgradePlayer.source === "squad"
            ? GameState.squad.players
            : GameState.squad.bench;
        const player = players[currentUpgradePlayer.index];

        if (currentUpgradeStat) {
          // Stat upgrade with slider
          const slider = document.getElementById("upgradeSlider");
          const points = parseInt(slider?.value) || 1;
          const cost = points * 3; // 3 TP per point

          if ((GameState.trainingPoints || 0) < cost) {
            alert(t("notEnoughTP"));
            return;
          }

          GameState.trainingPoints -= cost;

          // Initialize stats object if needed
          if (!player.stats) {
            player.stats = {};
            const defaultStats =
              player.position === "GK"
                ? [
                    "Diving",
                    "Handling",
                    "Kicking",
                    "Reflexes",
                    "Positioning",
                    "Speed",
                  ]
                : [
                    "Pace",
                    "Shooting",
                    "Passing",
                    "Dribbling",
                    "Defending",
                    "Physical",
                  ];
            defaultStats.forEach((s) => {
              player.stats[s] = player.overall;
            });
          }

          // Upgrade the stat by selected points
          player.stats[currentUpgradeStat] = Math.min(
            99,
            (player.stats[currentUpgradeStat] || player.overall) + points
          );

          // Recalculate overall
          const statValues = Object.values(player.stats);
          player.overall = Math.round(
            statValues.reduce((a, b) => a + b, 0) / statValues.length
          );
        } else if (currentUpgradePosition) {
          // Position change - cost depends on distance
          const cost = getPositionChangeCostTP(
            player.position,
            currentUpgradePosition
          );

          if ((GameState.trainingPoints || 0) < cost) {
            alert(t("notEnoughTP"));
            return;
          }

          GameState.trainingPoints -= cost;

          // Update positions array (don't change main position, just add)
          if (!player.positions) player.positions = [player.position];
          if (!player.positions.includes(currentUpgradePosition)) {
            player.positions.push(currentUpgradePosition);
          }
        }

        // Update current player reference
        currentUpgradePlayer.player = player;

        // Refresh UI
        renderUpgradeStats(player);
        renderUpgradePositions(player);
        currentUpgradeStat = null;
        currentUpgradePosition = null;
        updateUpgradeCost();
        updateAccountDisplay();
        updateSquadOverall();
        autoSave(); // Save after upgrade

        // Update modal display
        const detailsEl = document.getElementById("upgradePlayerDetails");
        if (detailsEl)
          detailsEl.textContent = `${player.position} | ${player.country} | OVR ${player.overall}`;

        const previewEl = document.getElementById("upgradeCardPreview");
        if (previewEl) previewEl.innerHTML = renderPlayerCard(player, true);

        // Update balance in upgrade screen
        const balanceEl = document.getElementById("upgradeBalance");
        if (balanceEl)
          balanceEl.textContent = `€${GameState.manager.balance.toLocaleString()}`;

        // Show success message
        const effectEl = document.getElementById("upgradeEffect");
        if (effectEl) {
          effectEl.style.color = "#4ade80";
          effectEl.textContent = "✅ Sukces!";
          setTimeout(() => {
            effectEl.style.color = "#4ade80";
            updateUpgradeCost();
          }, 1000);
        }
      }

      function closeUpgradeModal() {
        const modal = document.getElementById("upgradeModal");
        if (modal) modal.classList.remove("active");
        currentUpgradePlayer = null;
        currentUpgradeStat = null;

        // Refresh player list
        renderUpgradePlayers();
      }

      function renderLegends() {
        const grid = document.getElementById("legendsGrid");
        const noLegends = document.getElementById("noLegends");

        if (!GameState.legends || GameState.legends.length === 0) {
          grid.style.display = "none";
          noLegends.style.display = "block";
          return;
        }

        grid.style.display = "grid";
        noLegends.style.display = "none";

        grid.innerHTML = GameState.legends
          .map(
            (legend) => `
                <div class="legend-card-wrapper" style="text-align: center;">
                    ${renderPlayerCard(legend)}
                    <div style="color: var(--gold); font-size: 0.8rem; margin-top: 0.5rem;">
                        ${t("age")}: ${legend.retiredAt || legend.age}
                    </div>
                </div>
            `
          )
          .join("");
      }

      function updateLanguageButtons() {
        document.querySelectorAll(".lang-btn").forEach((btn) => {
          btn.style.opacity = "0.6";
          btn.style.borderColor = "transparent";
        });
        const activeBtn = document.getElementById(
          currentLang === "pl" ? "langPL" : "langEN"
        );
        if (activeBtn) {
          activeBtn.style.opacity = "1";
          activeBtn.style.borderColor = "var(--gold)";
        }
      }

      function showInstructions() {
        document.getElementById("instructionsModal").classList.add("active");
      }

      function closeInstructions() {
        document.getElementById("instructionsModal").classList.remove("active");
      }

      function updateAccountDisplay() {
        const balance = GameState.manager.balance;
        const balanceStr = balance.toLocaleString();

        const accountEl = document.getElementById("accountBalance");
        const marketEl = document.getElementById("marketBalance");
        const transferEl = document.getElementById("transferListBalance");

        if (accountEl) accountEl.textContent = balanceStr;
        if (marketEl) marketEl.textContent = balanceStr;
        if (transferEl) transferEl.textContent = "€" + balanceStr;
      }

      // ==================== FORMATION SELECTOR ====================
      document
        .getElementById("formationSelector")
        .addEventListener("click", (e) => {
          if (e.target.classList.contains("formation-btn")) {
            document
              .querySelectorAll(".formation-btn")
              .forEach((b) => b.classList.remove("selected"));
            e.target.classList.add("selected");
            GameState.squad.formation = e.target.dataset.formation;
            renderPitch();
          }
        });

      // ==================== CHECK URL FOR ROOM ====================
      function checkUrlForRoom() {
        const params = new URLSearchParams(window.location.search);
        const penaltyRoom = params.get("room") || params.get("penalty");

        if (penaltyRoom) {
          // Auto-join penalty room
          showScreen("onlinePenaltyLobby");
          document.getElementById("joinPenaltyInput").value = penaltyRoom;
          // Auto-connect after short delay
          setTimeout(() => joinPenaltyRoom(), 500);
        }
      }

      function ensurePlayersHaveContracts() {
        // Add contracts and stats to players who don't have them (migration for old saves)
        const allPlayers = [
          ...(GameState.squad.players || []),
          ...(GameState.squad.bench || []),
        ];

        allPlayers.forEach((player) => {
          if (!player) return;

          if (!player.salary) {
            player.salary = Math.floor(
              player.overall * 50 + Math.random() * player.overall * 20
            );
          }
          if (!player.contractYears) {
            player.contractYears = 1 + Math.floor(Math.random() * 3);
          }
          if (!player.matchRatings) {
            player.matchRatings = [];
          }
          if (player.goals === undefined) {
            player.goals = 0;
          }
          if (player.assists === undefined) {
            player.assists = 0;
          }
          if (player.cleanSheets === undefined) {
            player.cleanSheets = 0;
          }
          if (player.saves === undefined) {
            player.saves = 0;
          }
          // Injury system
          if (player.injuredUntil === undefined) {
            player.injuredUntil = null; // timestamp when injury ends
          }
          if (player.originalPosition === undefined) {
            player.originalPosition = player.position; // save original position
          }
          if (player.wrongPositionMatches === undefined) {
            player.wrongPositionMatches = 0; // consecutive matches in wrong position
          }
          if (player.originalOverall === undefined) {
            player.originalOverall = player.overall; // save original overall
          }
        });

        autoSave();
      }

      // ==================== INITIALIZATION ====================
      document.addEventListener("DOMContentLoaded", () => {
        // Check for mobile device
        const isMobile =
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          ) || window.innerWidth < 768;

        if (isMobile) {
          document.getElementById("mobileBlock").style.display = "flex";
          return; // Stop initialization
        }

        // Try to load saved game first
        const hasLoad = loadGame();

        if (!hasLoad || GameState.squad.players.length === 0) {
          // New game - initialize default squad
          initializeSquad();
        }

        // Initialize arena if not exists
        if (!GameState.arena) {
          GameState.arena = { current: 1, unlocked: [1] };
        }

        // Initialize game time
        initGameTime();

        updateAccountDisplay();
        updateSquadOverall();
        updateArenaDisplay();
        checkUrlForRoom();
        updateAllText();
        updateEmailBadge();

        // Render squad initially so it's ready when squadScreen is shown
        renderPitch();

        // Ensure existing players have contracts
        ensurePlayersHaveContracts();

        // Load/set manager name
        const nameInput = document.getElementById("managerName");
        if (nameInput) {
          if (GameState.manager.name) {
            nameInput.value = GameState.manager.name;
          }

          nameInput.addEventListener("change", (e) => {
            GameState.manager.name = e.target.value;
            autoSave();
          });
        }

        // Show loaded message
        if (hasLoad) {
        }
      });
    </script>
  </body>
</html>
